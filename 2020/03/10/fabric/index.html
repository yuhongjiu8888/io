<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="区块链,">





  <link rel="alternate" href="/atom.xml" title="JackYu's Blog" type="application/atom+xml">






<meta name="description" content="Fabric简介​     Hyperledger Fabric 是一个模块化架构的分布式账本平台，提供高度的机密性，弹性，灵活性和可扩展性。它旨在支持不同组件的可插拔实现，并且可以容纳生态系统中存在的高度复杂应用。  超级账本项目为透明、公开、去中心化的企业级分布式账本技术提供开源参考实现。 区块链是什么1.分布式账本（A Distributed Ledger） 区块链网络的核心是一个分布式账本">
<meta name="keywords" content="区块链">
<meta property="og:type" content="article">
<meta property="og:title" content="Fabric源码分析">
<meta property="og:url" content="http://yoursite.com/2020/03/10/fabric/index.html">
<meta property="og:site_name" content="JackYu&#39;s Blog">
<meta property="og:description" content="Fabric简介​     Hyperledger Fabric 是一个模块化架构的分布式账本平台，提供高度的机密性，弹性，灵活性和可扩展性。它旨在支持不同组件的可插拔实现，并且可以容纳生态系统中存在的高度复杂应用。  超级账本项目为透明、公开、去中心化的企业级分布式账本技术提供开源参考实现。 区块链是什么1.分布式账本（A Distributed Ledger） 区块链网络的核心是一个分布式账本">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://hyperledger-fabric.readthedocs.io/en/latest/_images/basic_network.png">
<meta property="og:image" content="http://hyperledger-fabric.readthedocs.io/en/latest/_images/Smart_Contract.png">
<meta property="og:image" content="http://hyperledger-fabric.readthedocs.io/en/latest/_images/consensus.png">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-a77b25f8a3e4d7a4b5d005bbe5b6df89_720w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-45187b8292aa5ecab715b12a80825aa1_r.jpg">
<meta property="og:image" content="d:/其他/区块链研究/区块链笔记/chaincode.shim.start.png">
<meta property="og:image" content="d:/其他/区块链研究/区块链笔记/peer背书过程.jpg">
<meta property="og:image" content="d:/其他/区块链研究/区块链笔记/orderer核心过程.jpg">
<meta property="og:image" content="d:/其他/区块链研究/区块链笔记/-%20Orderer%20启动的整体过程.jpg">
<meta property="og:image" content="d:/其他/区块链研究/区块链笔记/Orderer节点broadcast处理过程.jpg">
<meta property="og:image" content="d:/其他/区块链研究/区块链笔记/Orderer%20节点%20Deliver%20处理过程.jpg">
<meta property="og:updated_time" content="2020-03-10T10:34:28.643Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fabric源码分析">
<meta name="twitter:description" content="Fabric简介​     Hyperledger Fabric 是一个模块化架构的分布式账本平台，提供高度的机密性，弹性，灵活性和可扩展性。它旨在支持不同组件的可插拔实现，并且可以容纳生态系统中存在的高度复杂应用。  超级账本项目为透明、公开、去中心化的企业级分布式账本技术提供开源参考实现。 区块链是什么1.分布式账本（A Distributed Ledger） 区块链网络的核心是一个分布式账本">
<meta name="twitter:image" content="http://hyperledger-fabric.readthedocs.io/en/latest/_images/basic_network.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/10/fabric/">





  <title>Fabric源码分析 | JackYu's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JackYu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Nothing is impossible!</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/10/fabric/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackYu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JackYu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Fabric源码分析</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-10T18:34:28+08:00">
                2020-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Fabric"><a href="#Fabric" class="headerlink" title="Fabric"></a>Fabric</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​     Hyperledger Fabric 是一个模块化架构的分布式账本平台，提供高度的机密性，弹性，灵活性和可扩展性。它旨在支持不同组件的可插拔实现，并且可以容纳生态系统中存在的高度复杂应用。  <strong>超级账本项目为透明、公开、去中心化的企业级分布式账本技术提供开源参考实现。</strong></p>
<h2 id="区块链是什么"><a href="#区块链是什么" class="headerlink" title="区块链是什么"></a>区块链是什么</h2><h3 id="1-分布式账本（A-Distributed-Ledger）"><a href="#1-分布式账本（A-Distributed-Ledger）" class="headerlink" title="1.分布式账本（A Distributed Ledger）"></a>1.<strong>分布式账本（A Distributed Ledger）</strong></h3><p> 区块链网络的核心是一个分布式账本，用于记录在网络上发生的所有交易。区块链账本通常被描述为去中心化的，因为它被复制到许多网络参与者中，每个参与者都在协作维护。我们将看到，分权和协作是反映企业在现实世界中交换产品和服务方式的强大属性。 </p>
<p> <img src="http://hyperledger-fabric.readthedocs.io/en/latest/_images/basic_network.png" alt="img"> </p>
<p> 除了去中心化和协作之外，记录在区块链中的信息只能追加，使用加密技术可保证一旦交易添加在账本中，便无法对其进行修改。这种无法篡改的特性使得判断信息的来源变得很简单，因为参与者可以肯定信息在事后没有被改变。这就是区块链有时被描述为<strong>证明体系</strong>的原因。 </p>
<h3 id="2-智能合约（Smart-Contracts）"><a href="#2-智能合约（Smart-Contracts）" class="headerlink" title="2.智能合约（Smart Contracts）"></a><strong>2.智能合约（Smart Contracts）</strong></h3><p> 为了支持信息一致性更新 —— 启用一整作用于账本的功能（交易，查询等） —— 区块链网络使用智能合约来提供对账本访问控制。 </p>
<p> <img src="http://hyperledger-fabric.readthedocs.io/en/latest/_images/Smart_Contract.png" alt="img"> </p>
<p> 智能合约不仅是简单的封装信息在整个网络中同步，它们也可以被写入以允许参与者的一些交易能自动执行。例如，可以写一份智能合约，通过物品何时到达来决定传输费用。双方一旦同意该条款并写入账本中，当商品到达时，相应的资金将会自动被转入。 </p>
<h3 id="3-共识（Consensus）"><a href="#3-共识（Consensus）" class="headerlink" title="3.共识（Consensus）"></a><strong>3.共识（Consensus）</strong></h3><p> 通过网络保持分类账交易同步的过程 — 确保账本只有在交易获得相应的参与者批准时才更新，并且当账本更新时，它们以包含相同的顺序区块来更新账本 — 这个过程就称为共识。 </p>
<p> <img src="http://hyperledger-fabric.readthedocs.io/en/latest/_images/consensus.png" alt="img"> </p>
<p>我们将在后面学习更多关于账本、智能合约和共识的知识。就目前而言，将区块链视为共享的、复制的交易系统就足够了，该交易系统通过智能合约进行更新，并通过称为共识的协作过程保持一致同步。</p>
<h2 id="Fabric的特点"><a href="#Fabric的特点" class="headerlink" title="Fabric的特点"></a>Fabric的特点</h2><p> Hyperledger Fabric 是 Hyperledger 中的区块链项目之一。像其他区块链技术一样，它具有账本，使用智能合约，并且系统是参与者管理其交易的。 </p>
<p> Hyperledger Fabric从其他一些区块链系统中脱颖而出的地方在于它是<strong>私密的</strong>并且是<strong>权限化的</strong>。相对于允许未知身份参与网络的开放式权限系统（需要工作证明等协议来验证交易和保护网络）。Hyperledger Fabric 网络的成员通过注册可信<strong>成员服务提供商（Membership Service Provider 简称 MSP）</strong>来保证系统的私密性。 </p>
<p> Hyperledger Fabric 还提供多种可热插拔选项。账本数据可以以多种格式来存储，共识机制可以随时切换开关，并支持多种的MSP。 </p>
<p> Hyperledger Fabric 还提供了创建<strong>频道（channels）</strong>的能力，允许一组参与者创建单独的交易账本。对网络参与者中有潜在的竞争对手的情况下，这是一个特别重要的选择 — 例如，他们向某些参与者提供的特殊价格 — 每位参与者都知道。如果两个参与者都在一个频道，那么这些参与者（没有其他人）就拥有该频道的账本副本。 </p>
<h3 id="共享账本（Shared-Ledger）"><a href="#共享账本（Shared-Ledger）" class="headerlink" title="共享账本（Shared Ledger）"></a><strong>共享账本（Shared Ledger）</strong></h3><p> Hyperledger Fabric 的账本系统有两个组件：<strong>世界状态（world state）</strong>和<strong>事务日志（transaction log）</strong>。每个参与者都将分类帐的副本分配给所属的每个 Hyperledger Fabric 网络。Hyperledger Fabric 中的网络参与者都有一本账本副本。 </p>
<p> 世界状态组件描述了在特定时间点下账本的状态。这是相当于账本的数据库。交易日志组件记录了构成世界状态的所有交易;由此得出，账本是世界状态数据库和交易日志历史记录的组合。 </p>
<p> 账本对世界状态有可替换的数据存储。默认情况下，这是一个 LevelDB 键值存储数据库。事务日志不需要是可插拔的。它只记录区块链网络中使用的账本数据库的前后值。 </p>
<h3 id="智能合约（Smart-Contracts）"><a href="#智能合约（Smart-Contracts）" class="headerlink" title="智能合约（Smart Contracts）"></a><strong>智能合约（Smart Contracts）</strong></h3><p> Hyperledger Fabric 的智能合约是用 <strong>chaincode</strong> 实现的，并且被区块链外部应用程序所调用，以此来与账本交互。在大多数情况下，chaincode 仅与账本的数据库组件（世界状态）（例如查询）交互，而不与交易日志交互。 </p>
<h3 id="私密性（Privacy）"><a href="#私密性（Privacy）" class="headerlink" title="私密性（Privacy）"></a><strong>私密性（Privacy）</strong></h3><p> 根据网络的需求，企业对企业（B2B）网络的参与者可能对他们共享多少信息非常敏感。对于其他区块链网络而言，隐私不会成为首要问题。 </p>
<p> 相遇对其他的区块链网络，隐私（使用频道方法）对于 Hyperledger Fabric 是非常关键的要求。 </p>
<h3 id="共识（Consensus）"><a href="#共识（Consensus）" class="headerlink" title="共识（Consensus）"></a><strong>共识（Consensus）</strong></h3><p> 交易必须按照发生的顺序写入账本中，网络中不同的参与者皆是如此。要做到这点，必须建立交易顺序，并且必须实施一种方法，用于拒绝错误（或恶意）插入账本的不良交易。 </p>
<p> 这是一个老生常谈的计算机科学领域，有很多方法可以实现共识算法，每个方法都有不同的利弊。例如，PBFT（Practical Byzantine Fault Tolerance）可以提供文件副本相互通信的机制，以保持每个副本的一致性，即使在发生损坏的情况下。或者，在比特币中，通过计算加密问题（也被称为挖矿）来实现共识，谁先算出来该区块就算谁的。 </p>
<p>  Hyperledger Fabric 共识机制，其中目前包括 SOLO，Kafka ，会很快将了解到 SBFT（简化的拜占庭容错）。 </p>
<h2 id="Fabric应用场景"><a href="#Fabric应用场景" class="headerlink" title="Fabric应用场景"></a>Fabric应用场景</h2><p> Fabric由于其联盟链的特性，可以面向企业内部或多个企业之间的商业区块链应用场景，将区块链的维护节点和可见性限制在联盟内部，并用智能合约（链码）重点解决联盟成员间的信任或信息不对等问题，以提高经济活动效率。Fabric主要应用的场景如下：<br>➤金融服务：Fabric可以有效降低交易成本和管控风险、减少跨组织的交易风险，其在金融领域的应用受到了不少银行和金融交易机构的主要推动。<br>➤征信和资产权属管理：Fabric可以促进数据的交易和流动；提供安全可靠的支持。特别是资产权属的管理，利用区块链平台建立的多方信任机制可以有效降低资产交易成本和违约风险。<br>➤国际自动化贸易和供应链管理：Fabric可以简化管理流程中繁琐的手续。利用智能合约，贸易中销售和法律合同可以数字化、可以实现货物监控和实时支付，大大降低了公司的运营成本。 </p>
<h2 id="Fabric参考手册"><a href="#Fabric参考手册" class="headerlink" title="Fabric参考手册"></a>Fabric参考手册</h2><p><a href="https://hyperledger-fabric-zh-cn.readthedocs.io/zh/latest/docs/Peers.html" target="_blank" rel="noopener">peers对等节点</a> </p>
<p><a href="https://hyperledger-fabric-zh-cn.readthedocs.io/zh/latest/docs/Ledger.html" target="_blank" rel="noopener">ledger账本</a> </p>
<h2 id="Fabric的基本框架"><a href="#Fabric的基本框架" class="headerlink" title="Fabric的基本框架"></a>Fabric的基本框架</h2><p> <img src="https://pic2.zhimg.com/80/v2-a77b25f8a3e4d7a4b5d005bbe5b6df89_720w.jpg" alt="img"> </p>
<h2 id="Fabric的基本逻辑架构"><a href="#Fabric的基本逻辑架构" class="headerlink" title="Fabric的基本逻辑架构"></a><strong>Fabric的基本逻辑架构</strong></h2><p> <img src="https://pic2.zhimg.com/v2-45187b8292aa5ecab715b12a80825aa1_r.jpg" alt="preview"> </p>
<h2 id="Fabric共识模式"><a href="#Fabric共识模式" class="headerlink" title="Fabric共识模式"></a>Fabric共识模式</h2><p>fabric共识模式采用的 Endorse+Kafka+Commit 的模式，这里我们简称EKC共识。此共识包含以下几个步骤：</p>
<p>1.请求背书：<br>客户端用自己的私钥对交易进行签名后，按照指定格式将交易和签名信息进行打包，然后将打包后的数据发给背书节点请求背书。</p>
<p>2.验证背书：<br>背书节点收到背书请求后，验证交易的签名是否正确并调用智能合约验证交易内容是否合法。验证通过的话，背书节点用自己的私钥对背书结果进行签名并按照指定格式打包，然后将打包后的数据发给客户端。</p>
<p>3.提交交易：<br>客户端收到背书结果后，验证背书结果的签名是否正确。验证通过后，对交易请求和背书结果签名并打包。然后，把打包后的数据发送给orderer节点提交交易。</p>
<p>4.排序广播：<br>orderer节点收到交易后，验证数据的客户端签名<a href="#_msocom_1">[bJ1]</a> 是否正确。验证通过后，将交易发给kafka集群对应的topic。由于orderer中的对于每个通道都在kafka上监听对应的消息，因此，kafka将消息存放到对应topic上之后，会将消息广播给通道上的所有orderer。因为各个orderer的消息都是由kafka按照相同顺序发送的，因此，这个过程也实现了消息的排序。</p>
<p>5.打包出块：<br>orderer节点接收到从kafka推送的消息（kafka节点见同步消息不需要验证），当满足出块策略<a href="#_msocom_2">[bJ2]</a> ：缓存交易个数达到区块最大交易数或者时间达到出快时间，则将交易进行打包、对数据签名，然后出块，并将区块分发给peer节点。</p>
<p>6.验证记账：<br>peer节点接收到区块后，验证交易是否有效即验证区块的交易是否满足背书策略以及区块中交易的读写集版本是否正确<a href="#_msocom_3">[bJ3]</a> 。验证通过的话，执行此交易的内容更改状态数据库。验证失败的话，对此条交易不做任何处理。当区块中的交易全部处理完成后，将区块记录在本地数据库。</p>
<h2 id="Fabric源码解析"><a href="#Fabric源码解析" class="headerlink" title="Fabric源码解析"></a>Fabric源码解析</h2><h3 id="一、整体结构"><a href="#一、整体结构" class="headerlink" title="一、整体结构"></a>一、整体结构</h3><p>​    Hyperledger Fabric 在 1.0 中，架构已经解耦为三部分： </p>
<p>​    peer：主要起到 peer 作用，包括 endorser、committer 两种角色； </p>
<p>​    ca：即原先的 membersrvc，独立成一个新的项目。 </p>
<p>​    order：起到 order 作用。 </p>
<p>​    其中，peer 和 order 代码暂时都在 fabric 项目中，未来可能进一步拆分。</p>
<p>启动过程：<strong>orderer0,peer0,peer1,peer2,peer3,cli</strong>六个容器服务，首先在容器启动的时候order程序,然后在启动peer节点容器，相当于启动peer程序，最后启动cli容器。</p>
<p><strong>通过docker相关启动脚本，orderer容器先起，各个peer之间其实可以没有先后顺序但是都必须后与orderer容器，最后是cli容器。这说明，orderer服务必须先于peer服务，peer node start命令必须先于peer channel或peer chaincode命令。</strong></p>
<h3 id="二、源代码"><a href="#二、源代码" class="headerlink" title="二、源代码"></a>二、源代码</h3><p>说明：以下讲解代码基于fabric 1.0版本（<a href="https://github.com/hyperledger/fabric/tree/release-1.0" target="_blank" rel="noopener">github地址</a>）    </p>
<p>实现fabric功能的核心代码，包括：</p>
<ul>
<li><p>​    <strong><a href="">bccsp</a>包</strong>：实现对加解密算法和机制的支持。</p>
</li>
<li><p>​    <strong><a href="">common</a>包</strong>：一些通用的模块；</p>
</li>
<li>​    <strong><a href="">core</a>包</strong>：大部分核心实现代码都在本包下。其他包的代码封装上层接口，最终调用本包内代码；</li>
<li>​    <strong><a href="">events</a>包</strong>：支持event框架；</li>
<li>​    <strong><a href="">examples</a>包</strong>：包括一些示例的chaincode代码；</li>
<li>​    <strong><a href="">gossip</a>包</strong>：实现gossip协议；</li>
<li>​    <strong><a href="">msp</a>包</strong>：Member Service Provider 包；</li>
<li>​    <strong><a href="">order</a>包</strong>：order服务相关的入口和框架代码；</li>
<li>​    <strong><a href="">peer</a>包</strong>：peer的入口和框架代码；</li>
<li>​    <strong><a href="">protos</a>包</strong>：包括各种协议和消息的protobuf定义文件和生成的go文件。</li>
</ul>
<p>​    一些辅助代码包，包括：</p>
<ul>
<li>​    <strong><a href="">bddtests</a>包</strong>: 测试包，含大量bdd测试用例；</li>
<li>​    <strong><a href="">gotools</a>包</strong>：golang开发相关工具安装；</li>
<li>​    <strong><a href="">vendor</a>包</strong>： 管理依赖；</li>
</ul>
<p>​    安装部署包括：</p>
<ul>
<li><p>​    <strong><a href="">busybox</a>包</strong>：busybox环境，精简的Linux;</p>
</li>
<li><p>​    <strong><a href="">devenv</a>包</strong>：配置开发环境；</p>
</li>
<li><p>​    <strong><a href="">images</a>包</strong>：镜像生成模板等；</p>
</li>
<li><p>​    <strong><a href="">scripts</a>包</strong>：各种安装配置脚本；</p>
</li>
</ul>
<h3 id="三、核心过程"><a href="#三、核心过程" class="headerlink" title="三、核心过程"></a>三、核心过程</h3><p>​    总结一下核心核心的过程。</p>
<h4 id="3-1-Chaincode启动过程"><a href="#3-1-Chaincode启动过程" class="headerlink" title="3.1 Chaincode启动过程"></a>3.1 Chaincode启动过程</h4><p>​    Hyperledger Fabric中，Chaincode默认运行在Docker容器中。Peer通过调用Docker API来创建和启动Chaincode容器。Chaincode容器启动后跟Peer之间创建gRPC连接，双方通过发送ChaincodeMessage来进行交互通信。Chaincode容器利用core.chaincode.shim包提供的接口来向Peer发送请求。</p>
<p>​    <strong>典型结构</strong></p>
<p>​    下面给出了链码的典型结构，用户只需要关注到 Init() 和 Invoke() 函数的实现上，在其中利用 </p>
<p>​    shim.ChaincodeStubInterface 结构，实现跟账本的交互逻辑。</p>
<p>​    </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span> </span><br><span class="line">	<span class="string">"fmt"</span> </span><br><span class="line">	<span class="string">"github.com/hyperledger/fabric/core/chaincode/shim"</span> </span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> DemoChaincode <span class="keyword">struct</span> &#123; &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *DemoChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123; </span><br><span class="line">	<span class="comment">// more logics using stub here </span></span><br><span class="line">	<span class="keyword">return</span> stub.Success(<span class="literal">nil</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *DemoChaincode)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span>&#123;</span><br><span class="line">	<span class="comment">// more logics using stub here </span></span><br><span class="line">    <span class="keyword">return</span> stub.Success(<span class="literal">nil</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    err := shim.Start(<span class="built_in">new</span>(DemoChaincode)) </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; </span><br><span class="line">        fmt.Printf(<span class="string">"Error starting DemoChaincode: %s"</span>, err) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    Chaincode首先是一个普通的goland程序，其main方法中调用了shim层的Start()方法。启动过程如下图所示：</p>
<p><img src="D:\其他\区块链研究\区块链笔记\chaincode.shim.start.png"></p>
<p>​                                                    图  Chaincode* 启动过程</p>
<p>首先会进行初始化。包括读取默认配置，创建到 Peer 的gRPC 连接，主要包括 </p>
<p>NewChaincodeSupportClient(cc *grpc.ClientConn) 和 chaincodeSupportClient.Register(ctx </p>
<p>context.Context, opts …grpc.CallOption) 两个方法。 </p>
<p>初始化完成后，创建有限状态机结构（FSM，github.com/looplab/fsm）。FSM 会根据收到的 </p>
<p>消息和当前状态来触发状态转移，并执行提前设置的操作。 </p>
<p><em>Peer</em> 侧也利用了类似的 <em>FSM</em> 结构来管理消息响应。 </p>
<p>之后，利用创建好的 gRPC 连接开始向 Peer 发送第一个 gRPC 消息： </p>
<p>ChaincodeMessage_REGISTER，将自身注册到 Peer 上。注册成功后开始消息处理循环， </p>
<p>等待接收来自 Peer 的消息以及自身的状态迁移（nextState）消息。</p>
<p>后续过程中，Chaincode 和 Peer 利用 FSM 完成一系列对消息的响应运作，如下所示。</p>
<ul>
<li>​    Peer 收到来自链码容器的 ChaincodeMessage_REGISTER 消息，将其注册到本地的一 </li>
</ul>
<p>个 Handler 结构，返回 ChaincodeMessage_REGISTERED 消息发给链码容器。之后更 </p>
<p>新状态为 established ，并发送 ChaincodeMessage_READY 消息给链码侧，更新状态 </p>
<p>为 ready。</p>
<ul>
<li>链码侧收到 ChaincodeMessage_REGISTERED 消息后，不进行任何操作，注册成功。 </li>
</ul>
<p>更新状态为 established。收到 ChaincodeMessage_READY 消息后更新状态为 ready。</p>
<ul>
<li><p>Peer 侧发出 ChaincodeMessage_INIT 消息给链码容器，准备触发链码侧初始化操作。</p>
</li>
<li><p>链码容器收到 ChaincodeMessage_INIT 消息，通过 Handler.handleInit() 方法进行进行 </p>
<p>初始化。主要包括初始化所需的 ChaincodeStub 结构，以及调用链码代码中的 Init() 方 </p>
<p>法。初始化成功后，返回 ChaincodeMessage_COMPLETED 消息给 Peer。此时，链码 </p>
<p>容器进入可被调用（Invoke）状态。 </p>
</li>
<li><p>链码被调用时，Peer 发出 ChaincodeMessage_TRANSACTION 消息给链码。 </p>
</li>
<li><p>链码收到 ChaincodeMessage_TRANSACTION 消息，会调用 Invoke() 方法，根据 Invoke 方法中用户实现的逻辑，可以发出包括 ChaincodeMessage_GET_HISTORY_FOR_KEY、ChaincodeMessage_GET_QUERY_RESULT、ChaincodeMessage_GET_STATE、ChaincodeMessage_GET_STATE_BY_RANGE、 ChaincodeMessage_QUERY_STATE_CLOSE、ChaincodeMessage_QUERY_STATE_NEXT、 ChaincodeMessage_INVOKE_CHAINCODE 等消息给 Peer 侧。Peer 侧收到这些消 息，进行相应的处理，并回复 ChaincodeMessage_RESPONSE 消息。最后，链码侧会 </p>
<p>回复调用完成的消息 ChaincodeMessage_COMPLETE 给 Peer 侧。</p>
</li>
<li><p>在上述过程中，Peer 和链码侧还会定期的发送 ChaincodeMessage_KEEPALIVE 消息给 </p>
<p>对方，以确保彼此在线。</p>
</li>
</ul>
<h4 id="3-2-Peer节点启动"><a href="#3-2-Peer节点启动" class="headerlink" title="3.2 Peer节点启动"></a>3.2 Peer节点启动</h4><h5 id="3-2-1-Peer背书提案过程"><a href="#3-2-1-Peer背书提案过程" class="headerlink" title="3.2.1 Peer背书提案过程"></a>3.2.1 Peer背书提案过程</h5><p>​    客户端将交易预提案（Transaction Proposal)通过 gRPC 发送给支持 Endorser 角色的 Peer </p>
<p>进行背书。 </p>
<p>这些交易提案可能包括链码的安装、实例化、升级、调用、查询；以及 Peer 节点加入和列出 </p>
<p>通道操作。 </p>
<p>Peer 接收到请求后，会调用 core/endorser/endorser.go 中 Endorser 结构体 </p>
<p>的 ProcessProposal(ctx context.Context, signedProp *pb.SignedProposal) </p>
<p>(*pb.ProposalResponse, error) 方法，进行具体的背书处理。 </p>
<p>背书过程主要完成如下操作： </p>
<ul>
<li><p>检查提案消息的合法性，以及相关的权限； </p>
</li>
<li><p>模拟执行提案：启动链码容器，对世界状态的最新版本进行临时快照，基于它执行链 </p>
<p>码，将结果记录在读写集中； </p>
</li>
<li><p>对提案内容和读写集合进行签名，并返回提案响应消息。 </p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">ProcessProposal</span><span class="params">(ctx context.Context, signedProp *pb.SignedProposal)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//检查交易的合法性</span></span><br><span class="line">    prop, hdr, hdrExt, err := validation.ValidateProposalMessage(signedProp)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//该方法主要是Peer节点模拟提案过程，但是不会写入到区块中，当Peer节点模拟完一项提案，将模拟结果保存至读写集。</span></span><br><span class="line">    cd, res, simulationResult, ccevent, err := e.simulateProposal(ctx, chainID, txid, signedProp, prop, hdrExt.ChaincodeId, txsim)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> chainID == <span class="string">""</span> &#123;</span><br><span class="line">        pResp = &amp;pb.ProposalResponse&#123;</span><br><span class="line">            Response: res</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pResp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要过程如下图所示。</p>
<p><img src="D:\其他\区块链研究\区块链笔记\peer背书过程.jpg" style="zoom:150%"></p>
<p>​                                             <em>Endorser ProcessProposal</em> 过程</p>
<ul>
<li>检查提案合法性；<ul>
<li>调用 ValidateProposalMessage() 方法对签名的提案进行格式检查，主要包括：<ul>
<li>Channel 头部格式：是否合法头部类型，由 validateChannelHeader() 完成；</li>
<li>签名头格式：是否包括了 nonce 和creators 数据，由validateSignatureHeader() 完成； </li>
<li>签名域：creator 证书 MSP 检查是否合法，签名是否正确，由checkSignatureFromCreator() 完成。</li>
</ul>
</li>
<li>如果是系统链码调用（SCC），检查是否是允许从外部调用的三种 SCC 之一：cscc、lscc、qscc 或 rscc；</li>
<li>如果 chainID 不为空，获取对应 chain 的账本结构，并检查 TxID 唯一性，确保同一交易未曾提交到账本结构中； </li>
<li>对于用户链码调用，需要检查 ACL：资源为 PROPOSE ，默认策略是签名提案者在通道上拥有写权限（ CHANNELWRITERS ）。</li>
</ul>
</li>
<li>模拟执行提案 <ul>
<li>如果 chainID 不为空，获取对应账本的交易模拟器（TxSimulator）和历史查询器（HistoryQueryExecutor），这两个结构将在后续执行链码时被使用。 </li>
<li>如果 chainID 不为空，调用 simulateProposal() 方法获取模拟执行的结果，检查返回的响应 response 的状态，若不小于错误 500 则创建并返回一个失败的ProposalResponse。 </li>
</ul>
</li>
<li>对提案内容和读写集合进行签名 <ul>
<li>chainID 非空情况下，调用 endorseProposal() 方法利用 ESCC，对之前得到的模拟执行的结果进行背书。返回 ProposalResponse，检查 simulateProposal 返回的response 的状态，若不小于错误阈值 400（被背书节点反对），返回ProposalResponse 及链码错误 chaincodeError（endorseProposal 里有检查链码执行结果的状态，而 simulateProposal 没有检查）。</li>
<li>将 response.Payload 赋给 ProposalResponse.Response.Payload（因为simulateProposal 返回的 response 里面包含链码调用的结果）。</li>
<li>返回响应消息 ProposalResponse。 </li>
</ul>
</li>
</ul>
<p><strong>simulateProposal</strong> 方法 </p>
<p>​    simulateProposal 方法会通过执行链码逻辑来获取对状态的修改结果，并存放到读写集合 </p>
<p>中，主要过程如下： </p>
<ul>
<li>从提案结构的载荷中提取 ChaincodeInvocationSpec 结构，其中包含了所调用链码（包括系统链码和用户链码）的路径、名称和版本，以及调用时传入的参数列表；</li>
<li>检查 ESCC 和 VSCC（尚未实现）；</li>
<li>对用户链码，检查提案中的实例化策略跟账本上记录的该链码的实例化策略（安装链码时指定）是否一致。防止有人修改权限在其它通道非法实例化。 </li>
<li>调用 callChaincode() 方法执行 Proposal，返回 Response 和 ChaincodeEvent。<ul>
<li>调用 core.endorser 包中 SupportImpl.Execute() 方法，该方法主要调用core.chaincode 包中的 ExecuteChaincode() 方法，进一步调用包内的 Execute()方法。调用过程中会把交易模拟器和历史查询器通过上下文结构体传入后续子方法。</li>
<li>Execute() 方法会调用 ChaincodeSupport.Launch() 方法创建并启动链码容器。启动成功后创建链码 gRPC 消息，通过 ChaincodeSupport.Execute() 方法发送消息给CC 容器，执行相关的合约，并返回执行响应（ChaincodeMessage 结构）。此过程 中会将读写集记录到交易模拟器结构体中。</li>
</ul>
</li>
<li>对于非空 chainID（大部分跟账本相关的操作），执行 GetTxSimulationResults() 拿到执行结果 TxSimulationResults 结构，从中可以解析出读写集数据。</li>
<li>最终返回链码标准数据结构 ChaincodeDefinition、响应消息 ChaincodeMessage、交易读写集 PubSimulationResults、链码事件 ChaincodeEvent。</li>
</ul>
<p><strong>endorseProposal</strong> 方法</p>
<p>主要过程如下： </p>
<ul>
<li>获取被调用的链码指定的背书链码的名字。</li>
<li>通过 callChaincode() 实现对背书链码的调用，返回响应 response（对 ESCC 的调用同样也会产生 simulation results，但 ESCC 不能背书自己产生的simulation results，需要背书最初被调用的链码产生的 simulation results）。</li>
<li>检查 response.Status，是否大于等于 400（错误阈值），若是则把 response 赋给proposalResponse.Response 并返回 proposalResponse。</li>
<li>将 response.Payload解码后（ProposalResponse类型）返回。</li>
</ul>
<p><strong>callChaincode</strong> 方法</p>
<p>主要过程如下： </p>
<ul>
<li>判断交易模拟器，不为空则把它加入到Context的K-V存储中。</li>
<li>判断被call的cc是不是系统链码，创建CCContext（包含通道名、链码名、版本号、交易ID、是否 SCC、签名 Prop、Prop）</li>
<li>调用 core/chaincode/chaincodeexec.go 下的 ExecuteChaincode()，返回响应 response和 事件ccevent。</li>
<li>返回 response和ccevent。</li>
</ul>
<h4 id="3-3排序服务核心原理和工作过程"><a href="#3-3排序服务核心原理和工作过程" class="headerlink" title="3.3排序服务核心原理和工作过程"></a>3.3排序服务核心原理和工作过程</h4><p>​    排序服务在超级账本 Fabric 网络中起到十分核心的作用。所有交易在发送给 Committer 进行 </p>
<p>验证接受之前，需要先经过排序服务进行全局排序。 </p>
<p>在目前架构中，排序服务的功能被抽取出来，作为单独的 fabric-orderer 模块来实现，代码主 </p>
<p>要在 fabric/orderer 目录下。 </p>
<p>下面以 Kafka 作为共识插件为例，讲解 Orderer 节点的核心过程。 </p>
<h5 id="3-3-1工作原理"><a href="#3-3-1工作原理" class="headerlink" title="3.3.1工作原理"></a><strong>3.3.1工作原理</strong></h5><p>Orderer 节点（Ordering Service Node，OSN）在网络中起到代理作用，多个 Orderer 节点 </p>
<p>会连接到 Kafka 集群，利用 Kafka 的共识功能，完成对网络中交易的排序和打包成区块的工 </p>
<p>作。</p>
<p>Fabric 网络提供了多通道特性，为了支持这一特性，同时保障每个 Orderer 节点上数据的一 </p>
<p>致性，排序服务进行了一些特殊设计。 </p>
<p>对于每个通道，Orderer 将其映射到 Kafka 集群中的一个 topic （topic 名称与 channelID 相 </p>
<p>同）上。由于 Orderer 目前并没有使用 Kafka Topic 的多分区负载均衡特性，默认每个 topic </p>
<p>只创建了一个分区（0 号分区）。 </p>
<p>此外，Orderer 还在本地维护了针对每个通道的账本（区块链）结构，其中每个区块包括了一 </p>
<p>组排序后的交易消息，并且被分割为独立区块。  </p>
<p>核心过程如下所示：</p>
<p><img src="D:\其他\区块链研究\区块链笔记\orderer核心过程.jpg" style="zoom:150%"></p>
<p>​                                                      Orderer 节点核心过程</p>
<ul>
<li>客户端通过 gRPC 连接发送交易信息到 Orderer 节点的 Broadcast() 接口。</li>
<li>Orderer 节点收到请求后，提取消息进行解析、检查，通过检查后封装为 Kafka 消息，通过 Produce 接口发送到 Kakfa 集群对应的 topic 分区中。</li>
<li>当前收到消息数达到 BatchSize.MaxMessageCount 或消息尺寸过大，或超时时间达到 BatchTimeout，则发送分块消息 TTC-X 到 Kafka。</li>
<li>Kafka 集群维护多个 topic 分区。Kakfa 通过共识算法来确保写入到分区后的消息的一致性。即一旦写入分区，任何 Orderer 节点看到的都是相同的消息队列。</li>
<li>Orderer 节点在启动后，还默认对本地账本对应的 Kafka 分区数据进行监听，不断从Kafka 拉取（Consume）新的交易消息，并对消息进行处理。满足一定策略情况下（收到 TTX-C 或配置消息）还会将消息打包为区块。</li>
</ul>
<h4 id="3-4Orderer-节点启动过程"><a href="#3-4Orderer-节点启动过程" class="headerlink" title="3.4Orderer 节点启动过程"></a><strong>3.4Orderer</strong> 节点启动过程</h4><p>Orderer 节点启动通过 <strong>orderer</strong> 包下的 main() 方法实现，会进一步调用到<strong>orderer/common/server</strong>包中的 <strong>Main()</strong> 方法。</p>
<p>核心代码如下所示。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main is the entry point of orderer process</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fullCmd := kingpin.MustParse(app.Parse(os.Args[<span class="number">1</span>:]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// "version" command</span></span><br><span class="line">    <span class="keyword">if</span> fullCmd == version.FullCommand() &#123;</span><br><span class="line">        fmt.Println(metadata.GetVersionInfo())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conf := config.Load()</span><br><span class="line">    initializeLoggingLevel(conf)</span><br><span class="line">    initializeLocalMsp(conf)</span><br><span class="line">    </span><br><span class="line">    Start(fullCmd, conf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包括配置初始化过程和核心启动过程两个部分：</p>
<ul>
<li>config.Load()：从本地配置文件和环境变量中读取配置信息，构建配置树结构。 </li>
<li>initializeLoggingLevel(conf)：配置日志级别。</li>
<li>initializeLocalMsp(conf)：配置 MSP 结构。</li>
<li>Start()：完成启动后的核心工作。 </li>
</ul>
<p>核心启动过程都在 orderer/common/server 包中的 Start() 方法，如下图所示。</p>
<p><img src="D:\其他\区块链研究\区块链笔记\- Orderer 启动的整体过程.jpg" style="zoom:150%"></p>
<p>​                                                                <em>Orderer</em> 启动的整体过程</p>
<p>Start() 方法会初始化 gRPC 服务需要的结构，然后启动服务。 </p>
<p>核心代码如下所示。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(cmd <span class="keyword">string</span>, conf *config.TopLevel)</span></span> &#123;</span><br><span class="line">	logger.Debugf(<span class="string">"Start()"</span>)</span><br><span class="line">	signer := localmsp.NewSigner()</span><br><span class="line">	manager := initializeMultichannelRegistrar(conf, signer)</span><br><span class="line">    server := NewServer(manager, signer, &amp;conf.Debug)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> cmd &#123;</span><br><span class="line">    	<span class="keyword">case</span> start.FullCommand(): <span class="comment">// "start" command</span></span><br><span class="line">        	logger.Infof(<span class="string">"Starting %s"</span>, metadata.GetVersionInfo())</span><br><span class="line">        	initializeProfilingService(conf)</span><br><span class="line">        	grpcServer := initializeGrpcServer(conf)</span><br><span class="line">        	ab.RegisterAtomicBroadcastServer(grpcServer.Server(), server)</span><br><span class="line">        	logger.Info(<span class="string">"Beginning to serve requests"</span>)</span><br><span class="line">        	grpcServer.Start()</span><br><span class="line">        <span class="keyword">case</span> benchmark.FullCommand(): <span class="comment">// "benchmark" command</span></span><br><span class="line">        	logger.Info(<span class="string">"Starting orderer in benchmark mode"</span>)</span><br><span class="line">        	benchmarkServer := performance.GetBenchmarkServer()</span><br><span class="line">        	benchmarkServer.RegisterService(server)</span><br><span class="line">        	benchmarkServer.Start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包括两大部分：</p>
<ul>
<li>gRPC 服务结构初始化； </li>
<li>gRPC 服务启动。</li>
</ul>
<h5 id="3-4-1-gRPC-服务结构初始化"><a href="#3-4-1-gRPC-服务结构初始化" class="headerlink" title="3.4.1 gRPC 服务结构初始化"></a><strong>3.4.1 gRPC 服务结构初始化</strong></h5><p>包括创建新的 MSP 签名结构，初始化 Registrar 结构来管理各个账本结构，启动共识过程，以及创建 gRPC 服务端结构。</p>
<p>核心步骤包括： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signer := localmsp.NewSigner() <span class="comment">// 初始化签名结构</span></span><br><span class="line">manager := initializeMultichannelRegistrar(conf, signer, tlsCallback) <span class="comment">// 初始化账本管理器（Registrar）结构</span></span><br></pre></td></tr></table></figure>
<p>其中， initializeMultichannelRegistrar(conf, signer) 方法最为关键，核心代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeMultichannelRegistrar</span><span class="params">(conf *config.TopLevel, signer crypto.LocalSigner,callbacks ...<span class="keyword">func</span>(bundle *channelconfig.Bundle)</span>) *<span class="title">multichannel</span>.<span class="title">Registrar</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建操作账本的工厂结构</span></span><br><span class="line">    lf, _ := createLedgerFactory(conf)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是首次启动情况，默认先创建系统通道的本地账本结构</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lf.ChainIDs()) == <span class="number">0</span> &#123;</span><br><span class="line">        logger.Debugf(<span class="string">"There is no chain, hence we must be in bootstrapping"</span>)</span><br><span class="line">        initializeBootstrapChannel(conf, lf)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        logger.Info(<span class="string">"Not bootstrapping because of existing chains"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化共识插件，共识插件负责跟后台的队列打交道</span></span><br><span class="line">    consenters := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]consensus.Consenter)</span><br><span class="line">    consenters[<span class="string">"solo"</span>] = solo.New()</span><br><span class="line">    consenters[<span class="string">"kafka"</span>] = kafka.New(conf.Kafka.TLS, conf.Kafka.Retry, conf.Kafka.Version, conf.Kafka.Verbose)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建各个账本的管理器（Registrar）结构，并启动共识过程</span></span><br><span class="line">    <span class="keyword">return</span> multichannel.NewRegistrar(lf, consenters, signer, callbacks...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用传入的配置信息和签名信息完成如下步骤：</p>
<ul>
<li>创建账本操作的工厂结构；</li>
<li>如果是新启动情况，利用给定的系统初始区块文件初始化系统通道的相关结构；</li>
<li>完成共识插件（包括 solo 和 kafka 两种）的初始化；</li>
<li><strong>multichannel.NewRegistrar(lf, consenters, signer)</strong> 方法会扫描本地账本数据（此时至少已存在系统通道），创建 Registrar 结构，并为每个账本都启动共识（如 Kafka 排序）过程。</li>
</ul>
<p>说明：<em>Registrar</em> 结构（位于 <em>orderer.common.multichannel</em> 包）是 <em>Orderer</em> 组件中最核心的结构，管理了 <em>Orderer</em> 中所有的账本、共识插件等数据结构。 </p>
<p><strong>3.4.2 创建 Registrar 结构并启动共识过程</strong></p>
<p>NewRegistrar(lf, consenters, signer) 方法位于 orderer.common.multichannel 包，负责初始化链支持、消息处理器等重要数据结构，并为各个账本启动共识过程。 </p>
<p>核心代码如下： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">existingChains := ledgerFactory.ChainIDs()</span><br><span class="line"><span class="keyword">for</span> _, chainID := <span class="keyword">range</span> existingChains &#123; <span class="comment">// 启动本地所有的账本结构的共识过程</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := ledgerResources.ConsortiumsConfig(); ok &#123; <span class="comment">// 如果是系统账本（默认在首次启动时会自动创建）</span></span><br><span class="line">        chain := newChainSupport(r, ledgerResources, consenters, signer)</span><br><span class="line">        chain.Processor = msgprocessor.NewSystemChannel(chain, r.templator, msgprocessor.CreateSystemChannelFilters(r, chain))</span><br><span class="line">        r.chains[chainID] = chain</span><br><span class="line">        r.systemChannelID = chainID</span><br><span class="line">        r.systemChannel = chain</span><br><span class="line">        <span class="keyword">defer</span> chain.start() <span class="comment">// 启动共识过程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果是应用账本</span></span><br><span class="line">        chain := newChainSupport(r, ledgerResources, consenters, signer)</span><br><span class="line">        r.chains[chainID] = chain</span><br><span class="line">        chain.start() <span class="comment">// 启动共识过程</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>chain.start()</strong> 方法负责启动共识过程。以 Kafka 共识插件为例，最终以协程方式调用到 <strong>orderer.consensus.kafka</strong> 包中的 <strong>startThread()</strong> 方法，将在后台持续运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> startThread(chain)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>startThread()</strong> 方法将为指定的账本结构配置共识服务，并将其启动，核心代码包括：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Producer 结构</span></span><br><span class="line">chain.producer, err = setupProducerForChannel(chain.consenter.retryOptions(), chain.haltChan, chain.SharedConfig().KafkaBrokers(), chain.consenter.brokerConfig(), chain.channel)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 CONNECT 消息给 Kafka，如果失败，则退出</span></span><br><span class="line">sendConnectMessage(chain.consenter.retryOptions(), chain.haltChan, chain.producer, chain.channel)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建处理对应 Kafka topic 的 Consumer 结构</span></span><br><span class="line">chain.parentConsumer, err = setupParentConsumerForChannel(chain.consenter.retryOptions(), chain.haltChan, chain.SharedConfig().KafkaBrokers(), chain.consenter.brokerConfig(), chain.channel)</span><br><span class="line"><span class="comment">// 配置从指定 partition 读取消息的 PartitionConsumer 结构</span></span><br><span class="line">chain.channelConsumer, err = setupChannelConsumerForChannel(chain.consenter.retryOptions(), chain.haltChan, chain.parentConsumer, chain.channel, chain.lastOffsetPersisted+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从该链对应的 Kafka 分区不断读取消息，并进行处理过程</span></span><br><span class="line">chain.processMessagesToBlocks()</span><br></pre></td></tr></table></figure>
<p>主要包括如下步骤：</p>
<ul>
<li>创建到 Kafka 集群的 Producer 结构并发送 CONNECT 消息； </li>
<li>为对应的 topic 创建 Consumer 结构，并配置从指定分区读取消息的 PartitionConsumer结构； </li>
<li>对链对应的 Kafka 分区中消息的进行循环处理。</li>
</ul>
<h5 id="3-4-2-gRPC服务启动"><a href="#3-4-2-gRPC服务启动" class="headerlink" title="3.4.2 gRPC服务启动 "></a><strong>3.4.2 gRPC服务启动 </strong></h5><p>初始化 gRPC 服务结构，完成绑定并启动监听。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 gRPC 服务端结构</span></span><br><span class="line">server := NewServer(manager, signer, &amp;conf.Debug)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 gRPC 服务连接</span></span><br><span class="line">grpcServer := initializeGrpcServer(conf)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 gRPC 服务并启动</span></span><br><span class="line">ab.RegisterAtomicBroadcastServer(grpcServer.Server(), server)</span><br><span class="line">grpcServer.Start()</span><br></pre></td></tr></table></figure>
<p>其中， NewServer(manager, signer, &amp;conf.Debug) 方法（位于 orderer.common.server 包）最为核心，将 gRPC 相关的服务结构进行初始化，并绑定到 gRPC 请求上。分别响应 Deliver() 和 Broadcast() 两个 gRPC 调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewServer creates an ab.AtomicBroadcastServer based on the broadcast target and ledger Reader</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(r *multichannel.Registrar, _ crypto.LocalSigner, debug *localconfig.Debug)</span> <span class="title">ab</span>.<span class="title">AtomicBroadcastServer</span></span> &#123;</span><br><span class="line">	s := &amp;server&#123;</span><br><span class="line">		dh: deliver.NewHandlerImpl(deliverSupport&#123;Registrar: r&#125;),</span><br><span class="line">		bh: broadcast.NewHandlerImpl(broadcastSupport&#123;Registrar: r&#125;),</span><br><span class="line">        debug: debug,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-Orderer-节点对排序后消息的处理过程"><a href="#3-5-Orderer-节点对排序后消息的处理过程" class="headerlink" title="3.5 Orderer 节点对排序后消息的处理过程"></a><strong>3.5 Orderer</strong> 节点对排序后消息的处理过程</h4><p>经过排序后的消息，可以认为在网络中已经达成了基本的共识。Orderer 会获取这些消息，进行对应处理（包括打包为区块，更新本地账本结构等）。</p>
<p>以 Kafka 模式为例，Orderer 节点启动后，会调用 <strong>orderer/consensus/kafka</strong> 模块中 <strong>chainImpl</strong> 结构体的 processMessagesToBlocks() ([]uint64, error) 方法，持续获取 Kafka对应分区中的消息。</p>
<p><strong>主要过程</strong></p>
<p><strong>chainImpl</strong>  结构体的 <strong>processMessagesToBlocks()</strong>  方法不断从分区中 Consume 消息并进行处理，同时定时发送 TimeToCut 消息。</p>
<p>处理消息类型包括 Connect 消息（Producer 启动后发出）、TimeToCut 消息和 Regular 消息（Fabric 消息）。分别调用对应方法进行处理，主要流程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-chain.haltChan: <span class="comment">// 链故障了，退出</span></span><br><span class="line">        <span class="keyword">case</span> kafkaErr := &lt;-chain.channelConsumer.Errors(): <span class="comment">//获取 Kakfa 消息发生错误</span></span><br><span class="line">        	<span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-chain.errorChan: <span class="comment">// 连接关闭，不进行任何操作</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="comment">//其它错误，OutofRange，关闭 errorChan；否则进行超时重连</span></span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-chain.errorChan: <span class="comment">// 连接仍然关闭，尝试后台进行重连</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> &lt;-topicPartitionSubscriptionResumed: <span class="comment">// 继续</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-deliverSessionTimedOut: <span class="comment">//访问超时，尝试后台进行重连</span></span><br><span class="line">        <span class="keyword">case</span> in, ok := &lt;-chain.channelConsumer.Messages(): <span class="comment">// 核心过程：成功读取到 Kafka消息，进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> msg.Type.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> *ab.KafkaMessage_Connect: <span class="comment">// Kafka 连接消息，忽略</span></span><br><span class="line">            <span class="keyword">case</span> *ab.KafkaMessage_TimeToCut: <span class="comment">// TTC，打包现有的一批消息为区块</span></span><br><span class="line">            <span class="keyword">case</span> *ab.KafkaMessage_Regular: <span class="comment">// 核心处理：Fabric 相关消息，包括配置更新、应用通道交易等</span></span><br><span class="line">            	chain.processRegular(msg.GetRegular(), in.Offset)</span><br><span class="line">            <span class="keyword">case</span> &lt;-chain.timer: <span class="comment">//定期发出 TimeToCut 消息到 Kafka</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-5-1-Fabric-相关消息的处理"><a href="#3-5-1-Fabric-相关消息的处理" class="headerlink" title="3.5.1 Fabric 相关消息的处理"></a><strong>3.5.1 Fabric 相关消息的处理</strong></h5><p>对于 Fabric 相关消息（包括交易消息和配置消息），具体会调用 chainImpl 结构体的 <strong>processRegular(regularMessage <em>ab.KafkaMessageRegular, receivedOffset int64) error</em></strong>  方法进行处理。</p>
<p>该方法的核心代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">processRegular</span><span class="params">(regularMessage *ab.KafkaMessageRegular, receivedOffset <span class="keyword">int64</span>)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">	env := &amp;cb.Envelope&#123;&#125;</span><br><span class="line">	proto.Unmarshal(regularMessage.Payload, env) <span class="comment">// 从载荷中解析出信封结构</span></span><br><span class="line">	<span class="keyword">switch</span> regularMessage.Class &#123;</span><br><span class="line">		<span class="keyword">case</span> ab.KafkaMessageRegular_NORMAL: <span class="comment">// 普通交易消息</span></span><br><span class="line">			chain.ProcessNormalMsg(env) <span class="comment">// 检查消息合法性，分应用链和系统链两种情况</span></span><br><span class="line">			commitNormalMsg(env) <span class="comment">// 处理交易消息，满足条件则切块，并写入本地账本</span></span><br><span class="line">        <span class="keyword">case</span> ab.KafkaMessageRegular_CONFIG: <span class="comment">// 配置消息，包括通道头部类型为 CONFIG、CONFIG_UPDATE、ORDERER_TRANSACTION 三种</span></span><br><span class="line">        	chain.ProcessConfigMsg(env) <span class="comment">//检查消息合法性，分应用链和系统链两种情况</span></span><br><span class="line">        	commitConfigMsg(env) <span class="comment">// 切块，写入账本。如果是 ORDERER_TRANSACTION 消息，创建新的应用通道账本；如果是 CONFIG 消息，更新配置。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-5-2-普通交易消息"><a href="#3-5-2-普通交易消息" class="headerlink" title="3.5.2 普通交易消息"></a><strong>3.5.2 普通交易消息</strong></h5><p>普通交易消息，会检查是否满足生成区块的条件，满足则产生区块并写入本地账本结构。通过内部的 <strong>commitNormalMsg(env)</strong> 方法来完成。</p>
<p>该方法主要调用  <strong>orderer/common/multichannel</strong>  模块中 <strong>BlockWriter</strong> 结构体的 <strong>CreateNextBlock(messages []<em>cb.Envelope) </em>cb.Block</strong> 方法和  <strong>WriteBlock(block *cb.Block, encodedMetadataValue []byte)</strong>   方法。 </p>
<p><strong>CreateNextBlock(messages []<em>cb.Envelope) </em>cb.Block</strong> 方法基本过程十分简单，创建新的区块，将传入的交易的信封结构直接序列化到 block.Data.Data[] 域中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/multichannel/blockwriter.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BlockWriter)</span> <span class="title">CreateNextBlock</span><span class="params">(messages []*cb.Envelope)</span> *<span class="title">cb</span>.<span class="title">Block</span></span> &#123;</span><br><span class="line">    previousBlockHash := bw.lastBlock.Header.Hash()</span><br><span class="line">    </span><br><span class="line">    data := &amp;cb.BlockData&#123;</span><br><span class="line">        Data: <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="built_in">len</span>(messages)),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">for</span> i, msg := <span class="keyword">range</span> messages &#123; </span><br><span class="line">        data.Data[i], err = proto.Marshal(msg) </span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; </span><br><span class="line">            logger.Panicf(<span class="string">"Could not marshal envelope: %s"</span>, err) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    block := cb.NewBlock(bw.lastBlock.Header.Number+<span class="number">1</span>, previousBlockHash) 	</span><br><span class="line">    block.Header.DataHash = data.Hash() </span><br><span class="line">    block.Data = data </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WriteBlock(block *cb.Block, encodedMetadataValue []byte)</strong>  方法则将 Kafka 相关的元数据也附加到区块结构中，添加区块的签名、最新配置的签名，并写入到本地账本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/multichannel/blockwriter.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BlockWriter)</span> <span class="title">WriteBlock</span><span class="params">(block *cb.Block, encodedMetadataValue []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    bw.committingBlock.Lock()</span><br><span class="line">    bw.lastBlock = block</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> bw.committingBlock.Unlock()</span><br><span class="line">        bw.commitBlock(encodedMetadataValue)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kafka 相关的元数据（KafkaMetadata）包括：</p>
<ul>
<li>LastOffsetPersisted：上次消息的偏移量；</li>
<li>LastOriginalOffsetProcessed：本条消息被重复处理时，最新的偏移量；</li>
<li>LastResubmittedConfigOffset：上次提交的配置消息的偏移量。</li>
</ul>
<h5 id="3-5-3-配置交易消息"><a href="#3-5-3-配置交易消息" class="headerlink" title="3.5.3 配置交易消息"></a><strong>3.5.3 配置交易消息</strong></h5><p>首先会检查消息中配置版本号是否跟当前链上的配置版本号一致。如果不一致，则会更新后生成新的配置信封消息，扔回到后端的共识模块（如 Kafka），并且阻塞新的 Broadcast 消息直到重新提交的消息得到处理。代码片段如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go</span></span><br><span class="line"><span class="keyword">if</span> regularMessage.ConfigSeq &lt; seq &#123; <span class="comment">// 消息中配置版本并非最新版本</span></span><br><span class="line">    configEnv, configSeq, err := chain.ProcessConfigMsg(env)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// For both messages that are ordered for the first time or re-ordered, we set original offset</span></span><br><span class="line">    <span class="comment">// to current received offset and re-order it.</span></span><br><span class="line">    <span class="keyword">if</span> err := chain.configure(configEnv, configSeq, receivedOffset); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"error re-submitting config message because = %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    chain.lastResubmittedConfigOffset = receivedOffset <span class="comment">// Keep track of last resubmitted message offset</span></span><br><span class="line">    chain.doneReprocessingMsgInFlight = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">//Create the channel to block ingress messages</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果版本一致，则调用内部的 commitConfigMsg(env) 方法根据信封结构来产生区块。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">commitConfigMsg := <span class="function"><span class="keyword">func</span><span class="params">(message *cb.Envelope, newOffset <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    batch := chain.BlockCutter().Cut() <span class="comment">// 尝试把收到的交易汇总</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> batch != <span class="literal">nil</span> &#123; <span class="comment">// 如果已经积累了一些交易，则先把它们打包为区块</span></span><br><span class="line">        block := chain.CreateNextBlock(batch)</span><br><span class="line">        metadata := utils.MarshalOrPanic(&amp;ab.KafkaMetadata&#123;</span><br><span class="line">            LastOffsetPersisted: receivedOffset - <span class="number">1</span>,</span><br><span class="line">            LastOriginalOffsetProcessed: chain.lastOriginalOffsetProcessed,</span><br><span class="line">            LastResubmittedConfigOffset: chain.lastResubmittedConfigOffset,</span><br><span class="line">        &#125;)</span><br><span class="line">        chain.WriteBlock(block, metadata)</span><br><span class="line">        chain.lastCutBlockNumber++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    chain.lastOriginalOffsetProcessed = newOffset</span><br><span class="line">    block := chain.CreateNextBlock([]*cb.Envelope&#123;message&#125;) <span class="comment">// 将配置交易生成区块</span></span><br><span class="line">    metadata := utils.MarshalOrPanic(&amp;ab.KafkaMetadata&#123;</span><br><span class="line">        LastOffsetPersisted: receivedOffset,</span><br><span class="line">        LastOriginalOffsetProcessed: chain.lastOriginalOffsetProcessed,</span><br><span class="line">        LastResubmittedConfigOffset: chain.lastResubmittedConfigOffset,</span><br><span class="line">    &#125;)</span><br><span class="line">    chain.WriteConfigBlock(block, metadata) <span class="comment">// 添加区块到系统链</span></span><br><span class="line">    chain.lastCutBlockNumber++</span><br><span class="line">    chain.timer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于每个配置消息会单独生成区块。因此，如果之前已经收到了一些普通交易消息，会先把这些消息生成区块。</p>
<p>接下来，调用 orderer/common/multichannel 模块中 BlockWriter 结构体的 <strong>CreateNextBlock(messages []<em>cb.Envelope) </em>cb.Block</strong> 方法和   <strong>WriteConfigBlock(block *cb.Block, encodedMetadataValue []byte)</strong>  方法来分别打包区块和更新账本结构，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go</span></span><br><span class="line">chain.lastOriginalOffsetProcessed = newOffset</span><br><span class="line">block := chain.CreateNextBlock([]*cb.Envelope&#123;message&#125;)</span><br><span class="line">metadata := utils.MarshalOrPanic(&amp;ab.KafkaMetadata&#123;</span><br><span class="line">    LastOffsetPersisted: receivedOffset,</span><br><span class="line">    LastOriginalOffsetProcessed: chain.lastOriginalOffsetProcessed,</span><br><span class="line">    LastResubmittedConfigOffset: chain.lastResubmittedConfigOffset,</span><br><span class="line">&#125;)</span><br><span class="line">chain.WriteConfigBlock(block, metadata)</span><br><span class="line">chain.lastCutBlockNumber++</span><br><span class="line">chain.timer = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>其中， WriteConfigBlock() 方法执行解析消息和处理的主要逻辑，核心代码如下所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/multichannel/blockwriter.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BlockWriter)</span> <span class="title">WriteConfigBlock</span><span class="params">(block *cb.Block, encodedMetadataValue []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 解析配置交易信封结构，每个区块中只有一个配置交易</span></span><br><span class="line">    ctx, err := utils.ExtractEnvelope(block, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析载荷和通道头结构</span></span><br><span class="line">    payload, err := utils.UnmarshalPayload(ctx.Payload)</span><br><span class="line">    chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按照配置交易内容，执行对应操作</span></span><br><span class="line">    <span class="keyword">switch</span> chdr.Type &#123; <span class="comment">// 排序后只有 ORDERER_TRANSACTION 和 CONFIG 两种类型消息</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int32</span>(cb.HeaderType_ORDERER_TRANSACTION): <span class="comment">// 新建应用通道</span></span><br><span class="line">        	newChannelConfig, err := utils.UnmarshalEnvelope(payload.Data)</span><br><span class="line">        <span class="comment">// 创建新的本地账本结构并启动对应的轮询消息过程，实际调用 orderer/common/multichann el.Registrar.newChain(configtx *cb.Envelope)</span></span><br><span class="line">        	bw.registrar.newChain(newChannelConfig)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int32</span>(cb.HeaderType_CONFIG): <span class="comment">// 更新通道配置</span></span><br><span class="line">        	configEnvelope, err := configtx.UnmarshalConfigEnvelope(payload.Data)</span><br><span class="line">        	bundle, err := bw.support.CreateBundle(chdr.ChannelId, configEnvelope.Config)</span><br><span class="line">        	bw.support.Update(bundle)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将区块写入到本地账本结构 </span></span><br><span class="line">    bw.WriteBlock(block, encodedMetadataValue)</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-6-Orderer-节点-Broadcast-请求的处理"><a href="#3-6-Orderer-节点-Broadcast-请求的处理" class="headerlink" title="3.6 Orderer 节点 Broadcast 请求的处理"></a><strong>3.6 Orderer</strong> 节点 <strong>Broadcast</strong> 请求的处理</h4><p>Broadcast，意味着客户端将请求消息（例如完成背书后的交易）通过 gRPC 接口发送给 </p>
<p>Ordering 服务。Orderer 进行本地验证处理后，会转化为入队消息发给后端共识模块（如 </p>
<p>Kafka）。 </p>
<p>发给 Orderer 的 Broadcast 请求消息包括链码的实例化、调用；通道的创建、更新。 </p>
<p>来自客户端的请求消息，会首先交给 orderer.common.server 包中 server 结构体的 </p>
<p>Broadcast(srv ab.AtomicBroadcast_BroadcastServer) error 方法处理。该方法主要会调用到 </p>
<p>orderer.common.broadcast 包中 handlerImpl 结构的 Handle(srv </p>
<p>ab.AtomicBroadcast_BroadcastServer) error 方法。 </p>
<p>handlerImpl 结构体十分重要，在 Orderer 整个处理过程中都会用到。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> handlerImpl <span class="keyword">struct</span> &#123; </span><br><span class="line"></span><br><span class="line">sm ChannelSupportRegistrar </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bh *handlerImpl)</span> <span class="title">Handle</span><span class="params">(srv ab.AtomicBroadcast_BroadcastServer)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Broadcast 请求的整体处理过程如下图所示。</p>
<p><img src="D:\其他\区块链研究\区块链笔记\Orderer节点broadcast处理过程.jpg" style="zoom: 150%"></p>
<p>​                                                                        图  - Orderer 节点 <em>Broadcast</em> 处理过程</p>
<p><strong>Handle(srv ab.AtomicBroadcast_BroadcastServer) error</strong> 方法会开启一个循环来从 srv 中读取请求消息并进行处理，直到结束。主要包括解析消息、处理消息（包括配置消息和非配置消息）和返回响应三个步骤。</p>
<p>核心代码如下所示（位于 <strong>orderer/common/broadcast/broadcast.go#handlerImpl.Handle()</strong> ）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    msg, error := srv.Recv() <span class="comment">// 从请求中提取一个 Envelope 消息</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析消息：判断是否为配置消息；获取对应本地账本结构：由通道头部中指定的通道 ID 决定，本地对应账 本结构不存在时（如新建应用通道）则由系统通道来处理</span></span><br><span class="line">    chdr, isConfig, processor, err := bh.sm.BroadcastChannelSupport(msg)</span><br><span class="line">    <span class="comment">// 检查是否被之前重新提交的消息阻塞</span></span><br><span class="line">    processor.WaitReady()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对应的通道结构对消息进行处理</span></span><br><span class="line">    <span class="keyword">if</span> !isConfig &#123; <span class="comment">// 普通消息</span></span><br><span class="line">        configSeq, err := processor.ProcessNormalMsg(msg) <span class="comment">//消息检查</span></span><br><span class="line">        processor.Order(msg, configSeq) <span class="comment">//入队列操作</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 配置消息，目前只有 CONFIG_UPDATE 类型，如创建、更新通道，或获取配置区块</span></span><br><span class="line">        config, configSeq, err := processor.ProcessConfigUpdateMsg(msg)<span class="comment">// 合并配置更新消息</span></span><br><span class="line">        processor.Configure(config, configSeq) <span class="comment">//入队列操作：相关处理后发给 Kafka</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    srv.Send(&amp;ab.BroadcastResponse&#123;Status: cb.Status_SUCCESS&#125;) <span class="comment">// 返回响应消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分为三个步骤： </p>
<ul>
<li>解析消息：判断是否为配置消息，决定消息应由哪个通道结构进行处理，注意对于创建应用通道消息，处理器指定为系统的通道结构；</li>
<li>处理消息：选用对应的通道结构对消息进行处理，包括普通消息和配置消息；</li>
<li>返回响应消息给请求方。</li>
</ul>
<h5 id="3-6-1-解析消息"><a href="#3-6-1-解析消息" class="headerlink" title="3.6.1 解析消息"></a><strong>3.6.1 解析消息</strong></h5><p>首先，解析消息，获取消息通道头、是否为配置消息、获取对应处理器结构（链结构）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdr, isConfig, processor, err := bh.sm.BroadcastChannelSupport(msg)</span><br></pre></td></tr></table></figure>
<p>实际上，会映射到 <strong>orderer.common.server</strong> 包中 <strong>broadcastSupport</strong> 结构体的 <strong>BroadcastChannelSupport(msg *cb.Envelope) (*cb.ChannelHeader, bool,broadcast.ChannelSupport, error)</strong> 方法，进一步调用到 orderer.common.multichannel 包中 Registrar 结构体的对应方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/multichannel/registrar.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Registrar)</span> <span class="title">BroadcastChannelSupport</span><span class="params">(msg *cb.Envelope)</span> <span class="params">(*cb.ChannelHeader, <span class="keyword">bool</span>, *ChainSupport, error)</span></span> &#123;</span><br><span class="line">    chdr, err := utils.ChannelHeader(msg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"could not determine channel ID: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cs, ok := r.chains[chdr.ChannelId] <span class="comment">// 应用通道、系统通道</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        cs = r.systemChannel <span class="comment">// 空，则默认为系统通道，如收到新建应用通道请求时，Orderer 本地并没有该应用通道结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    isConfig := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">switch</span> cs.ClassifyMsg(chdr) &#123; <span class="comment">// 只有 CONFIG_UPDATE 会返回 ConfigUpdateMsg</span></span><br><span class="line">    <span class="keyword">case</span> msgprocessor.ConfigUpdateMsg: <span class="comment">// CONFIG_UPDATE 消息，包括创建、更新通道，获取配置区块等</span></span><br><span class="line">        isConfig = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> chdr, isConfig, cs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>channel 头部从消息信封结构中解析出来；是否为配置信息根据消息头中通道类型进行判断（是否为 cb.HeaderType_CONFIG_UPDATE）；通过字典结构查到对应的 ChainSupport 结构（应用通道、系统通道）作为处理器。之后，利用解析后的结果，分别对不同类型的消息（普通消息、配置消息）进行不同处理。</p>
<p>对于普通交易消息，主要执行如下两个操作：消息格式检查和入队列操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">configSeq, err := processor.ProcessNormalMsg(msg) <span class="comment">//消息检查</span></span><br><span class="line">processor.Order(msg, configSeq) <span class="comment">//入队列操作</span></span><br></pre></td></tr></table></figure>
<p>消息检查方法会映射到 <strong>orderer.common.msgprocessor</strong> 包中 <strong>StandardChannel/SystemChannel</strong> 结构体的ProcessNormalMsg(env *cb.Envelope) (configSequint64, err error) 方法，以应用通道为例，实现如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/msgprocessor/standardchannel.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StandardChannel)</span> <span class="title">ProcessNormalMsg</span><span class="params">(env *cb.Envelope)</span> <span class="params">(configSeq <span class="keyword">uint64</span>, err error)</span></span>&#123;</span><br><span class="line">    configSeq = s.support.Sequence() <span class="comment">// 获取配置的序列号，映射到 common.configtx 包中 configManager 结构体的对应方法</span></span><br><span class="line">    err = s.filters.Apply(env) <span class="comment">// 进行过滤检查，实现为 orderer.common.msgprocessor 包中 RuleSet 结构体的对应方法。</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，过滤器会在创建 ChainSupport 结构时候初始化：</p>
<ul>
<li>应用通道：orderer.common.mspprocessor 包中的CreateStandardChannelFilters(filterSupport channelconfig.Resources) *RuleSet 方法，包括 EmptyRejectRule、SizeFilter 和SigFilter（ChannelWriters 角色）。</li>
<li>系统通道：orderer.common.mspprocessor 包中的CreateSystemChannelFilters(chainCreator ChainCreator, ledgerResourceschannelconfig.Resources) *RuleSet 方法，包括 <strong>EmptyRejectRule</strong>、<strong>SizeFilter</strong>、<strong>SigFilter（ChannelWriters 角色）</strong>和 <strong>SystemChannelFilter</strong>。 </li>
</ul>
<p><strong>入队列操作</strong> </p>
<p>入队列操作会根据 consensus 配置的不同映射到 orderer.consensus.solo 包或orderer.consensus.kafka 包中的方法。 </p>
<p>以 kafka 情况为例，会映射到 chainImpl 结构体的对应方法。该方法会将消息进一步封装为<em>sarama.ProducerMessage</em> 类型消息，通过 enqueue 方法发给 Kafka 后端。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go#chainImpl.Order(）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">Order</span><span class="params">(env *cb.Envelope, configSeq <span class="keyword">uint64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> chain.order(env, configSeq, <span class="keyword">int64</span>(<span class="number">0</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">order</span><span class="params">(env *cb.Envelope, configSeq <span class="keyword">uint64</span>, originalOffset <span class="keyword">int64</span> )</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    marshaledEnv, err := utils.Marshal(env)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot enqueue, unable to marshal envelope because = %s"</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !chain.enqueue(newNormalMessage(marshaledEnv, configSeq, originalOffset)) &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot enqueue"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-6-2-处理配置交易消息"><a href="#3-6-2-处理配置交易消息" class="headerlink" title="3.6.2 处理配置交易消息"></a><strong>3.6.2 处理配置交易消息</strong></h5><p>对于配置交易消息（CONFIG_UPDATE 类型消息，包括创建、更新通道，获取配置区块等），处理过程与正常消息略有不同，包括合并配置更新消息和入队列操作两个操作。</p>
<p><strong>合并配置更新</strong></p>
<p>主要过程包括如下两个步骤：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config, configSeq, err := processor.ProcessConfigUpdateMsg(msg) <span class="comment">// 合并配置更新，生成新的配置信封结构</span></span><br><span class="line">processor.Configure(config, configSeq) <span class="comment">//入队列操作，将生成的配置信封结构消息扔给后端队列（如Kafka)</span></span><br></pre></td></tr></table></figure>
<p>其中，合并配置更新消息方法会映射到 <strong>orderer.common.msgprocessor</strong> 包中<strong>StandardChannel/SystemChannel</strong> 结构体的 <strong>ProcessConfigUpdateMsg(env *cb.Envelope)(configSeq uint64, err error)</strong> 方法，计算合并后的配置和配置编号。</p>
<p>以应用通道为例，实现如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/msgprocessor/standardchannel.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StandardChannel)</span> <span class="title">ProcessConfigUpdateMsg</span><span class="params">(env *cb.Envelope)</span> <span class="params">(config *cb.Envelop e, configSeq <span class="keyword">uint64</span>, err error)</span></span> &#123;</span><br><span class="line">    logger.Debugf(<span class="string">"Processing config update message for channel %s"</span>, s.support.ChainID())</span><br><span class="line">    seq := s.support.Sequence() <span class="comment">// 获取当前配置的版本号</span></span><br><span class="line">    err = s.filters.Apply(env) <span class="comment">// 校验权限，是否可以更新配置</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据输入的更新配置交易消息生成配置信封结构：Config 为更新后配置字典；LastUpdate 为输入的更新配置交易</span></span><br><span class="line">    <span class="comment">// 最终调用 `common/configtx` 包下 `ValidatorImpl.ProposeConfigUpdate()` 方法。</span></span><br><span class="line">    configEnvelope, err := s.support.ProposeConfigUpdate(env)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成签名的配置信封结构，通道头类型为 HeaderType_CONFIG。即排序后消息类型将由 CONFIG_UPDATE 变更为 CONFIG</span></span><br><span class="line">    config, err = utils.CreateSignedEnvelope(cb.HeaderType_CONFIG, s.support.ChainID(), s.support.Signer(), configEnvelope, msgVersion, epoch)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    err = s.filters.Apply(config) <span class="comment">// 校验生成的配置消息是否合法</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config, seq, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于系统通道情况，除了调用普通通道结构的对应方法来处理普通的更新配置交易外，还会负责新建应用通道请求。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/msgprocessor/systemchannel.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SystemChannel)</span> <span class="title">ProcessConfigUpdateMsg</span><span class="params">(envConfigUpdate *cb.Envelope)</span> <span class="params">(config *cb.Envelope, configSeq <span class="keyword">uint64</span>, err error)</span></span> &#123;</span><br><span class="line">    channelID, err := utils.ChannelID(envConfigUpdate)</span><br><span class="line">    <span class="keyword">if</span> channelID == s.support.ChainID() &#123; <span class="comment">// 更新系统通道的配置交易，与普通通道相同处理</span></span><br><span class="line">        <span class="keyword">return</span> s.StandardChannel.ProcessConfigUpdateMsg(envConfigUpdate)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从系统通道中获取当前最新的配置</span></span><br><span class="line">    <span class="comment">// orderer/common/msgprocessor/systemchannel.go#DefaultTemplator.NewChannelConfig()</span></span><br><span class="line">    bundle, err := s.templator.NewChannelConfig(envConfigUpdate)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并来自客户端的配置更新信封结构，创建配置信封结构 ConfigEnvelope</span></span><br><span class="line">    newChannelConfigEnv, err := bundle.ConfigtxValidator().ProposeConfigUpdate(envConf igUpdate)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 封装新的签名信封结构，其 Payload.Data 是 newChannelConfigEnv</span></span><br><span class="line">    newChannelEnvConfig, err := utils.CreateSignedEnvelope(cb.HeaderType_CONFIG, channelID, s.support.Signer(), newChannelConfigEnv, msgVersion, epoch)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理新建应用通道请求，封装为 ORDERER_TRANSACTION 类型消息</span></span><br><span class="line">    wrappedOrdererTransaction, err := utils.CreateSignedEnvelope(cb.HeaderType_ORDERER_TRANSACTION, s.support.ChainID(), s.support.Signer(), newChannelEnvConfig, msgVersion, epoch)</span><br><span class="line">    s.StandardChannel.filters.Apply(wrappedOrdererTransaction) <span class="comment">// 再次校验配置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回封装后的签名信封结构</span></span><br><span class="line">    <span class="keyword">return</span> wrappedOrdererTransaction, s.support.Sequence(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队列操作会根据 consensus 配置的不同映射到 orderer.consensus.solo 包或 orderer.consensus.kafka 包中的方法。以 kafka 情况为例，会映射到 chainImpl 结构体的 Configure(config <em>cb.Envelope, configSeq uint64) 方法。该方法会调用 configure(config </em>cb.Envelope, configSeq uint64, originalOffset int64) 方法，将消息进一步封装为 KafkaMessage_Regular 类型消息，通过 enqueue 方法发给 Kafka 后端。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">configure</span><span class="params">(config *cb.Envelope, configSeq <span class="keyword">uint64</span>, originalOffset <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    marshaledConfig, err := utils.Marshal(config)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot enqueue, unable to marshal config because %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 封装为 `KafkaMessageRegular_CONFIG` 类型消息，并通过 producer 发给 Kafka</span></span><br><span class="line">    <span class="keyword">if</span> !chain.enqueue(newConfigMessage(marshaledConfig, configSeq, originalOffset)) &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot enqueue"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，封装为 KafkaMessageRegular_CONFIG 类型消息过程十分简单。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newConfigMessage</span><span class="params">(config []<span class="keyword">byte</span>, configSeq <span class="keyword">uint64</span>, originalOffset <span class="keyword">int64</span>)</span> *<span class="title">ab</span>.<span class="title">KafkaMessage</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ab.KafkaMessage&#123;</span><br><span class="line">        Type: &amp;ab.KafkaMessage_Regular&#123;</span><br><span class="line">            Regular: &amp;ab.KafkaMessageRegular&#123;</span><br><span class="line">                Payload: config,</span><br><span class="line">                ConfigSeq: configSeq,</span><br><span class="line">                Class: ab.KafkaMessageRegular_CONFIG,</span><br><span class="line">                OriginalOffset: originalOffset,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后 Orderer 将再次从 Kakfa 获取到共识（这里主要是排序）完成的 </p>
<p>KafkaMessageRegular_CONFIG 消息，进行解析和处理。具体可以参考<strong>Orderer 节点对排序后消息的处理过程</strong>。</p>
<h5 id="3-6-3-返回响应"><a href="#3-6-3-返回响应" class="headerlink" title="3.6.3 返回响应"></a><strong>3.6.3 返回响应</strong></h5><p>如果处理成功，则返回成功响应消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srv.Send(&amp;ab.BroadcastResponse&#123;Status: cb.Status_SUCCESS&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="3-7-Orderer-节点-Deliver-请求的处理"><a href="#3-7-Orderer-节点-Deliver-请求的处理" class="headerlink" title="3.7 Orderer 节点 Deliver 请求的处理"></a><strong>3.7 Orderer</strong> 节点 <strong>Deliver</strong> 请求的处理</h4><p>Deliver，意味着客户端通过 gRPC 接口从 Ordering 服务获取数据（例如指定区块的数据）。 </p>
<p>Orderer 节点收到请求消息，会首先交给 <strong>orderer.common.server</strong> 包中 server 结构体的 </p>
<p><strong>Deliver(srv ab.AtomicBroadcast_DeliverServer) error</strong> 方法处理。该方法进一步调用 </p>
<p><strong>orderer.common.deliver</strong> 包中 <strong>deliverServer</strong> 结构的 Handle(srv ab.AtomicBroadcast_DeliverServer) error 方法进行处理。 </p>
<p>deliverServer 结构体十分重要，完成对 Deliver 请求的处理过程。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> deliverServer <span class="keyword">struct</span> &#123; </span><br><span class="line"></span><br><span class="line">sm SupportManager </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *deliverServer)</span> <span class="title">Handle</span><span class="params">(srv ab.AtomicBroadcast_DeliverServer)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>整体处理过程如下图所示。</p>
<p><img src="D:\其他\区块链研究\区块链笔记\Orderer 节点 Deliver 处理过程.jpg" style="zoom:150%"></p>
<p>​                                                                <em>Orderer</em> 节点 <em>Deliver</em> 处理过程</p>
<p>Handle(srv ab.AtomicBroadcast_DeliverServer) error 方法会开启一个循环来从 srv 中不断读 取请求消息并进行处理，直到结束。 </p>
<p>核心代码如下所示，包括提取消息和对消息进行处理两个步骤。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	envelope, err := srv.Recv() <span class="comment">// 从请求中提取一个 Envelope 消息</span></span><br><span class="line">    ds.deliverBlocks(srv, envelope) <span class="comment">// 对消息进行处理并答复，核心过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，对单个请求的处理都在 deliverBlocks(srv ab.AtomicBroadcast_DeliverServer, envelope </p>
<p>*cb.Envelope) 方法中。该方法的处理过程包括<strong>解析消息</strong>、<strong>检查合法性</strong>、<strong>发送区块</strong>以及<strong>返回响</strong> </p>
<p><strong>应</strong>四个步骤。</p>
<h5 id="3-7-1-解析消息"><a href="#3-7-1-解析消息" class="headerlink" title="3.7.1 解析消息"></a><strong>3.7.1 解析消息</strong></h5><p>首先，从请求的 Envelope 结构中提取载荷（Payload），进一步从载荷中提取通道头部信息。利用通道头部信息获取对应的本地链结构，并获取当前最新的配置序列号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取载荷</span></span><br><span class="line">payload, err := utils.UnmarshalPayload(envelope.Payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取通道头</span></span><br><span class="line">chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链结构，映射到 orderer.common.multichannel 包中 Registrar 结构体中对应方法</span></span><br><span class="line">chain, ok := ds.sm.GetChain(chdr.ChannelId)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前配置序列号</span></span><br><span class="line">lastConfigSequence := chain.Sequence()</span><br></pre></td></tr></table></figure>
<h5 id="3-7-2-检查合法性"><a href="#3-7-2-检查合法性" class="headerlink" title="3.7.2 检查合法性"></a><strong>3.7.2 检查合法性</strong></h5><p>包括对权限和 seekInfo 数据进行检查。首先，检查请求方是否对通道拥有读权限。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sf := msgprocessor.NewSigFilter(policies.ChannelReaders, chain.PolicyManager())</span><br><span class="line"><span class="keyword">if</span> err := sf.Apply(envelope); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logger.Warningf(<span class="string">"[channel: %s] Received unauthorized deliver request from %s: %s"</span>,chdr.ChannelId, addr, err)</span><br><span class="line">    <span class="keyword">return</span> sendStatusReply(srv, cb.Status_FORBIDDEN)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，从 Envelope 结构的 payload.data 域中解析出 seekInfo 结构，并检查其合法性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">proto.Unmarshal(payload.Data, seekInfo)</span><br><span class="line">chain.Reader().Iterator(seekInfo.Start)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 seekInfo 的</span></span><br><span class="line">cursor, number := chain.Reader().Iterator(seekInfo.Start)</span><br><span class="line"><span class="keyword">switch</span> stop := seekInfo.Stop.Type.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *ab.SeekPosition_Oldest: <span class="comment">// 截止到最早的区块</span></span><br><span class="line">    	stopNum = number</span><br><span class="line">    <span class="keyword">case</span> *ab.SeekPosition_Newest: <span class="comment">// 截止到最新的区块</span></span><br><span class="line">    	stopNum = chain.Reader().Height() - <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> *ab.SeekPosition_Specified: <span class="comment">// 截止到特定的区块</span></span><br><span class="line">    	stopNum = stop.Specified.Number</span><br><span class="line">    <span class="keyword">if</span> stopNum &lt; number &#123;</span><br><span class="line">        logger.Warningf(<span class="string">"[channel: %s] Received invalid seekInfo message from %s: star t number %d greater than stop number %d"</span>, chdr.ChannelId, addr, number, stopNum)</span><br><span class="line">        <span class="keyword">return</span> sendStatusReply(srv, cb.Status_BAD_REQUEST)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-7-3-发送区块"><a href="#3-7-3-发送区块" class="headerlink" title="3.7.3 发送区块"></a><strong>3.7.3 发送区块</strong></h5><p>在指定的起始和截止范围内，逐个从本地账本读取区块，并发送对应的区块数据，核心代码如下所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    block, status := cursor.Next() <span class="comment">// 获取区块</span></span><br><span class="line">    sendBlockReply(srv, block) <span class="comment">// 发送区块</span></span><br><span class="line">    <span class="keyword">if</span> stopNum == block.Header.Number &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-7-4-返回响应"><a href="#3-7-4-返回响应" class="headerlink" title="3.7.4 返回响应"></a><strong>3.7.4 返回响应</strong></h5><p>如果处理成功，则返回成功响应消息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendStatusReply(srv, cb.Status_SUCCESS)</span><br></pre></td></tr></table></figure>
<h4 id="3-8-客户端执行创建通道"><a href="#3-8-客户端执行创建通道" class="headerlink" title="3.8 客户端执行创建通道"></a>3.8 客户端执行创建通道</h4><p>主要步骤包括： </p>
<ul>
<li>客户端调用 sendCreateChainTransaction()，检查指定的配置交易文件，或者利用默认配 </li>
</ul>
<p>置，构造一个创建应用通道的配置交易结构，封装为 Envelope，指定 channel 头部类型 </p>
<p>为 CONFIG_UPDATE。 </p>
<ul>
<li>客户端发送配置交易到 Ordering 服务。 </li>
</ul>
<ul>
<li><p>Orderer 收到 CONFIG_UPDATE 消息后，检查指定的通道还不存在，则开始新建过程 </p>
<p>（参考 orderer/configupdate/configupdate.go 文件），构造该应用通道的初始区块。 </p>
<ul>
<li>Orderer 首先检查通道应用（Application）配置中的组织都在创建的联盟 （Consortium）配置组织中。</li>
<li>之后从系统通道中获取 Orderer 相关的配置，并创建应用通道配置，对应 mod_policy 为系统通道配置中的联盟指定信息。</li>
<li>接下来根据 CONFIG_UPDATE 消息的内容更新获取到的配置信息。所有配置发生变更后版本号都要更新。</li>
<li>最后，创建签名 Proposal 消息（头部类型为 ORDERER_TRANSACTION），发送到系统通道中，完成应用通道的创建过程。</li>
</ul>
</li>
<li><p>客户端利用 gRPC 通道从 Orderer 服务获取到该应用通道的初始区块（<strong>具体过程类似fetch 命令）。 </strong></p>
</li>
<li><p>客户端将收到的区块写入到本地的 chainID + “.block” 文件。这个文件后续会被需要加入到通道的节点使用。</p>
</li>
</ul>
<h4 id="3-9-客户端执行加入通道"><a href="#3-9-客户端执行加入通道" class="headerlink" title="3.9 客户端执行加入通道"></a>3.9 客户端执行加入通道</h4><p>主要步骤包括： </p>
<ul>
<li>客户端首先创建一个 ChaincodeSpec 结构，其 input 中的 Args 第一个参数是 </li>
</ul>
<p>CSCC.JoinChain（指定调用配置链码的操作），第二个参数为所加入通道的初始区块。 </p>
<ul>
<li><p>利用 ChaincodeSpec 构造一个 ChaincodeInvocationSpec 结构。 </p>
</li>
<li><p>利用 ChaincodeInvocationSpec，创建 Proposal 结构并进行签名，channel 头部类型为 </p>
</li>
</ul>
<p>CONFIG。 </p>
<ul>
<li>客户端通过 gRPC 将 Proposal 签名后发给 Endorser（所操作的 Peer），调用 </li>
</ul>
<p>ProcessProposal(ctx context.Context, in *SignedProposal, opts …grpc.CallOption) </p>
<p>(*ProposalResponse, error) 方法进行处理，主要通过配置系统链码进行本地链的初始化 </p>
<p>工作。 </p>
<ul>
<li>初始化完成后，即可收到来自通道内的 Gossip 消息等。 </li>
</ul>
<p>其中，比较重要的数据结构包括 ChaincodeSpec、ChaincodeInvocationSpec、Proposal </p>
<p>等。 </p>
<h4 id="3-10-客户端执行链码安装"><a href="#3-10-客户端执行链码安装" class="headerlink" title="3.10 客户端执行链码安装"></a>3.10 客户端执行链码安装</h4><h5 id="链码安装过程"><a href="#链码安装过程" class="headerlink" title="链码安装过程"></a>链码安装过程</h5><p>​        链码安装主要包括两个部分： </p>
<ul>
<li><p>客户端封装安装消息； </p>
</li>
<li><p>Peer 节点处理请求。 </p>
</li>
</ul>
<h5 id="3-10-1-客户端封装安装消息"><a href="#3-10-1-客户端封装安装消息" class="headerlink" title="3.10.1  客户端封装安装消息"></a>3.10.1  客户端封装安装消息</h5><p>客户端将链码的源码和环境等内容封装为一个链码安装打包文件（Chaincode Install </p>
<p>Package，CIP），并传输到指定的 Peer 节点。此过程只需要跟 Peer 节点打交道。 </p>
<p>主要步骤包括： </p>
<ul>
<li><p>首先是构造带签名的提案结构（SignedProposal）。 </p>
<ul>
<li><p>调用 InitCmdFactory(isEndorserRequired, isOrdererRequired bool) </p>
<p>​    (*ChaincodeCmdFactory, error) 方法，初始化 EndoserClient（跟 Peer 通信）、 </p>
<p>​    BroadcastClient（跟 Orderer 通信）、Signer（签名操作）等辅助结构体。所有链 </p>
<p>​    码子命令都会执行该过程，会根据需求具体初始化不同的结构。 </p>
</li>
<li><p>然后根据命令行参数进行解析，判断是根据传入的打包文件来直接读取 </p>
<p>​    ChaincodeDeploymentSpec（CDS）结构，还是根据传入参数从本地链码源代码文 </p>
<p>​    件来构造生成。 </p>
</li>
<li><p>以本地重新构造情况为例，首先根据命令行中传入的路径、名称等信息，构造生成 </p>
<p>ChaincodeSpec（CS）结构。 </p>
</li>
<li><p>利用 ChaincodeSpec 结构，结合链码包数据生成一个 ChaincodeDeploymentSpec </p>
<p>结构（chainID 为空），调用本地的 install(msg proto.Message, cf </p>
<p>*ChaincodeCmdFactory) error 方法。 </p>
</li>
<li><p>install 方法基于传入的 ChaincodeDeploymentSpec 结构，构造一个对生命周期管理 </p>
<p>系统链码（LSCC）调用的 ChaincodeSpec 结构，其中，Type 为 </p>
<p>ChaincodeSpec_GOLANG，ChaincodeId.Name 为“lscc”，Input 为 </p>
<p>“install”+ChaincodeDeploymentSpec。进一步地，构造了一个 LSCC 的 </p>
<p>ChaincodeInvocationSpec（CIS）结构，对 ChaincodeSpec 结构进行封装。 </p>
</li>
<li><p>基于 LSCC 的 ChaincodeInvocationSpec 结构，添加头部结构，生成一个提案 </p>
<p>（Proposal）结构。其中，通道头部中类型为 ENDORSER_TRANSACTION，TxID </p>
<p>为对随机数+签名实体，进行 Hash。 </p>
</li>
<li><p>对 Proposal 进行签名，转化为一个签名后的提案消息结构 SignedProposal。 </p>
</li>
</ul>
</li>
</ul>
<ul>
<li>将带签名的提案结构通过 EndorserClient 经由 gRPC 通道发送给 Peer 的 </li>
</ul>
<p>ProcessProposal(ctx context.Context, in *SignedProposal, opts …grpc.CallOption) </p>
<p>(*ProposalResponse, error) 接口。 </p>
<ul>
<li>Peer 模拟运行生命周期链码的调用交易进行处理，检查格式、签名和权限等，通过则保</li>
</ul>
<p>86客户端执行链码安装 存到本地文件系统。 </p>
<h4 id="3-11客户端执行链码实例化"><a href="#3-11客户端执行链码实例化" class="headerlink" title="3.11客户端执行链码实例化"></a>3.11客户端执行链码实例化</h4><p>主要步骤包括：</p>
<ul>
<li>首先，类似链码安装命令，需要创建一个 SignedProposal 消息。注意 instantiate 和upgrade 支持 policy、escc、vscc 等参数。LSCC 的 ChaincodeSpec 结构中，Input 中包括类型（“deploy”）、通道 ID、ChaincodeDeploymentSpec 结构、背书策略、escc 和vscc 等。 </li>
<li>调用 EndorserClient，发送 gRPC 消息，将签名后的 Proposal 发给指定的 Peer 节点（Endorser），调用 ProcessProposal(ctx context.Context, in *<em>SignedProposal, opts …grpc.CallOption) (</em>*ProposalResponse, error) 方法，进行背书处理。节点会模拟运行LSCC 的调用交易，启动链码容器。实例化成功后会返回 ProposalResponse 消息（其中包括背书签名）。</li>
<li>根据 Peer 返回的 ProposalResponse 消息，创建一个 SignedTX（Envelop 结构的交易，带有签名）。</li>
<li>使用 BroadcastClient 将交易消息通过 gRPC 通道发给 Orderer，Orderer 会进行全网排序，并广播给 Peer 进行确认提交。</li>
</ul>
<h4 id="3-12-客户端执行链码调用"><a href="#3-12-客户端执行链码调用" class="headerlink" title="3.12 客户端执行链码调用"></a>3.12 客户端执行链码调用</h4><p>基本过程如下： </p>
<ul>
<li>首先，也是要创建一个 SignedProposal 消息。根据传入的各种参数，生成 ChaincodeSpec 结构（其中，Input 为传入的调用参数）。然后，根据 ChaincodeSpec、chainID、签名实体等，生成 ChaincodeInvocationSpec 结构。进而封装生成 Proposal 结构（通道头部中类型为ENDORSER_TRANSACTION），并进行签名。</li>
<li>调用 EndorserClient，发送 gRPC 消息，将签名后的 Proposal 发给指定的 Peer 节点 （Endorser），调用 ProcessProposal(ctx context.Context, in <em>SignedProposal, opts…grpc.CallOption) (</em>*ProposalResponse, error) 方法，进行背书处理。节点会模拟运行链码调用交易，成功后会返回 ProposalResponse 消息（带有背书签名）。</li>
<li>根据 Peer 返回的 ProposalResponse 消息，创建一个 SignedTX（Envelop 结构的交易，带有签名）。</li>
<li>使用 BroadcastClient 将交易消息通过 gRPC 通道发给 Orderer 进行全网排序并广播给Peer 进行确认提交。</li>
</ul>
<p>注意 invoke 是异步操作，invoke 成功只能保证交易已经进入 Orderer 进行排序，但无法保证 </p>
<p>最终写到账本中（例如交易未通过 Committer 验证而被拒绝）。需要通过 eventHub 或查询 </p>
<p>方式来进行确认交易是否最终写入到账本上。 </p>
<h4 id="3-13-客户端执行链码查询"><a href="#3-13-客户端执行链码查询" class="headerlink" title="3.13 客户端执行链码查询"></a>3.13 客户端执行链码查询</h4><p>主要过程如下:</p>
<ul>
<li>根据传入的各种参数，最终构造签名提案，通过 endorserClient 发送给指定的 Peer。</li>
<li>成功的话，获取到 ProposalResponse，打印出 proposalResp.Response.Payload 内容。</li>
</ul>
<p>需要注意 invoke 和 query 的区别，query 不需要创建 SignedTx 发送到 Orderer，而且会返回 </p>
<p>查询的结果。 </p>
<h2 id="Fabric词汇"><a href="#Fabric词汇" class="headerlink" title="Fabric词汇"></a>Fabric词汇</h2><h3 id="Anchor-Peer-锚节点"><a href="#Anchor-Peer-锚节点" class="headerlink" title="Anchor Peer - 锚节点"></a>Anchor Peer - 锚节点</h3><p>A peer node on a channel that all other peers can discover and communicate with. Each <a href="https://hyperledgercn.github.io/hyperledgerDocs/glossary/#Member" target="_blank" rel="noopener">Member</a> on a channel has an anchor peer (or multiple anchor peers to prevent single point of failure), allowing for peers belonging to different Members to discover all existing peers on a channel.</p>
<p>锚节点是通道中能被所有对等节点探测、并能与之进行通信的一种对等节点。通道中的每个成员都有一个（或多个，以防单点故障）锚节点，允许属于不同成员身份的节点来发现通道中存在的其它节点。</p>
<h3 id="Block-区块"><a href="#Block-区块" class="headerlink" title="Block - 区块"></a>Block - 区块</h3><p>An ordered set of transactions that is cryptographically linked to the preceding block(s) on a channel.</p>
<p>在一个通道上，（区块是）一组有序交易的集合。区块往往通过密码学手段（Hash 值）连接到前导区块。</p>
<p> 区块是一组有序的交易集合，在通道中经过加密（哈希加密）后与前序区块连接。</p>
<h3 id="Chain-链"><a href="#Chain-链" class="headerlink" title="Chain - 链"></a>Chain - 链</h3><p>The ledger’s chain is a transaction log structured as hash-linked blocks of transactions. Peers receive blocks of transactions from the ordering service, mark the block’s transactions as valid or invalid based on endorsement policies and concurrency violations, and append the block to the hash chain on the peer’s file system.</p>
<p>chain就是block之间以hash连接为结构的交易日志。peer从order service接收交易block，并根据背书策略和并发冲突标记block上的交易是否有效，然后将该block追加到peer文件系统中的hash chain上。</p>
<p> 账本的链是一个交易区块经过“哈希连接”结构化的交易日志。对等节点从排序服务收到交易区块，基于背书策略和并发冲突来标注区块的交易为有效或者无效状态，并且将区块追加到对等节点文件系统的哈希链中。 </p>
<h3 id="Chaincode-链码"><a href="#Chaincode-链码" class="headerlink" title="Chaincode - 链码"></a>Chaincode - 链码</h3><p>Chaincode is software, running on a ledger, to encode assets and the transaction instructions (business logic) for modifying the assets.</p>
<p>链码是一个运行在账本上的软件，它可以对资产进行编码，其中的交易指令（或者叫业务逻辑）也可以用来修改资产。</p>
<h3 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel - 通道"></a>Channel - 通道</h3><p>A channel is a private blockchain overlay on a Fabric network, allowing for data isolation and confidentiality. A channel-specific ledger is shared across the peers in the channel, and transacting parties must be properly authenticated to a channel in order to interact with it. Channels are defined by a <a href="https://hyperledgercn.github.io/hyperledgerDocs/glossary/#Configuration-Block" target="_blank" rel="noopener">Configuration-Block</a>.</p>
<p>通道是构建在“Fabric”网络上的私有区块链，实现了数据的隔离和保密。通道特定的账本在通道中是与所有对等节点共享的，并且交易方必须通过该通道的正确验证才能与账本进行交互。通道是由一个“配置块”来定义的。</p>
<h3 id="Commitment-提交"><a href="#Commitment-提交" class="headerlink" title="Commitment - 提交"></a>Commitment - 提交</h3><p>Each <a href="https://hyperledgercn.github.io/hyperledgerDocs/glossary/#Peer" target="_blank" rel="noopener">Peer</a> on a channel validates ordered blocks of transactions and then commits (writes-appends) the blocks to its replica of the channel <a href="https://hyperledgercn.github.io/hyperledgerDocs/glossary/#Ledger" target="_blank" rel="noopener">Ledger</a>. Peers also mark each transaction in each block as valid or invalid.</p>
<p>一个通道中的每个对等节点都会验证交易的有序区块，然后将区块提交（写或追加）至该通道上账本的各个副本。对等节点也会标记每个区块中的每笔交易的状态是有效或者无效。</p>
<h3 id="Consensus-共识"><a href="#Consensus-共识" class="headerlink" title="Consensus - 共识"></a>Consensus - 共识</h3><p>A broader term overarching the entire transactional flow, which serves to generate an agreement on the order and to confirm the correctness of the set of transactions constituting a block.</p>
<p>共识是贯穿整个交易流程的广义术语，其用于产生一个对于排序的同意书和确认构成区块的交易集的正确性。</p>
<h3 id="Current-State-当前状态"><a href="#Current-State-当前状态" class="headerlink" title="Current State - 当前状态"></a>Current State - 当前状态</h3><p>The current state of the ledger represents the latest values for all keys ever included in its chain transaction log. Peers commit the latest values to ledger current state for each valid transaction included in a processed block. Since current state represents all latest key values known to the channel, it is sometimes referred to as World State. Chaincode executes transaction proposals against current state data.</p>
<p>ledger的current state表示其chain交易log中所有key的最新值。peer会将处理过的block中的每个交易对应的修改value提交到ledger的current state，由于current state表示channel所知的所有最新的k-v，所以current state也被称为World State。Chaincode执行交易proposal就是针对的current state。</p>
<h3 id="Dynamic-Membership-动态成员"><a href="#Dynamic-Membership-动态成员" class="headerlink" title="Dynamic Membership - 动态成员"></a>Dynamic Membership - 动态成员</h3><p>Fabric supports the addition-removal of members, peers, and ordering service nodes, without compromising the operationality of the overall network. Dynamic membership is critical when business relationships adjust and entities need to be added-removed for various reasons.</p>
<p>Fabric支持动态添加-移除members、peers和ordering服务节点，而不会影响整个网络的操作性。当业务关系调整或因各种原因需添加-移除实体时，Dynamic Membership至关重要。</p>
<h3 id="Endorsement-背书"><a href="#Endorsement-背书" class="headerlink" title="Endorsement - 背书"></a>Endorsement - 背书</h3><p>Refers to the process where specific peer nodes execute a transaction and return a <code>YES-NO</code> response to the client application that generated the transaction proposal. Chaincode applications have corresponding endorsement policies, in which the endorsing peers are specified.</p>
<p>Endorsement 是指一个peer执行一个交易并返回<code>YES-NO</code>给生成交易proposal的client app 的过程。chaincode具有相应的endorsement policies，其中指定了endorsing peer。</p>
<h3 id="Endorsement-policy-背书策略"><a href="#Endorsement-policy-背书策略" class="headerlink" title="Endorsement policy - 背书策略"></a>Endorsement policy - 背书策略</h3><p>Defines the peer nodes on a channel that must execute transactions attached to a specific chaincode application, and the required combination of responses (endorsements). A policy could require that a transaction be endorsed by a minimum number of endorsing peers, a minimum percentage of endorsing peers, or by all endorsing peers that are assigned to a specific chaincode application. Policies can be curated based on the application and the desired level of resilience against misbehavior (deliberate or not) by the endorsing peers. A distinct endorsement policy for install and instantiate transactions is also required.</p>
<p>Endorsement policy定义了依赖于特定chaincode执行交易的channel上的peer和响应结果（endorsements）的必要组合条件（即返回Yes或No的条件）。Endorsement policy可指定对于某一chaincode，可以对交易背书的最小背书节点数或者最小背书节点百分比。背书策略由背书节点基于应用程序和对抵御不良行为的期望水平来组织管理。在install和instantiate Chaincode（deploy tx）时需要指定背书策略。</p>
<h3 id="Fabric-ca"><a href="#Fabric-ca" class="headerlink" title="Fabric-ca"></a>Fabric-ca</h3><p>Fabric-ca is the default Certificate Authority component, which issues PKI-based certificates to network member organizations and their users. The CA issues one root certificate (rootCert) to each member, one enrollment certificate (eCert) to each authorized user, and a number of transaction certificates (tCerts) for each eCert.</p>
<p>Fabric-ca是默认的证书管理组件，它向网络成员及其用户颁发基于PKI的证书。CA为每个成员颁发一个根证书（rootCert），为每个授权用户颁发一个注册证书（eCert），为每个注册证书颁发大量交易证书（tCerts）。</p>
<h3 id="Genesis-Block-初始区块"><a href="#Genesis-Block-初始区块" class="headerlink" title="Genesis Block - 初始区块"></a>Genesis Block - 初始区块</h3><p>The configuration block that initializes a blockchain network or channel, and also serves as the first block on a chain.</p>
<p>Genesis Block是初始化区块链网络或channel的配置区块，也是链上的第一个区块。</p>
<h3 id="Gossip-Protocol-Gossip协议"><a href="#Gossip-Protocol-Gossip协议" class="headerlink" title="Gossip Protocol - Gossip协议"></a>Gossip Protocol - Gossip协议</h3><p>The gossip data dissemination protocol performs three functions: 1) manages peer discovery and channel membership; 2) disseminates ledger data across all peers on the channel; 3) syncs ledger state across all peers on the channel. Refer to the <a href="http://--hyperledger-fabric.readthedocs.io-en-latest-gossip.html/" target="_blank" rel="noopener">Gossip</a> topic for more details.</p>
<p>Gossip数据传输协议有三项功能：1）管理peer发现和channel成员；2）channel上的所有peer间广播账本数据；3）channel上的所有peer间同步账本数据。</p>
<h3 id="Initialize-初始化"><a href="#Initialize-初始化" class="headerlink" title="Initialize - 初始化"></a>Initialize - 初始化</h3><p>A method to initialize a chaincode application.</p>
<p>一个初始化chaincode程序的方法。</p>
<h3 id="Install-安装"><a href="#Install-安装" class="headerlink" title="Install - 安装"></a>Install - 安装</h3><p>The process of placing a chaincode on a peer’s file system.</p>
<p>将chaincode放到peer的文件系统的过程。<em>（译注：即将ChaincodeDeploymentSpec信息存到chaincodeInstallPath-chaincodeName.chainVersion文件中）</em></p>
<h3 id="Instantiate-实例化"><a href="#Instantiate-实例化" class="headerlink" title="Instantiate - 实例化"></a>Instantiate - 实例化</h3><p>The process of starting a chaincode container.</p>
<p>启动chaincode容器的过程。<em>（译注：在lccc中将ChaincodeData保存到state中，然后deploy Chaincode并执行Init方法）</em></p>
<h3 id="Invoke-调用"><a href="#Invoke-调用" class="headerlink" title="Invoke - 调用"></a>Invoke - 调用</h3><p>Used to call chaincode functions. Invocations are captured as transaction proposals, which then pass through a modular flow of endorsement, ordering, validation, committal. The structure of invoke is a function and an array of arguments.</p>
<p>用于调用chaincode内的函数。Chaincode invoke就是一个交易proposal，然后执行模块化的流程（背书、共识、 验证、 提交）。invoke的结构就是一个函数和一个参数数组。</p>
<h3 id="Leading-Peer-主导节点"><a href="#Leading-Peer-主导节点" class="headerlink" title="Leading Peer - 主导节点"></a>Leading Peer - 主导节点</h3><p>Each <a href="https://hyperledgercn.github.io/hyperledgerDocs/glossary/#Member" target="_blank" rel="noopener">Member</a> can own multiple peers on each channel that it subscribes to. One of these peers is serves as the leading peer for the channel, in order to communicate with the network ordering service on behalf of the member. The ordering service “delivers” blocks to the leading peer(s) on a channel, who then distribute them to other peers within the same member cluster.</p>
<p>每一个Member在其订阅的channel上可以拥有多个peer，其中一个peer会作为channel的leading peer代表该Member与ordering service通信。ordering service将block传递给leading peer，该peer再将此block分发给同一member下的其他peer。</p>
<h3 id="Ledger-账本"><a href="#Ledger-账本" class="headerlink" title="Ledger - 账本"></a>Ledger - 账本</h3><p>A ledger is a channel’s chain and current state data which is maintained by each peer on the channel.</p>
<p>Ledger是个channel的chain和由channel中每个peer维护的world state。<em>（这个解释有点怪）</em></p>
<h3 id="Member-成员"><a href="#Member-成员" class="headerlink" title="Member - 成员"></a>Member - 成员</h3><p>A legally separate entity that owns a unique root certificate for the network. Network components such as peer nodes and application clients will be linked to a member.</p>
<p>拥有网络唯一根证书的合法独立实体。像peer节点和app client这样的网络组件会链接到一个Member。</p>
<h3 id="Membership-Service-Provider-MSP"><a href="#Membership-Service-Provider-MSP" class="headerlink" title="Membership Service Provider - MSP"></a>Membership Service Provider - MSP</h3><p>The Membership Service Provider (MSP) refers to an abstract component of the system that provides credentials to clients, and peers for them to participate in a Hyperledger Fabric network. Clients use these credentials to authenticate their transactions, and peers use these credentials to authenticate transaction processing results (endorsements). While strongly connected to the transaction processing components of the systems, this interface aims to have membership services components defined, in such a way that alternate implementations of this can be smoothly plugged in without modifying the core of transaction processing components of the system.</p>
<p>MSP是指为client和peer提供证书的系统抽象组件。Client用证书来认证他们的交易；peer用证书认证其交易背书。该接口与系统的交易处理组件密切相关，旨在使已定义的成员身份服务组件以这种方式顺利插入而不会修改系统的交易处理组件的核心。</p>
<h3 id="Membership-Services-成员服务"><a href="#Membership-Services-成员服务" class="headerlink" title="Membership Services - 成员服务"></a>Membership Services - 成员服务</h3><p>Membership Services authenticates, authorizes, and manages identities on a permissioned blockchain network. The membership services code that runs in peers and orderers both authenticates and authorizes blockchain operations. It is a PKI-based implementation of the Membership Services Provider (MSP) abstraction.</p>
<p>成员服务在许可的区块链网络上认证、授权和管理身份。在peer和order中运行的成员服务的代码都会认证和授权区块链操作。它是基于PKI的MSP实现。</p>
<p>The <code>fabric-ca</code> component is an implementation of membership services to manage identities. In particular, it handles the issuance and revocation of enrollment certificates and transaction certificates.</p>
<p><code>fabric-ca</code>组件实现了成员服务，来管理身份。特别的，它处理ECert和TCert的颁发和撤销。</p>
<p>An enrollment certificate is a long-term identity credential; a transaction certificate is a short-term identity credential which is both anonymous and un-linkable.</p>
<p>ECert是长期的身份凭证；TCert是短期的身份凭证，是匿名和不可链接的。</p>
<h3 id="Ordering-Service-排序服务或共识服务"><a href="#Ordering-Service-排序服务或共识服务" class="headerlink" title="Ordering Service - 排序服务或共识服务"></a>Ordering Service - 排序服务或共识服务</h3><p>A defined collective of nodes that orders transactions into a block. The ordering service exists independent of the peer processes and orders transactions on a first-come-first-serve basis for all channel’s on the network. The ordering service is designed to support pluggable implementations beyond the out-of-the-box SOLO and Kafka varieties. The ordering service is a common binding for the overall network; it contains the cryptographic identity material tied to each <a href="https://hyperledgercn.github.io/hyperledgerDocs/glossary/#Member" target="_blank" rel="noopener">Member</a>.</p>
<p>将交易排序放入block的节点的集合。ordering service独立于peer流程之外，并以先到先得的方式为网络上所有的channel作交易排序。ordering service支持可插拔实现，目前默认实现了SOLO和Kafka。ordering service是整个网络的公用binding，包含与每个Member相关的加密材料。</p>
<h3 id="Peer-节点"><a href="#Peer-节点" class="headerlink" title="Peer - 节点"></a>Peer - 节点</h3><p>A network entity that maintains a ledger and runs chaincode containers in order to perform read-write operations to the ledger. Peers are owned and maintained by members.</p>
<p>一个网络实体，维护ledger并运行Chaincode容器来对ledger执行read-write操作。peer由Member拥有和维护。</p>
<h3 id="Policy-策略"><a href="#Policy-策略" class="headerlink" title="Policy - 策略"></a>Policy - 策略</h3><p>There are policies for endorsement, validation, block committal, chaincode management and network-channel management.</p>
<p>有背书策略，校验策略，区块提交策略，Chaincode管理策略和网络-通道管理策略。</p>
<h3 id="Proposal-提案"><a href="#Proposal-提案" class="headerlink" title="Proposal - 提案"></a>Proposal - 提案</h3><p>A request for endorsement that is aimed at specific peers on a channel. Each proposal is either an instantiate or an invoke (read-write) request.</p>
<p>一种针对channel中某peer的背书请求。每个proposal要么是Chaincode instantiate要么是Chaincode invoke。</p>
<h3 id="Query-查询"><a href="#Query-查询" class="headerlink" title="Query - 查询"></a>Query - 查询</h3><p>A query requests the value of a key(s) against the current state.</p>
<p>对于current state中某个key的value的查询请求。</p>
<h3 id="Software-Development-Kit-SDK"><a href="#Software-Development-Kit-SDK" class="headerlink" title="Software Development Kit - SDK"></a>Software Development Kit - SDK</h3><p>The Hyperledger Fabric client SDK provides a structured environment of libraries for developers to write and test chaincode applications. The SDK is fully configurable and extensible through a standard interface. Components, including cryptographic algorithms for signatures, logging frameworks and state stores, are easily swapped in and out of the SDK. The SDK API uses protocol buffers over gRPC for transaction processing, membership services, node traversal and event handling applications to communicate across the fabric. The SDK comes in multiple flavors - Node.js, Java. and Python.</p>
<p>SDK为开发人员提供了一个结构化的库环境，用于编写和测试链码应用程序。SDK完全可以通过标准接口实现配置和扩展，像签名的加密算法、日志框架和state存储这样的组件都可以轻松地实现替换。SDK API使用gRPC进行交易处理，成员服务、节点遍历以及事件处理都是据此与fabric通信。目前SDK支持Node.js、Java和Python。</p>
<h3 id="State-Database-stateDB"><a href="#State-Database-stateDB" class="headerlink" title="State Database - stateDB"></a>State Database - stateDB</h3><p>Current state data is stored in a state database for efficient reads and queries from chaincode. These databases include levelDB and couchDB.</p>
<p>为了从Chaincode中高效的读写，Current state 数据存储在stateDB中，包括levelDB和couchDB。</p>
<h3 id="System-Chain-系统链"><a href="#System-Chain-系统链" class="headerlink" title="System Chain - 系统链"></a>System Chain - 系统链</h3><p>Contains a configuration block defining the network at a system level. The system chain lives within the ordering service, and similar to a channel, has an initial configuration containing information such as: MSP information, policies, and configuration details. Any change to the overall network (e.g. a new org joining or a new ordering node being added) will result in a new configuration block being added to the system chain.</p>
<p>包含在系统级定义网络的配置区块。系统链存在于ordering service中，与channel类似，具有包含以下信息的初始配置：MSP信息、策略和信息配置。对整个网络的任何变化（例如新的Org加入或者添加新的Ordering节点）将导致新的配置区块被添加到系统链。</p>
<p>The system chain can be thought of as the common binding for a channel or group of channels. For instance, a collection of financial institutions may form a consortium (represented through the system chain), and then proceed to create channels relative to their aligned and varying business agendas.</p>
<p>系统链可看做是一个channel或一组channel的公用binding。例如，金融机构的集合可以形成一个财团（以system chain表示），然后根据其相同或不同的业务创建channel。</p>
<h3 id="Transaction-交易"><a href="#Transaction-交易" class="headerlink" title="Transaction - 交易"></a>Transaction - 交易</h3><p>An invoke or instantiate operation. Invokes are requests to read-write data from the ledger. Instantiate is a request to start a chaincode container on a peer.</p>
<p>Chaincode的invoke或instantiate操作。Invoke是从ledger中请求read-write set；Instantiate是请求在peer上启动Chaincode容器。</p>
      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.jpg" alt="JackYu wechat" style="width: 200px; max-width: 100%">
    <div>欢迎您扫一扫上面的微信号，添加好友！</div>
</div>

      </div>
    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/区块链/" rel="tag"># 区块链</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/24/malloc/" rel="next" title="malloc、calloc、realloc的区别">
                <i class="fa fa-chevron-left"></i> malloc、calloc、realloc的区别
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="JackYu">
            
              <p class="site-author-name" itemprop="name">JackYu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhongjiu8888" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/2620164274/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>Weibo</a>
                  </span>
                
            </div>
          

		</div>
        
		<!--Music player-->
		<div>
			
				<!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=427142481&auto=1&height=66"></iframe> -->
				<!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=470699422&auto=1&height=66"></iframe> -->
				<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=463352828&auto=1&height=66"></iframe>
				
		</div>




          
          

          
          

          

        </section></div>
      

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Fabric"><span class="nav-number">1.</span> <span class="nav-text">Fabric</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区块链是什么"><span class="nav-number">1.2.</span> <span class="nav-text">区块链是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-分布式账本（A-Distributed-Ledger）"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.分布式账本（A Distributed Ledger）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-智能合约（Smart-Contracts）"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.智能合约（Smart Contracts）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-共识（Consensus）"><span class="nav-number">1.2.3.</span> <span class="nav-text">3.共识（Consensus）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fabric的特点"><span class="nav-number">1.3.</span> <span class="nav-text">Fabric的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#共享账本（Shared-Ledger）"><span class="nav-number">1.3.1.</span> <span class="nav-text">共享账本（Shared Ledger）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#智能合约（Smart-Contracts）"><span class="nav-number">1.3.2.</span> <span class="nav-text">智能合约（Smart Contracts）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私密性（Privacy）"><span class="nav-number">1.3.3.</span> <span class="nav-text">私密性（Privacy）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共识（Consensus）"><span class="nav-number">1.3.4.</span> <span class="nav-text">共识（Consensus）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fabric应用场景"><span class="nav-number">1.4.</span> <span class="nav-text">Fabric应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fabric参考手册"><span class="nav-number">1.5.</span> <span class="nav-text">Fabric参考手册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fabric的基本框架"><span class="nav-number">1.6.</span> <span class="nav-text">Fabric的基本框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fabric的基本逻辑架构"><span class="nav-number">1.7.</span> <span class="nav-text">Fabric的基本逻辑架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fabric共识模式"><span class="nav-number">1.8.</span> <span class="nav-text">Fabric共识模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fabric源码解析"><span class="nav-number">1.9.</span> <span class="nav-text">Fabric源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、整体结构"><span class="nav-number">1.9.1.</span> <span class="nav-text">一、整体结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、源代码"><span class="nav-number">1.9.2.</span> <span class="nav-text">二、源代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、核心过程"><span class="nav-number">1.9.3.</span> <span class="nav-text">三、核心过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-Chaincode启动过程"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">3.1 Chaincode启动过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Peer节点启动"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">3.2 Peer节点启动</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-1-Peer背书提案过程"><span class="nav-number">1.9.3.2.1.</span> <span class="nav-text">3.2.1 Peer背书提案过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3排序服务核心原理和工作过程"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">3.3排序服务核心原理和工作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1工作原理"><span class="nav-number">1.9.3.3.1.</span> <span class="nav-text">3.3.1工作原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4Orderer-节点启动过程"><span class="nav-number">1.9.3.4.</span> <span class="nav-text">3.4Orderer 节点启动过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-1-gRPC-服务结构初始化"><span class="nav-number">1.9.3.4.1.</span> <span class="nav-text">3.4.1 gRPC 服务结构初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-2-gRPC服务启动"><span class="nav-number">1.9.3.4.2.</span> <span class="nav-text">3.4.2 gRPC服务启动 </span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-Orderer-节点对排序后消息的处理过程"><span class="nav-number">1.9.3.5.</span> <span class="nav-text">3.5 Orderer 节点对排序后消息的处理过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-1-Fabric-相关消息的处理"><span class="nav-number">1.9.3.5.1.</span> <span class="nav-text">3.5.1 Fabric 相关消息的处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-2-普通交易消息"><span class="nav-number">1.9.3.5.2.</span> <span class="nav-text">3.5.2 普通交易消息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-3-配置交易消息"><span class="nav-number">1.9.3.5.3.</span> <span class="nav-text">3.5.3 配置交易消息</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-Orderer-节点-Broadcast-请求的处理"><span class="nav-number">1.9.3.6.</span> <span class="nav-text">3.6 Orderer 节点 Broadcast 请求的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-1-解析消息"><span class="nav-number">1.9.3.6.1.</span> <span class="nav-text">3.6.1 解析消息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-2-处理配置交易消息"><span class="nav-number">1.9.3.6.2.</span> <span class="nav-text">3.6.2 处理配置交易消息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-3-返回响应"><span class="nav-number">1.9.3.6.3.</span> <span class="nav-text">3.6.3 返回响应</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-Orderer-节点-Deliver-请求的处理"><span class="nav-number">1.9.3.7.</span> <span class="nav-text">3.7 Orderer 节点 Deliver 请求的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-1-解析消息"><span class="nav-number">1.9.3.7.1.</span> <span class="nav-text">3.7.1 解析消息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-2-检查合法性"><span class="nav-number">1.9.3.7.2.</span> <span class="nav-text">3.7.2 检查合法性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-3-发送区块"><span class="nav-number">1.9.3.7.3.</span> <span class="nav-text">3.7.3 发送区块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-4-返回响应"><span class="nav-number">1.9.3.7.4.</span> <span class="nav-text">3.7.4 返回响应</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-客户端执行创建通道"><span class="nav-number">1.9.3.8.</span> <span class="nav-text">3.8 客户端执行创建通道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-客户端执行加入通道"><span class="nav-number">1.9.3.9.</span> <span class="nav-text">3.9 客户端执行加入通道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-10-客户端执行链码安装"><span class="nav-number">1.9.3.10.</span> <span class="nav-text">3.10 客户端执行链码安装</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#链码安装过程"><span class="nav-number">1.9.3.10.1.</span> <span class="nav-text">链码安装过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-10-1-客户端封装安装消息"><span class="nav-number">1.9.3.10.2.</span> <span class="nav-text">3.10.1  客户端封装安装消息</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-11客户端执行链码实例化"><span class="nav-number">1.9.3.11.</span> <span class="nav-text">3.11客户端执行链码实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-12-客户端执行链码调用"><span class="nav-number">1.9.3.12.</span> <span class="nav-text">3.12 客户端执行链码调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-13-客户端执行链码查询"><span class="nav-number">1.9.3.13.</span> <span class="nav-text">3.13 客户端执行链码查询</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fabric词汇"><span class="nav-number">1.10.</span> <span class="nav-text">Fabric词汇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Anchor-Peer-锚节点"><span class="nav-number">1.10.1.</span> <span class="nav-text">Anchor Peer - 锚节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Block-区块"><span class="nav-number">1.10.2.</span> <span class="nav-text">Block - 区块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chain-链"><span class="nav-number">1.10.3.</span> <span class="nav-text">Chain - 链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chaincode-链码"><span class="nav-number">1.10.4.</span> <span class="nav-text">Chaincode - 链码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-通道"><span class="nav-number">1.10.5.</span> <span class="nav-text">Channel - 通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Commitment-提交"><span class="nav-number">1.10.6.</span> <span class="nav-text">Commitment - 提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consensus-共识"><span class="nav-number">1.10.7.</span> <span class="nav-text">Consensus - 共识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Current-State-当前状态"><span class="nav-number">1.10.8.</span> <span class="nav-text">Current State - 当前状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dynamic-Membership-动态成员"><span class="nav-number">1.10.9.</span> <span class="nav-text">Dynamic Membership - 动态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Endorsement-背书"><span class="nav-number">1.10.10.</span> <span class="nav-text">Endorsement - 背书</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Endorsement-policy-背书策略"><span class="nav-number">1.10.11.</span> <span class="nav-text">Endorsement policy - 背书策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fabric-ca"><span class="nav-number">1.10.12.</span> <span class="nav-text">Fabric-ca</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Genesis-Block-初始区块"><span class="nav-number">1.10.13.</span> <span class="nav-text">Genesis Block - 初始区块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gossip-Protocol-Gossip协议"><span class="nav-number">1.10.14.</span> <span class="nav-text">Gossip Protocol - Gossip协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Initialize-初始化"><span class="nav-number">1.10.15.</span> <span class="nav-text">Initialize - 初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Install-安装"><span class="nav-number">1.10.16.</span> <span class="nav-text">Install - 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Instantiate-实例化"><span class="nav-number">1.10.17.</span> <span class="nav-text">Instantiate - 实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Invoke-调用"><span class="nav-number">1.10.18.</span> <span class="nav-text">Invoke - 调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leading-Peer-主导节点"><span class="nav-number">1.10.19.</span> <span class="nav-text">Leading Peer - 主导节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ledger-账本"><span class="nav-number">1.10.20.</span> <span class="nav-text">Ledger - 账本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Member-成员"><span class="nav-number">1.10.21.</span> <span class="nav-text">Member - 成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Membership-Service-Provider-MSP"><span class="nav-number">1.10.22.</span> <span class="nav-text">Membership Service Provider - MSP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Membership-Services-成员服务"><span class="nav-number">1.10.23.</span> <span class="nav-text">Membership Services - 成员服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ordering-Service-排序服务或共识服务"><span class="nav-number">1.10.24.</span> <span class="nav-text">Ordering Service - 排序服务或共识服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Peer-节点"><span class="nav-number">1.10.25.</span> <span class="nav-text">Peer - 节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Policy-策略"><span class="nav-number">1.10.26.</span> <span class="nav-text">Policy - 策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proposal-提案"><span class="nav-number">1.10.27.</span> <span class="nav-text">Proposal - 提案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Query-查询"><span class="nav-number">1.10.28.</span> <span class="nav-text">Query - 查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Software-Development-Kit-SDK"><span class="nav-number">1.10.29.</span> <span class="nav-text">Software Development Kit - SDK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#State-Database-stateDB"><span class="nav-number">1.10.30.</span> <span class="nav-text">State Database - stateDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System-Chain-系统链"><span class="nav-number">1.10.31.</span> <span class="nav-text">System Chain - 系统链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transaction-交易"><span class="nav-number">1.10.32.</span> <span class="nav-text">Transaction - 交易</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </aside></div>
  


        
      </main></div>
    

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JackYu</span>

  
</div>


 <div class="powered-by">
 <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
 </span>
 </div>
<!-- <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> 



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>



-->
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共28.5k字</span>
</div>

        







        
      </div>
    </footer>

    

    

  

  <a href="https://github.com/yuhongjiu8888"><img style="position: absolute; top: 0; right: 0; border: 0" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>


  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  
  <script type="text/javascript" color="0,0,255" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>