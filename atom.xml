<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JackYu&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/7d6859529934feb0edca87907b1ce4e0</icon>
  <subtitle>Nothing is impossible!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-27T09:21:45.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JackYu</name>
    <email>1134735533@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++11新特性</title>
    <link href="http://yoursite.com/2018/12/27/c++11featrues/"/>
    <id>http://yoursite.com/2018/12/27/c++11featrues/</id>
    <published>2018-12-27T09:25:59.968Z</published>
    <updated>2018-12-27T09:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1.Lambda 表达式"></a>1.Lambda 表达式</h5><p>Lambda 表达式就是用于创建<strong>匿名函数</strong>的。<br>为什么说 lambda 表达式如此激动人心呢？举一个例子。标准 C++ 库中有一个常用算法的库，其中提供了很多算法函数，比如 sort() 和 find()。这些函数通常需要提供一个“谓词函数 predicate function”。所谓谓词函数，就是进行一个操作用的临时函数。比如 find() 需要一个谓词，用于查找元素满足的条件；能够满足谓词函数的元素才会被查找出来。<strong>这样的谓词函数，使用临时的匿名函数，既可以减少函数数量，又会让代码变得清晰易读。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;<span class="keyword">return</span>-type &#123;body&#125;</span><br></pre></td></tr></table></figure><p>最简单的例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> abssort(float *x, unsigned N)</span><br><span class="line">&#123;</span><br><span class="line">  std::sort(x,</span><br><span class="line">            x + N,</span><br><span class="line">            [](float a, float b) &#123; <span class="keyword">return</span> std::abs(a) &lt; std::abs(b); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要注意：</p><ol><li>返回值类型-&gt;return-type可以省略，由语言自动推导，但前提是只有当 lambda 表达式中的语句“足够简单”，才能自动推断返回值类型。</li><li>引入 lambda 表达式的前导符是一对方括号，称为 lambda 引入符（lambda-introducer）。lambda 表达式可以使用与其相同范围 scope 内的变量。这个引入符的作用就是表明，其后的 lambda 表达式以何种方式使用（正式的术语是“捕获”）这些变量（这些变量能够在 lambda 表达式中被捕获，其实就是构成了一个闭包）。</li><li>捕获类型可以以下类型：</li></ol><ul><li>[]  // 不捕获任何外部变量</li><li>[=] // 以值的形式捕获所有外部变量</li><li>[&amp;] // 以引用形式捕获所有外部变量</li><li>[x, &amp;y] // x 以传值形式捕获，y 以引用形式捕获</li><li>[=, &amp;z]// z 以引用形式捕获，其余变量以传值形式捕获</li><li>[&amp;, x] // x 以值的形式捕获，其余变量以引用形式捕获</li></ul><ol start="4"><li>对于[=]或[&amp;]的形式，lambda 表达式可以直接使用  this 指针 。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</li><li>对于下面的例子，[=]意味着，lambda 表达式以传值的形式捕获外部变量。C++ 11 标准说，如果以传值的形式捕获外部变量，那么，lambda 体不允许修改外部变量，对 f0 的任何修改都会引发编译错误。但是，注意在 lambda 表达式前声明了mutable关键字，这就允许了 lambda 表达式体修改 f0 的值。因此不会报错。但由于是传值的，虽然在 lambda 表达式中对 f0 有了修改，但由于是传值的，外部的 f0 依然不会被修改。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float f0 = <span class="number">1.0</span>;</span><br><span class="line">std::cout &lt;&lt; [=](float f) mutable &#123; <span class="keyword">return</span> f0 += std::abs(f); &#125; (<span class="number">-3.5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">'\n'</span> &lt;&lt; f0 &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>– 混合机制的实例如下（f0 通过引用被捕获，而其它变量，比如 f1 则是通过值被捕获）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float f0 = <span class="number">1.0</span>f;</span><br><span class="line">float f1 = <span class="number">10.0</span>f;</span><br><span class="line">std::cout &lt;&lt; [=, &amp;f0](float a) &#123; <span class="keyword">return</span> f0 += f1 + std::abs(a); &#125; (<span class="number">-3.5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">'\n'</span> &lt;&lt; f0 &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p><strong>C++引入Lambda的最主要原因:</strong><br>1）可以定义匿名函数；<br>2）<strong>编译器会把其转成函数对象</strong>；为什么以前STL中的ptr_fun()这个函数对象不能用？（ptr_fun()就是把一个自然函数转成函数对象的）原因是，ptr_fun() 的局限是其接收的自然函数只能有1或2个参数。<br>3）”闭包”，限制了别人的访问，更私有；</p><h5 id="2-自动类型推导和-decltype"><a href="#2-自动类型推导和-decltype" class="headerlink" title="2.自动类型推导和 decltype"></a>2.自动类型推导和 decltype</h5><p>在 C++03 中，声明对象的同时必须指明其类型，其实大多数情况下，声明对象的同时也会包括一个初始值，C++11 在这种情况下就能够让你声明对象时不再指定类型了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto x = <span class="number">0</span>; <span class="comment">//0 是 int 类型，所以 x 也是 int 类型  </span></span><br><span class="line">auto c = <span class="string">'a'</span>; <span class="comment">//char  </span></span><br><span class="line">auto d = <span class="number">0.5</span>; <span class="comment">//double  </span></span><br><span class="line">auto national_debt = <span class="number">14400000000000</span>LL;<span class="comment">//long long</span></span><br></pre></td></tr></table></figure><p>这个特性在对象的类型很大很长的时候很有用，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">void</span> func(<span class="keyword">const</span> vector&lt;int&gt; &amp;vi)  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="comment">//vector&lt;int&gt;::const_iterator ci=vi.begin(); </span></span><br><span class="line">  auto ci=vi.begin();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++11 也提供了从对象或表达式中“俘获”类型的机制，新的操作符 decltype 可以从一个表达式中“俘获”其结果的类型并“返回”：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vector&lt;int&gt; vi;  </span><br><span class="line">typedef decltype (vi.begin()) CIT;  </span><br><span class="line">CIT another_const_iterator;</span><br></pre></td></tr></table></figure><p><strong>注意： auto作为函数返回值时，只能用于定义函数，不能用于声明函数</strong></p><h5 id="3-统一的初始化语法"><a href="#3-统一的初始化语法" class="headerlink" title="3.统一的初始化语法"></a>3.统一的初始化语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//括号内初始化</span></span><br><span class="line">std::string s(<span class="string">"hello"</span>);  </span><br><span class="line">int m=int(); <span class="comment">//default initialization </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//等号形式的</span></span><br><span class="line">std::string s=<span class="string">"hello"</span>;  </span><br><span class="line">int x=<span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对于 POD 集合，又可以用大括号</span></span><br><span class="line">int arr[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  </span><br><span class="line">struct tm today=&#123;<span class="number">0</span>&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//最后还有构造函数的成员初始化：</span></span><br><span class="line">struct S &#123;  </span><br><span class="line"> int x;  </span><br><span class="line"> S(): x(<span class="number">0</span>) &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure><p>C++11 就用大括号一统天下了!<br>对于容器来说，终于可以摆脱 push_back() 调用了，C++11中可以直观地初始化容器了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 container initializer  </span></span><br><span class="line">vector vs&lt;string&gt;=&#123; <span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"third"</span>&#125;;  </span><br><span class="line">map singers =  </span><br><span class="line">  &#123; &#123;<span class="string">"Lady Gaga"</span>, <span class="string">"+1 (212) 555-7890"</span>&#125;,  </span><br><span class="line">    &#123;<span class="string">"Beyonce Knowles"</span>, <span class="string">"+1 (212) 555-0987"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>而类中的数据成员初始化也得到了支持：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">  int a=<span class="number">7</span>; <span class="comment">//C++11 only  </span></span><br><span class="line">public:  </span><br><span class="line">  C();  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-deleted-函数和-defaulted-函数"><a href="#4-deleted-函数和-defaulted-函数" class="headerlink" title="4.deleted 函数和 defaulted 函数"></a>4.deleted 函数和 defaulted 函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct A  </span><br><span class="line">&#123;  </span><br><span class="line">    A()=<span class="keyword">default</span>; <span class="comment">//C++11  </span></span><br><span class="line">    virtual ~A()=<span class="keyword">default</span>; <span class="comment">//C++11  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>=default; 指示编译器生成该函数的默认实现。这有两个好处：一是让程序员轻松了，少敲键盘，二是有更好的性能。<br>与 defaulted 函数相对的就是 deleted 函数, 实现 non copy-able 防止对象拷贝，要想禁止拷贝，用 =deleted 声明一下两个关键的成员函数就可以了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int func()=<span class="keyword">delete</span>;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//防止对象拷贝的实现</span></span><br><span class="line">struct NoCopy  </span><br><span class="line">&#123;  </span><br><span class="line">    NoCopy &amp; operator =(<span class="keyword">const</span> NoCopy &amp;) = <span class="keyword">delete</span>;  </span><br><span class="line">    NoCopy(<span class="keyword">const</span> NoCopy &amp;) = <span class="keyword">delete</span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">NoCopy a;  </span><br><span class="line">NoCopy b(a); <span class="comment">//编译错误，拷贝构造函数是 deleted 函数</span></span><br></pre></td></tr></table></figure><h5 id="5-nullptr"><a href="#5-nullptr" class="headerlink" title="5.nullptr"></a>5.nullptr</h5><p>nullptr 是一个新的 C++ 关键字，它是空指针常量，它是用来替代高风险的 NULL 宏和 0 字面量的。nullptr 是强类型的,所有跟指针有关的地方都可以用 nullptr，包括函数指针和成员指针：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> f(int); <span class="comment">//#1  </span></span><br><span class="line"><span class="keyword">void</span> f(char *);<span class="comment">//#2  </span></span><br><span class="line"><span class="comment">//C++03  </span></span><br><span class="line">f(<span class="number">0</span>); <span class="comment">//调用的是哪个 f?  </span></span><br><span class="line"><span class="comment">//C++11  </span></span><br><span class="line">f(nullptr) <span class="comment">//毫无疑问，调用的是 #2  </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> char *pc=str.c_str(); <span class="comment">//data pointers  </span></span><br><span class="line"><span class="keyword">if</span> (pc != nullptr)  </span><br><span class="line">  cout &lt;&lt; pc &lt;&lt; endl;  </span><br><span class="line">int (A::*pmf)()=nullptr; <span class="comment">//指向成员函数的指针  </span></span><br><span class="line"><span class="keyword">void</span> (*pmf)()=nullptr; <span class="comment">//指向函数的指针</span></span><br></pre></td></tr></table></figure><h5 id="6-右值引用"><a href="#6-右值引用" class="headerlink" title="6.右值引用"></a>6.右值引用</h5><p>在 C++03 中的引用类型是只绑定左值的，C++11 引用一个新的引用类型叫右值引用类型，它是绑定到右值的，如临时对象或字面量。<br>增加右值引用的主要原因是为了<strong>实现 move 语义</strong>。与传统的拷贝不同，move 的意思是目标对象“窃取”原对象的资源，并将源置于“空”状态。当拷贝一个对象时，其实代价昂贵且无必要，move 操作就可以替代它。如在 string 交换的时候，使用 move 意义就有巨大的性能提升，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原方案很慢，因为需要申请内存，然后拷贝字符；</span></span><br><span class="line">[cpp] view plain copy</span><br><span class="line"><span class="keyword">void</span> naiveswap(string &amp;a, string &amp; b)  </span><br><span class="line">&#123;  </span><br><span class="line">    string temp = a;  </span><br><span class="line">    a=b;  </span><br><span class="line">    b=temp;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用move就只需要交换两个数据成员，无须申请、释放内存和拷贝字符数组；</span></span><br><span class="line"><span class="keyword">void</span> moveswapstr(string&amp; empty, string &amp; filled)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//pseudo code, but you get the idea  </span></span><br><span class="line">    size_t sz=empty.size();  </span><br><span class="line">    <span class="keyword">const</span> char *p= empty.data();  </span><br><span class="line">    <span class="comment">//move filled's resources to empty  </span></span><br><span class="line">    empty.setsize(filled.size());  </span><br><span class="line">    empty.setdata(filled.data());  </span><br><span class="line">    <span class="comment">//filled becomes empty  </span></span><br><span class="line">    filled.setsize(sz);  </span><br><span class="line">    filled.setdata(p);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现支持 move 的类，需要声明 move 构造函数和 move 赋值操作符，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    Movable (Movable&amp;&amp;); <span class="comment">//move constructor  </span></span><br><span class="line">    Movable&amp;&amp; operator=(Movable&amp;&amp;); <span class="comment">//move assignment operator  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="C-11-的标准库"><a href="#C-11-的标准库" class="headerlink" title="C++11 的标准库"></a>C++11 的标准库</h5><p>线程库、新的智能指针类、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-Lambda-表达式&quot;&gt;&lt;a href=&quot;#1-Lambda-表达式&quot; class=&quot;headerlink&quot; title=&quot;1.Lambda 表达式&quot;&gt;&lt;/a&gt;1.Lambda 表达式&lt;/h5&gt;&lt;p&gt;Lambda 表达式就是用于创建&lt;strong&gt;匿名函数&lt;/
      
    
    </summary>
    
    
      <category term="技术 编程语言 C++11" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C-11/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="http://yoursite.com/2018/12/27/docker/"/>
    <id>http://yoursite.com/2018/12/27/docker/</id>
    <published>2018-12-27T02:50:02.862Z</published>
    <updated>2018-12-27T02:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="docker是什么？"><a href="#docker是什么？" class="headerlink" title="docker是什么？"></a>docker是什么？</h5><p>docker是一个开源的容器引擎，它基于LCX容器技术，使用Go语言开发。<br>源代码托管在Github上，并遵从Apache2.0协议。<br>Docker采用C/S架构，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。</p><p>简单来说：Docker就是一种快速解决生产问题的一种技术手段。<br>简单点：Docker就是对容器进行操作管理的工具</p><h5 id="docker优缺点"><a href="#docker优缺点" class="headerlink" title="docker优缺点"></a>docker优缺点</h5><p><strong>优点：</strong><br>多：    适用场景多<br>快：    环境部署快、更新快<br>好：    好多人在用<br>省：    省钱省力省人工</p><p><strong>缺点：</strong><br>太腻歪人：  依赖操作系统<br>不善沟通：  依赖网络<br>不善理财：  银行U盾等场景不能用</p><h5 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h5><p>搜索 ： docker search 【image_name】<br>获取 ： docker pull 【image_name】<br>查看 ： docker image 【image_name】<br>docker image -a 列出本地的image（包括已删除的镜像记录）<br>镜像重命名： docker tag [old_name]:[old_version]  [new_name]:[new_verdion]<br>删除镜像：docker rmi [image_id]<br>导出镜像：（将已下载好的镜像，导出到本地）<br>                docker save  -o [导出镜像名称]   [本地镜像]<br>                例：docker save -o nginx.tar nginx</p><p>导入镜像： docker load  &lt; [image.tar_name]</p><h5 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h5><p>查看容器： docker ps<br>启动容器三种方式：</p><ol><li><p>基于镜像新建一个容器并启动<br>docker  run  &lt;参数，可选&gt;   [docker_image]  [执行命令]<br><strong>docker run 其实是两个命令的结合体docker create + docker start</strong></p></li><li><p>将关闭的容器重新启动<br>docker  start   [container_id]</p></li><li><p>守护进程方式启动(常用方式)<br>docker  run  -d  [image_name]   command…<br>例：docker run  -d nginx</p></li></ol><p>关闭容器： docker stop  [container_id]</p><p>删除容器的三种方式：<br>1.正常删除- - -删除已关闭的<br>docker  rm [container_id]</p><p>2.强制删除- - - 删除正在运行的<br>docker rm  -f  [container_id]</p><p>3.强制批量删除- - - 删除全部容器<br>docker rm  -f $(docker ps -a -q)</p><p>进入容器三种方法：<br>1.创建容器的同事并且进入容器<br>docker  run  –name  [container_name] -it [docker_image]  /bin/bash</p><p>2.手工方式进入容器<br>docker exec -it  容器id   /bin/bash</p><p>3.生产方式进入容器<br> 我们生产中常用的进入容器方法是使用脚本，脚本内容如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"># 定义进入仓库函数</span><br><span class="line">docker_in()&#123;</span><br><span class="line">  NAME_ID=$<span class="number">1</span></span><br><span class="line">  PID=$(docker inspect --format &#123;&#123;.State.Pid&#125;&#125; $NAME_ID)</span><br><span class="line">  nsenter --target $PID --mount --uts --ipc --net --pid</span><br><span class="line">&#125;</span><br><span class="line">docker_in $<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;docker是什么？&quot;&gt;&lt;a href=&quot;#docker是什么？&quot; class=&quot;headerlink&quot; title=&quot;docker是什么？&quot;&gt;&lt;/a&gt;docker是什么？&lt;/h5&gt;&lt;p&gt;docker是一个开源的容器引擎，它基于LCX容器技术，使用Go语言开发。&lt;
      
    
    </summary>
    
    
      <category term="技术 容器" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>IO阻塞与非阻塞一篇就够了</title>
    <link href="http://yoursite.com/2018/12/27/io_sync/"/>
    <id>http://yoursite.com/2018/12/27/io_sync/</id>
    <published>2018-12-27T02:49:55.298Z</published>
    <updated>2018-12-27T01:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么叫IO"><a href="#什么叫IO" class="headerlink" title="什么叫IO"></a>什么叫IO</h5><p>io通常是指计算机系统输入和输出的称呼，包括设备（键盘鼠标显示器）、总线、磁盘读写、内存等都称之为IO。</p><h5 id="IO阻塞与非阻塞"><a href="#IO阻塞与非阻塞" class="headerlink" title="IO阻塞与非阻塞"></a>IO阻塞与非阻塞</h5><p>阻塞（block）：用户态进程切换至内核态进程（read，write，accept等API函数系统调用），用户态进程一直处于挂起状态，直至内核态返回，继续工作。</p><p>非阻塞（nonblock）:用户态进程切换至内核态进程（read，write，accept等API函数系统调用），内核态进程会立马返回数据或状态码给用户态进程，用户态进程无需处于挂起状态，一直处于忙碌状态。</p><h5 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h5><p>同步（synchronous）:一个服务进行数据请求时，服务方立马告知请求结果，若数据不满足，请求方会再次主动发送请求到服务方，直至请求方得到满意的回复。（期望的结果）</p><p>异步（asynchronous）：客户向服务方请求，服务方也会立马回复请求方，不同的是，客户请求方只留下一个回调函数，用来让服务方等待条件满足后，主动通知客户方最终结果。（此方式客户方只请求了一次服务方）</p><ul><li>阻塞、非阻塞和同步异步是两个不同的概念。 </li><li>同步与异步最大的差异是对待结果的返回方式不一样。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;什么叫IO&quot;&gt;&lt;a href=&quot;#什么叫IO&quot; class=&quot;headerlink&quot; title=&quot;什么叫IO&quot;&gt;&lt;/a&gt;什么叫IO&lt;/h5&gt;&lt;p&gt;io通常是指计算机系统输入和输出的称呼，包括设备（键盘鼠标显示器）、总线、磁盘读写、内存等都称之为IO。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="技术 linux" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-linux/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2018/12/26/threadpool/"/>
    <id>http://yoursite.com/2018/12/26/threadpool/</id>
    <published>2018-12-26T14:13:35.349Z</published>
    <updated>2018-12-26T14:13:35.345Z</updated>
    
    <content type="html"><![CDATA[<h5 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h5><p>在那些情况下我们会使用到多线程：</p><p>1.阻塞调用（阻塞IO调用、等待资源）<br>2.耗时的计算（读写文件、复杂的计算）<br>3.高密度任务（高并发低延时的网络IO请求）<br>面临以上情况时都去临时创建线程会带来什么问题：</p><p>1.创建了太多的线程，系统资源就会被浪费，而且会浪费时间去创建和销毁线程。<br>2.创建线程太慢，导致执行任务结果返回过慢。<br>3.销毁线程太慢，可能会影响别的进程使用资源。<br>所以：创建多个线程，放在池子里不销毁，要用的时候就把任务丢给池子里的线程去执行，这就是线程池。<br>OK，问题来了任务由谁产生（生产者），如何丢给线程池的某个线程（消费者）？这个问题的回答需从以下几方面：</p><p>1） 生产者采用什么方式与消费者同步？<br>2） 任务如何保存？<br>3） 生产者之间的同步方式，消费者之间的同步方式？</p><p>一下所有的代码设计适用于单生产者多消费者模式</p><h5 id="条件变量结合互斥锁-任务队列"><a href="#条件变量结合互斥锁-任务队列" class="headerlink" title="条件变量结合互斥锁 + 任务队列"></a>条件变量结合互斥锁 + 任务队列</h5><p>设计如何：</p><p><img src="https://github.com/zhiyong0804/f-threadpool/blob/master/cond_mutex.png?raw=true" alt="enter description here"></p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">typedef struct queue_task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* (*run)(<span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">void</span>* argv;</span><br><span class="line">&#125;task_t;</span><br><span class="line"></span><br><span class="line">typedef struct queue</span><br><span class="line">&#123;</span><br><span class="line">    int      head;</span><br><span class="line">    int      tail;</span><br><span class="line">    int      size;</span><br><span class="line">    int      capcity;</span><br><span class="line">    task_t*  tasks;</span><br><span class="line">&#125; queue_t;</span><br><span class="line"></span><br><span class="line">typedef struct async_queue</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_t  mutex;</span><br><span class="line">    pthread_cond_t   cond;</span><br><span class="line">    int              waiting_threads;</span><br><span class="line"></span><br><span class="line">    queue_t*         queue;</span><br><span class="line">    int              quit;   <span class="comment">// 0 表示不退出  1 表示退出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调试变量 */</span></span><br><span class="line">    long long        tasked;  <span class="comment">// 已经处理完的任务数量</span></span><br><span class="line">&#125; async_queue_t;</span><br></pre></td></tr></table></figure><p>取任务的代码设计如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">task_t* async_cond_queue_pop_head(async_queue_t* q, int timeout)</span><br><span class="line">&#123;</span><br><span class="line">    task_t *task = NULL;</span><br><span class="line">    struct timeval now;</span><br><span class="line">    struct timespec outtime;</span><br><span class="line">    pthread_mutex_lock(&amp;(q-&gt;mutex));</span><br><span class="line">    <span class="keyword">if</span> (queue_is_empty(q-&gt;queue))</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;waiting_threads++;</span><br><span class="line">        <span class="keyword">while</span> (queue_is_empty(q-&gt;queue) &amp;&amp; (q-&gt;quit == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            gettimeofday(&amp;now, NULL);</span><br><span class="line">            <span class="keyword">if</span> (now.tv_usec + timeout &gt; <span class="number">1000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                outtime.tv_sec = now.tv_sec + <span class="number">1</span>;</span><br><span class="line">                outtime.tv_nsec = ((now.tv_usec + timeout) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                outtime.tv_sec = now.tv_sec;</span><br><span class="line">                outtime.tv_nsec = (now.tv_usec + timeout) * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_cond_timedwait(&amp;(q-&gt;cond), &amp;(q-&gt;mutex), &amp;outtime);</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;waiting_threads--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task = queue_pop_head(q-&gt;queue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调试代码 */</span></span><br><span class="line">    <span class="keyword">if</span> (task)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;tasked ++;</span><br><span class="line">        <span class="keyword">static</span> long long precision = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> ((q-&gt;tasked % precision ) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            time_t current_stm = get_current_timestamp();</span><br><span class="line">            precision *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;(q-&gt;mutex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情见：<a href="https://github.com/zhiyong0804/f-threadpool/blob/master/async_cond_queue.c" target="_blank" rel="noopener">https://github.com/zhiyong0804/f-threadpool/blob/master/async_cond_queue.c</a></p><p>不足：</p><p>因为Mutex引起线程挂起和唤醒的操作，在IO密集型的服务器上不是特别高效（实测过）；<br>条件变量必须和互斥锁相结合使用，使用起来较麻烦；<br>条件变量不能像eventfd一样为I/O事件驱动。<br>管道可以和I/O复用很好的融合，但是管道比eventfd多用了一个文件描述符，而且管道内核还得给其管理的缓冲区，eventfd则不需要，因此eventfd比起管道要高效。</p><h5 id="eventfd-epoll"><a href="#eventfd-epoll" class="headerlink" title="eventfd + epoll"></a>eventfd + epoll</h5><p>队列的设计：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct async_queue</span><br><span class="line">&#123;</span><br><span class="line">    queue_t*         queue;</span><br><span class="line">    int              quit;   <span class="comment">// 0 表示不退出  1 表示退出</span></span><br><span class="line"></span><br><span class="line">    int              efd;     <span class="comment">//event fd,</span></span><br><span class="line">    int              epollfd; <span class="comment">// epoll fd</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调试变量 */</span></span><br><span class="line">    long long        tasked;  <span class="comment">// 已经处理完的任务数量</span></span><br><span class="line">&#125; async_queue_t;</span><br></pre></td></tr></table></figure><p>插入任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BOOL async_eventfd_queue_push_tail(async_queue_t* q, task_t *task)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long long i = <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">if</span> (!queue_is_full(q-&gt;queue))</span><br><span class="line">    &#123;</span><br><span class="line">        queue_push_tail(q-&gt;queue, task);</span><br><span class="line"></span><br><span class="line">        struct epoll_event ev;</span><br><span class="line">        int efd = eventfd(<span class="number">0</span>, EFD_CLOEXEC | EFD_NONBLOCK);</span><br><span class="line">        <span class="keyword">if</span> (efd == <span class="number">-1</span>) printf(<span class="string">"eventfd create: %s"</span>, strerror(errno));</span><br><span class="line">        ev.events = EPOLLIN ;<span class="comment">// | EPOLLLT;</span></span><br><span class="line">        ev.data.fd = efd;</span><br><span class="line">        <span class="keyword">if</span> (epoll_ctl(q-&gt;epollfd, EPOLL_CTL_ADD, efd, &amp;ev) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> NULL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(efd, &amp;i, sizeof (i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">task_t* async_eventfd_queue_pop_head(async_queue_t* q, int timeout)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long long i = <span class="number">0</span>;</span><br><span class="line">    struct epoll_event events[MAX_EVENTS];</span><br><span class="line">    int nfds = epoll_wait(q-&gt;epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        read(events[<span class="number">0</span>].data.fd, &amp;i, sizeof (i));</span><br><span class="line">        close(events[<span class="number">0</span>].data.fd); <span class="comment">// <span class="doctag">NOTE:</span> need to close here</span></span><br><span class="line">        task_t* task = queue_pop_head(q-&gt;queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 调试代码 */</span></span><br><span class="line">        <span class="keyword">if</span> (task)</span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;tasked ++;</span><br><span class="line">            <span class="keyword">static</span> long long precision = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> ((q-&gt;tasked % precision ) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                time_t current_stm = get_current_timestamp();</span><br><span class="line">                printf(<span class="string">"%d tasks cost : %d\n"</span>, precision, current_stm - start_stm);</span><br><span class="line">                precision *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为eventfd每次写数据后，只会唤醒一个epoll_wait所在的线程，so，确保了同一时刻仅有一个线程取任务。<br>代码详情：<a href="https://github.com/zhiyong0804/f-threadpool/blob/master/async_eventfd_queue.c" target="_blank" rel="noopener">https://github.com/zhiyong0804/f-threadpool/blob/master/async_eventfd_queue.c</a></p><p>不足：<br>上面两种方案，所有的线程共用同一个队列，所以消费者线程之间取任务时需要做同步，生产者和消费者也需要做同步。用一个形象的图可以表示如下：<br><img src="https://github.com/zhiyong0804/f-threadpool/blob/master/fuck.png?raw=true" alt="enter description here"></p><h5 id="eventfd-epoll-多队列的设计"><a href="#eventfd-epoll-多队列的设计" class="headerlink" title="eventfd + epoll + 多队列的设计"></a>eventfd + epoll + 多队列的设计</h5><p>设计思想如下图：<br><img src="https://github.com/zhiyong0804/f-threadpool/blob/master/multiple.png?raw=true" alt="enter description here"></p><p>代码详情见：<a href="https://github.com/zhiyong0804/StreamingServer" target="_blank" rel="noopener">https://github.com/zhiyong0804/StreamingServer</a><br>Oh my god, huge project, where can i find thre thread pool source. 说来话长，这个代码是EasyDarwin的源码，但是因为某种原因，EasyDarwin的源码不再共享，取而代之的打赏的二维码，so， 我把他们的源码做了局部的修改，然后重新提交，且命名为StreamingServer，里面的设计是采用条件变量做同步的，但是多队列的思想是可以沿袭的，打算加班用eventfd实现。</p><p>这样一种设计是不是让我们能够想到下面这幅图呢？<br><img src="https://github.com/zhiyong0804/f-threadpool/blob/master/lijiao.jpg?raw=true" alt="enter description here"></p><p>之前所有的道路遇到十字路口时（共享了资源），只能使用信号灯去同步汽车的行驶，现如今，把共享资源fuck掉了，用立交桥，爽吧！！！？</p><p>并行编程是很难的，可以参考以下这篇论文:</p><p>并发编程的11个问题英文版：<a href="http://www.it610.com/article/4462577.htm" target="_blank" rel="noopener">http://www.it610.com/article/4462577.htm</a><br>并发编程的11个问题中文版：<a href="https://blog.csdn.net/mergerly/article/details/39028861" target="_blank" rel="noopener">https://blog.csdn.net/mergerly/article/details/39028861</a><br>我也并不聪明，可是当我2年前接触到ZeroMQ这个项目时，我特别惊叹于Pieter Hintjens的一些观点，“真正的并发就是不共享资源”</p><p>so，方案四的设计</p><h5 id="Lock-free"><a href="#Lock-free" class="headerlink" title="Lock-free"></a>Lock-free</h5><p>当我们在第三种方案上，增加了多队列，即每线程每队列时，实际上我们的队列设计变成了一个单生产者单消费者共享的队列，但是这个队列的写指针（tail）仅会被生产者使用，读指针（head）仅会被消费者使用，实际上没有共享任何资源，当然queue_t的size变量，我正在重构把它拿掉。</p><p><strong>OK，那么在这种设计下，消费者线程如何“等待”如何“取”任务？</strong></p><p>实际上，上面的三种方案对于消费者线程都是被动等待通知，收到通知则去取任务，实际上，我们完全可以设计成“轮询”的方案，就是不停地看自己的任务队列里是否有任务，没有就循环一次，中间当然可以加上sched_yield操作，让其它的线程能够得到调度。</p><h5 id="线程池的尺寸设计多大合适？"><a href="#线程池的尺寸设计多大合适？" class="headerlink" title="线程池的尺寸设计多大合适？"></a>线程池的尺寸设计多大合适？</h5><p>CPU密集型的：<br>thread size = N + 1;<br>IO密集型的：<br>thread size = 2*N + 1;</p><p>当然这不是绝对的，所以在mariadb的线程池是可以动态调整这个尺寸的。</p><p>——————————————全文完—————————————————–</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;为什么需要线程池&quot;&gt;&lt;a href=&quot;#为什么需要线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么需要线程池&quot;&gt;&lt;/a&gt;为什么需要线程池&lt;/h5&gt;&lt;p&gt;在那些情况下我们会使用到多线程：&lt;/p&gt;
&lt;p&gt;1.阻塞调用（阻塞IO调用、等待资源）&lt;br
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Mutex的实现原理</title>
    <link href="http://yoursite.com/2018/12/26/mutex/"/>
    <id>http://yoursite.com/2018/12/26/mutex/</id>
    <published>2018-12-26T13:34:02.511Z</published>
    <updated>2018-12-26T13:31:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>互斥锁主要用于实现内核中的互斥访问功能。内核互斥锁是在原子 API 之上实现的，但这对于内核用户是不可见的。对它的访问必须遵循一些规则：同一时间只能有一个任务持有互斥锁，而且只有这个任务可以对互斥锁进行解锁。互斥锁不能进行递归锁定或解锁。一个互斥锁对象必须通过其API初始化，而不能使用memset或复制初始化。一个任务在持有互斥锁的时候是不能结束的。互斥锁所使用的内存区域是不能被释放的。使用中的互斥锁是不能被重新初始化的。并且互斥锁不能用于中断上下文。但是互斥锁比当前的内核信号量选项更快，并且更加紧凑，因此如果它们满足您的需求，那么它们将是您明智的选择。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.15</span> kernel</span><br><span class="line">include/linux/mutex.h</span><br><span class="line">struct mutex &#123;</span><br><span class="line">atomic_long_towner;</span><br><span class="line">spinlock_twait_lock;</span><br><span class="line">#ifdef CONFIG_MUTEX_SPIN_ON_OWNER</span><br><span class="line">struct optimistic_spin_queue osq; <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line">#endif</span><br><span class="line">struct list_headwait_list;</span><br><span class="line">#ifdef CONFIG_DEBUG_MUTEXES</span><br><span class="line"><span class="keyword">void</span>*magic;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="line">struct lockdep_mapdep_map;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1.owner<br>锁的持有者, 如果没有task持有则为0，否则是获取到锁的pid。<br>2.wait_lock<br>自旋锁，内核用来保护代码执行区的。<br>3.wait_list<br>等待队列，是一个链表，如果task没有获取owner == 0，则把task加入到这个等待队列，并且将进程设置为TASK_UNINTERRUPTIBLE状态，直到被wakeup调用唤醒执行。</p><h3 id="mutex-lock"><a href="#mutex-lock" class="headerlink" title="mutex_lock"></a>mutex_lock</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux/kener/locking/mutex.c:252</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mutex_lock - acquire the mutex</span></span><br><span class="line"><span class="comment"> * @lock: the mutex to be acquired</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Lock the mutex exclusively for this task. If the mutex is not</span></span><br><span class="line"><span class="comment"> * available right now, it will sleep until it can get it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The mutex must later on be released by the same task that</span></span><br><span class="line"><span class="comment"> * acquired it. Recursive locking is not allowed. The task</span></span><br><span class="line"><span class="comment"> * may not exit without first unlocking the mutex. Also, kernel</span></span><br><span class="line"><span class="comment"> * memory where the mutex resides must not be freed with</span></span><br><span class="line"><span class="comment"> * the mutex still locked. The mutex must first be initialized</span></span><br><span class="line"><span class="comment"> * (or statically defined) before it can be locked. memset()-ing</span></span><br><span class="line"><span class="comment"> * the mutex to 0 is not allowed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (The CONFIG_DEBUG_MUTEXES .config option turns on debugging</span></span><br><span class="line"><span class="comment"> * checks that will enforce the restrictions and will also do</span></span><br><span class="line"><span class="comment"> * deadlock debugging)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is similar to (but not equivalent to) down().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __sched mutex_lock(struct mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!__mutex_trylock_fast(lock))</span><br><span class="line">__mutex_lock_slowpath(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline bool __mutex_trylock_fast(struct mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long curr = (unsigned long)current;</span><br><span class="line">unsigned long zero = <span class="number">0</span>UL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (atomic_long_try_cmpxchg_acquire(&amp;lock-&gt;owner, &amp;zero, curr))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lock a mutex (possibly interruptible), slowpath:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline int __sched</span><br><span class="line">__mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,</span><br><span class="line">    struct lockdep_map *nest_lock, unsigned long ip,</span><br><span class="line">    struct ww_acquire_ctx *ww_ctx, <span class="keyword">const</span> bool use_ww_ctx)</span><br><span class="line">&#123;</span><br><span class="line">struct mutex_waiter waiter;</span><br><span class="line">bool first = <span class="literal">false</span>;</span><br><span class="line">struct ww_mutex *ww;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line">ww = container_of(lock, struct ww_mutex, base);</span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx) &#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(ww_ctx == READ_ONCE(ww-&gt;ctx)))</span><br><span class="line"><span class="keyword">return</span> -EALREADY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reset the wounded flag after a kill. No other process can</span></span><br><span class="line"><span class="comment"> * race and wound us here since they can't have a valid owner</span></span><br><span class="line"><span class="comment"> * pointer if we don't have any locks held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ww_ctx-&gt;acquired == <span class="number">0</span>)</span><br><span class="line">ww_ctx-&gt;wounded = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preempt_disable();</span><br><span class="line">mutex_acquire_nest(&amp;lock-&gt;dep_map, subclass, <span class="number">0</span>, nest_lock, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock) ||</span><br><span class="line">    mutex_optimistic_spin(lock, ww_ctx, use_ww_ctx, NULL)) &#123;</span><br><span class="line"><span class="comment">/* got the lock, yay! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx)</span><br><span class="line">ww_mutex_set_context_fastpath(ww, ww_ctx);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * After waiting to acquire the wait_lock, try again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock)) &#123;</span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx)</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line"></span><br><span class="line">goto skip_wait;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug_mutex_lock_common(lock, &amp;waiter);</span><br><span class="line"></span><br><span class="line">lock_contended(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!use_ww_ctx) &#123;</span><br><span class="line"><span class="comment">/* add waiting tasks to the end of the waitqueue (FIFO): */</span></span><br><span class="line">__mutex_add_waiter(lock, &amp;waiter, &amp;lock-&gt;wait_list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEBUG_MUTEXES</span><br><span class="line">waiter.ww_ctx = MUTEX_POISON_WW_CTX;</span><br><span class="line">#endif</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add in stamp order, waking up waiters that must kill</span></span><br><span class="line"><span class="comment"> * themselves.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = __ww_mutex_add_waiter(&amp;waiter, lock, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">goto err_early_kill;</span><br><span class="line"></span><br><span class="line">waiter.ww_ctx = ww_ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">waiter.task = current;</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Once we hold wait_lock, we're serialized against</span></span><br><span class="line"><span class="comment"> * mutex_unlock() handing the lock off to us, do a trylock</span></span><br><span class="line"><span class="comment"> * before testing the error conditions to make sure we pick up</span></span><br><span class="line"><span class="comment"> * the handoff.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock))</span><br><span class="line">goto acquired;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check for signals and kill conditions while holding</span></span><br><span class="line"><span class="comment"> * wait_lock. This ensures the lock cancellation is ordered</span></span><br><span class="line"><span class="comment"> * against mutex_unlock() and wake-ups do not go missing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal_pending_state(state, current))) &#123;</span><br><span class="line">ret = -EINTR;</span><br><span class="line">goto err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx) &#123;</span><br><span class="line">ret = __ww_mutex_check_kill(lock, &amp;waiter, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">goto err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ww_mutex needs to always recheck its position since its waiter</span></span><br><span class="line"><span class="comment"> * list is not FIFO ordered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((use_ww_ctx &amp;&amp; ww_ctx) || !first) &#123;</span><br><span class="line">first = __mutex_waiter_is_first(lock, &amp;waiter);</span><br><span class="line"><span class="keyword">if</span> (first)</span><br><span class="line">__mutex_set_flag(lock, MUTEX_FLAG_HANDOFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Here we order against unlock; we must either see it change</span></span><br><span class="line"><span class="comment"> * state back to RUNNING and fall through the next schedule(),</span></span><br><span class="line"><span class="comment"> * or we must see its unlock and acquire.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock) ||</span><br><span class="line">    (first &amp;&amp; mutex_optimistic_spin(lock, ww_ctx, use_ww_ctx, &amp;waiter)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">&#125;</span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">acquired:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wound-Wait; we stole the lock (!first_waiter), check the</span></span><br><span class="line"><span class="comment"> * waiters as anyone might want to wound us.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!ww_ctx-&gt;is_wait_die &amp;&amp;</span><br><span class="line">    !__mutex_waiter_is_first(lock, &amp;waiter))</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_remove_waiter(lock, &amp;waiter, current);</span><br><span class="line"><span class="keyword">if</span> (likely(list_empty(&amp;lock-&gt;wait_list)))</span><br><span class="line">__mutex_clear_flag(lock, MUTEX_FLAGS);</span><br><span class="line"></span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line"></span><br><span class="line">skip_wait:</span><br><span class="line"><span class="comment">/* got the lock - cleanup and rejoice! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx)</span><br><span class="line">ww_mutex_lock_acquired(ww, ww_ctx);</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">mutex_remove_waiter(lock, &amp;waiter, current);</span><br><span class="line">err_early_kill:</span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line">mutex_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, ip);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码可以看出，如果task获取不到锁，则先把自己加入到等待队列，并且设置进程状态为TASK_UNINTERRUPTIBLE，让出CPU的执行。</p><h3 id="mutex-unlock"><a href="#mutex-unlock" class="headerlink" title="mutex_unlock"></a>mutex_unlock</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mutex_unlock - release the mutex</span></span><br><span class="line"><span class="comment"> * @lock: the mutex to be released</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unlock a mutex that has been locked by this task previously.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function must not be used in interrupt context. Unlocking</span></span><br><span class="line"><span class="comment"> * of a not locked mutex is not allowed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is similar to (but not equivalent to) up().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __sched mutex_unlock(struct mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">#ifndef CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="line"><span class="keyword">if</span> (__mutex_unlock_fast(lock))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">#endif</span><br><span class="line">__mutex_unlock_slowpath(lock, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Release the lock, slowpath:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __sched __mutex_unlock_slowpath(struct mutex *lock, unsigned long ip)</span><br><span class="line">&#123;</span><br><span class="line">struct task_struct *next = NULL;</span><br><span class="line">DEFINE_WAKE_Q(wake_q);</span><br><span class="line">unsigned long owner;</span><br><span class="line"></span><br><span class="line">mutex_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, ip);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Release the lock before (potentially) taking the spinlock such that</span></span><br><span class="line"><span class="comment"> * other contenders can get on with things ASAP.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Except when HANDOFF, in that case we must not clear the owner field,</span></span><br><span class="line"><span class="comment"> * but instead set it to the top waiter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">owner = atomic_long_read(&amp;lock-&gt;owner);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">unsigned long old;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEBUG_MUTEXES</span><br><span class="line">DEBUG_LOCKS_WARN_ON(__owner_task(owner) != current);</span><br><span class="line">DEBUG_LOCKS_WARN_ON(owner &amp; MUTEX_FLAG_PICKUP);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (owner &amp; MUTEX_FLAG_HANDOFF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">old = atomic_long_cmpxchg_release(&amp;lock-&gt;owner, owner,</span><br><span class="line">  __owner_flags(owner));</span><br><span class="line"><span class="keyword">if</span> (old == owner) &#123;</span><br><span class="line"><span class="keyword">if</span> (owner &amp; MUTEX_FLAG_WAITERS)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">owner = old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">debug_mutex_unlock(lock);</span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;lock-&gt;wait_list)) &#123;</span><br><span class="line"><span class="comment">/* get the first entry from the wait-list: */</span></span><br><span class="line">struct mutex_waiter *waiter =</span><br><span class="line">list_first_entry(&amp;lock-&gt;wait_list,</span><br><span class="line"> struct mutex_waiter, list);</span><br><span class="line"></span><br><span class="line">next = waiter-&gt;task;</span><br><span class="line"></span><br><span class="line">debug_mutex_wake_waiter(lock, waiter);</span><br><span class="line">wake_q_add(&amp;wake_q, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (owner &amp; MUTEX_FLAG_HANDOFF)</span><br><span class="line">__mutex_handoff(lock, next);</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line"></span><br><span class="line">wake_up_q(&amp;wake_q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放锁时，先检查ower是否是自己，如果是的，则从等待队列（wait_list）拿取第一个task，并且调用wake_up_q去唤醒task，task恢复执行。</p><p>——————————————全文完—————————————————–</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;互斥锁主要用于实现内核中的互斥访问功能。内核互斥锁是在原子 API 之上实现的，但这对于内核用户是不可见的。对它的访问必须遵循一些规则：同一时间只能有一个任务持有互斥锁，而且只有这个任务可以对互斥锁进行解锁。互斥锁不能进行递归锁定或解锁。一个互斥锁对象必须通过其API初始化
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>协程</title>
    <link href="http://yoursite.com/2018/12/26/xiecheng/"/>
    <id>http://yoursite.com/2018/12/26/xiecheng/</id>
    <published>2018-12-26T12:39:35.468Z</published>
    <updated>2018-12-26T12:39:35.464Z</updated>
    
    <content type="html"><![CDATA[<p>协程，英文（coroutines）,是一种比线程更加轻量级的存在。</p><ol><li>一个进程可以拥有多个线程，一个线程也可以拥有多个协程。</li><li>最重要的是，协程不是被操作系统内核所管理（内核调用），而完全是由用户态程序所控制（用户态执行）。</li><li>这样带来的好处就是性能得到了很大的提升，不像进程线程切换带来的消耗资源，cpu的调度。</li><li>协程的开销远远小于线程的开销。</li><li>协程并不想线程需要锁机制，协程中控制共享资源不加锁，只需要判断状态就好，所以执行效率比多线程高的多。</li></ol><p>因为协程是一个线程执行，那怎么利用多核CPU呢？<br>        最简单的方法就是多进程+协程，既充分利用多核，又充分发挥协程的高效率。</p><p>==协程允许我们写同步代码的逻辑，却做着异步的事，避免回调嵌套，使得代码逻辑清晰（协程是追求极限性能和优美的代码结构产物）==</p><p><em>参考手册</em> : <a href="http://ntycobook.ntytcp.com/" target="_blank" rel="noopener">协程详细介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;协程，英文（coroutines）,是一种比线程更加轻量级的存在。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个进程可以拥有多个线程，一个线程也可以拥有多个协程。&lt;/li&gt;
&lt;li&gt;最重要的是，协程不是被操作系统内核所管理（内核调用），而完全是由用户态程序所控制（用户态执行）。&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://yoursite.com/2018/12/26/git/"/>
    <id>http://yoursite.com/2018/12/26/git/</id>
    <published>2018-12-26T12:36:16.198Z</published>
    <updated>2018-12-26T12:36:16.198Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-git与SVN的区别"><a href="#1-git与SVN的区别" class="headerlink" title="1.git与SVN的区别"></a>1.git与SVN的区别</h5><p>git是分布式版本控制系统。必须客户端连接上服务端才能正常工作。<br>svn是集中式版本控制系统。每台机器就是一个单独运行的库，方便高效便捷的开发。</p><h5 id="2-git常用命令"><a href="#2-git常用命令" class="headerlink" title="2.git常用命令"></a>2.git常用命令</h5><p>git config -global ; 配置环境信息<br>git init ；将目录变成git管理的仓库，初始化仓库<br>git add ;提交到暂存区<br>git commit; 提交到本地仓<br>git status ;查看仓库是否有文件未提交<br>git diff 文件名；比较文件<br>git reset -hard HEAD~100;回到前100个版本<br>git reset -hard(版本号)；回到指定的版本号<br>git  reflog；取得版本号</p><p>git checkout -b ;创建并且换到分支<br>git branch dev ；创建分支<br>git checkout dev；切换分支<br>git merge dev; 将dev分支上的内容合并到主支master上<br>git branch -d name;删除分支</p><p><em>参考手册</em> :  <a href="http://47.106.79.26:4000/" target="_blank" rel="noopener">git详细介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-git与SVN的区别&quot;&gt;&lt;a href=&quot;#1-git与SVN的区别&quot; class=&quot;headerlink&quot; title=&quot;1.git与SVN的区别&quot;&gt;&lt;/a&gt;1.git与SVN的区别&lt;/h5&gt;&lt;p&gt;git是分布式版本控制系统。必须客户端连接上服务端才能正常工
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Lua脚本式编程</title>
    <link href="http://yoursite.com/2018/12/26/lua/"/>
    <id>http://yoursite.com/2018/12/26/lua/</id>
    <published>2018-12-26T08:58:27.539Z</published>
    <updated>2018-12-26T08:57:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h3><p>单行注释：–<br>多行注释：–[[ 内容–]]</p><p>lua最好<strong>不要使用</strong>下划线加大字母的标识符，因为lua的保留字是这样的。<br>lua不允许使用特殊字符如@$%来定义标志符。</p><p>默认情况下，变量总是认为全局。<br>删除全局变量，只需要将变量赋值nil .</p><p>lua的数据类型：nil 、boolean、number、string、userdata、function、thread和table。</p><p>nil作为比较时应该加上双引号，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type(x) == &quot;nil&quot;</span><br></pre></td></tr></table></figure><p>boolean类型只有两个可选值：true 和 false<br>lua把false和nil看作是“假”，其他都为真。</p><p>number（数字）：lua只有一种number类型，double双精度类型，默认类型可以修改luaconf.h里面的定义。</p><p>string（字符串）：由一对双引号或单引号来表示，也可以用2个方括号“[[ ]]”来表示“一块”字符串。</p><p>对一个数字字符串上进行算术操作时，lua会尝试将这个数字字符串转换成一个数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(“<span class="number">2</span>”+<span class="number">6</span>)   <span class="number">8.0</span></span><br><span class="line">print(<span class="string">"2"</span>+<span class="string">"6"</span>) <span class="number">8.0</span></span><br></pre></td></tr></table></figure><p>字符串连接使用的是 . .如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"a"</span> .. <span class="string">"b"</span>)  ab</span><br><span class="line">print(<span class="number">157</span> .. <span class="number">428</span>) <span class="number">157428</span></span><br></pre></td></tr></table></figure><p>#计算字符串的长度。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len =<span class="string">"www.runoob.com"</span></span><br><span class="line">print(#len)                 14</span><br><span class="line">print(#"www.runoob.com") 14</span><br></pre></td></tr></table></figure><h3 id="2-宿主语言C-C"><a href="#2-宿主语言C-C" class="headerlink" title="2.宿主语言C/C++"></a>2.宿主语言C/C++</h3><p>==虚拟栈==<br>        无论何时lua调用C，被调用的函数都得到一个新的栈，这个栈独立于C函数本身的栈，也独立于之前的栈。<br>        方便起见，所有正对栈的API查询操作都不严格遵守栈的操作规则。而是可以用一个索引来指向栈上的任何元素：<br>        ==正的索引指的是栈上的绝对位置（从1开始），负的索引指从栈顶开始的偏移量。==</p><p>Lua_checkstack:扩大可用堆栈的尺寸<br>LUA_MINSTACK一般被定义为20。</p><p>压入栈的数据类型包括数值、字符串、指针、table、闭包。</p><p><img src="./attachments/1545806848964.drawio.html" alt="Diagram"></p><p>Lua_pushcclosure(L,func,0)；创建并压入一个闭包<br>Lua_createtable(L,0,0)；新建并压入一个表<br>Lua_pushnumber(L,343)；压入一个数字<br>Lua_pushstring(L,”Nystr”)；压入一个字符串</p><p>Lua中，number、boolean、nil、lightuserdata四种类型的值是直接存在栈上元素里和垃圾回收无关。<br>Lua中，string、table、closure、userdata、thread存在栈上元素里的只是指针，他们都会在生命周期结束后被垃圾回收。</p><p>Lua_push<em>族函数都有“创建一个类型的值并压入”的语义。<br>Lua value -&gt; C value时，是通过Lua_to</em>族api实现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">取表中元素 </span><br><span class="line"><span class="keyword">void</span> lua_getfield(lua_state *L,int index,<span class="keyword">const</span> char *K)</span><br><span class="line">操作： arr = stack[index]</span><br><span class="line">stack.push(arr[K])</span><br><span class="line">取表中键为K的元素，这里的表是由index指向的栈上的一个表。</span><br><span class="line">栈高度+<span class="number">1</span>，栈顶元素是（stack[index]）[K]。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本语法&quot;&gt;&lt;a href=&quot;#1-基本语法&quot; class=&quot;headerlink&quot; title=&quot;1.基本语法&quot;&gt;&lt;/a&gt;1.基本语法&lt;/h3&gt;&lt;p&gt;单行注释：–&lt;br&gt;多行注释：–[[ 内容–]]&lt;/p&gt;
&lt;p&gt;lua最好&lt;strong&gt;不要使用&lt;/str
      
    
    </summary>
    
    
      <category term="技术,编程语言" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP通讯知识</title>
    <link href="http://yoursite.com/2018/11/25/TCP-IP%E9%80%9A%E8%AE%AF%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/11/25/TCP-IP通讯知识/</id>
    <published>2018-11-25T07:28:09.000Z</published>
    <updated>2018-11-25T07:28:51.974Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="TCP" scheme="http://yoursite.com/categories/TCP/"/>
    
    
      <category term="TCP网络通信" scheme="http://yoursite.com/tags/TCP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>test_md</title>
    <link href="http://yoursite.com/2018/11/23/test-md/"/>
    <id>http://yoursite.com/2018/11/23/test-md/</id>
    <published>2018-11-23T12:06:11.000Z</published>
    <updated>2018-11-25T07:09:53.890Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="test" scheme="http://yoursite.com/categories/test/"/>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/11/23/hello-world/"/>
    <id>http://yoursite.com/2017/11/23/hello-world/</id>
    <published>2017-11-23T12:06:11.000Z</published>
    <updated>2018-11-25T07:23:27.648Z</updated>
    
    <content type="html"><![CDATA[<p>notshow: true<br>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;notshow: true&lt;br&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a hr
      
    
    </summary>
    
      <category term="hexo查询" scheme="http://yoursite.com/categories/hexo%E6%9F%A5%E8%AF%A2/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
