<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JackYu&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/7d6859529934feb0edca87907b1ce4e0</icon>
  <subtitle>Nothing is impossible!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-11T06:49:00.834Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JackYu</name>
    <email>1134735533@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式架构</title>
    <link href="http://yoursite.com/2020/03/11/%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2020/03/11/认识分布式架构/</id>
    <published>2020-03-11T06:49:00.838Z</published>
    <updated>2020-03-11T06:49:00.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识分布式架构"><a href="#认识分布式架构" class="headerlink" title="认识分布式架构"></a>认识分布式架构</h1><p>随着计算机系统规模变得越来越大，将所有的业务单元集中部署在一个或若干个大型机上的体系结构，已经越来越不能满足当今计算机系统，尤其是大型互联网系统的快速发展，各种灵活多变的系统架构模型层出不穷。分布式的处理方式越来越受到业界的青睐——计算机系统正在经历一场前所未有的从集中式向分布式架构的变革。</p><h2 id="集中式与分布式"><a href="#集中式与分布式" class="headerlink" title="集中式与分布式"></a>集中式与分布式</h2><h3 id="集中式系统"><a href="#集中式系统" class="headerlink" title="集中式系统"></a>集中式系统</h3><p>所谓的集中式系统就是指由一台或多台主计算机组成中心节点，数据集中存储于这个中心节点中，并且整个系统的所有业务单元都集中部署在这个中心节点上，系统的所有功能均由其集中处理。</p><p>集中式系统的最大的特点就是部署结构非常简单，底层一般采用从IBM、HP等厂商购买到的昂贵的大型主机。因此无需考虑如何对服务进行多节点的部署，也就不用考虑各节点之间的分布式协作问题。但是，由于采用单机部署，很可能带来系统大而复杂、难于维护、发生单点故障（单个点发生故障的时候会波及到整个系统或者网络，从而导致整个系统或者网络的瘫痪）、扩展性差等问题。</p><h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p><strong>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统</strong>。简单来说就是一群独立计算机集合共同对外提供服务，但是对于系统的用户来说，就像是一台计算机在提供服务一样。分布式意味着可以采用更多的普通计算机（相对于昂贵的大型机）组成分布式集群对外提供服务。计算机越多，CPU、内存、存储资源等也就越多，能够处理的并发访问量也就越大。</p><p>从分布式系统的概念中我们知道，各个主机之间通信和协调主要通过网络进行，所以分布式系统中的计算机在空间上几乎没有任何限制，这些计算机可能被放在不同的机柜上，也可能被部署在不同的机房中，还可能在不同的城市中，对于大型的网站甚至可能分布在不同的国家和地区。但是，无论空间上如何分布，一个标准的分布式系统应该具有以下几个主要特征：</p><ul><li><p>分布性</p><p>分布式系统中的多台计算机之间在空间位置上可以随意分布，同时，机器的分布情况也会随时变动。</p></li><li><p>对等性</p><p>分布式系统中的计算机没有主／从之分，即没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是对等的。副本（Replica）是分布式系统最常见的概念之一，指的是分布式系统对数据和服务提供的一种冗余方式。在常见的分布式系统中，为了对外提供高可用的服务，我们往往会对数据和服务进行副本处理。数据副本是指在不同节点上持久化同一份数据，当某一个节点上存储的数据丢失时，可以从副本上读取该数据，这是解决分布式系统数据丢失问题最为有效的手段。另一类副本是服务副本，指多个节点提供同样的服务，每个节点都有能力接收来自外部的请求并进行相应的处理。</p></li><li><p>并发性</p><p>在一个计算机网络中，程序运行过程的并发性操作是非常常见的行为。例如同一个分布式系统中的多个节点，可能会并发地操作一些共享的资源，如何准确并高效地协调分布式并发操作也成为了分布式系统架构与设计中最大的挑战之一。</p></li><li><p>缺乏全局时钟</p><p>在分布式系统中，很难定义两个事件究竟谁先谁后，原因就是因为分布式系统缺乏一个全局的时钟序列控制。</p></li><li><p>故障总是会发生</p><p>组成分布式系统的所有计算机，都有可能发生任何形式的故障。除非需求指标允许，在系统设计时不能放过任何异常情况。</p></li></ul><h3 id="分布式系统面临的问题"><a href="#分布式系统面临的问题" class="headerlink" title="分布式系统面临的问题"></a>分布式系统面临的问题</h3><ul><li><p>通信异常</p><p>分布式系统需要在各个节点之间进行网络通信，因此网络通信都会伴随着网络不可用的风险或是系统不可用都会导致最终分布式系统无法顺利完成一次网络通信。另外，即使分布式系统各节点之间的网络通信能够正常进行，其延时也会远大于单机操作，会影响消息的收发的过程，因此消息丢失和消息延迟变得非常普遍。</p></li><li><p>网络分区</p><p>当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点之间能够进行正常通信，而另一些节点则不能——我们将这个现象称为网络分区，就是俗称的“脑裂”。当网络分区出现时，分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本需要整个分布式才能完成的功能，这就对分布式一致性提出类非常大的挑战。</p></li><li><p>三态</p><p>分布式系统的每一次请求与响应，存在特有的“三态”概念，即成功、失败与超时。当出现超时现象时，网络通信的发起方是无法确定当前请求是否被成功处理的。</p></li><li><p>节点故障</p><p>节点故障则是分布式环境下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或“僵死”现象。</p></li></ul><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>在单机数据库中，我们很容易能够实现一套满足ACID特性的事务处理系统，但在分布式数据库中，数据分散在不同的机器上，如何对这些数据进行分布式的事务处理具有非常大的挑战。但是在分布式计算领域，为了保证分布式应用程序的可靠性，分布式事务是无法回避的。</p><p>分布式事务是指事务的参与者、支持的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点之上。通常一个分布式事务中会涉及对多个数据源或业务系统的操作。一个最典型的分布式事务场景：一个跨银行的转账操作涉及调用两个异地的银行服务，其中一个是本地银行提供的取款服务，另一个则是目标银行提供的存款服务，这两个服务本身是无状态并且是互相独立的，共同构成了一个完整的分布式事务。</p><p>对于一个高访问量、高并发的互联网分布式系统来说，如果我们期望实现一套严格满足ACID特性的分布式事务，很可能出现的情况就是在系统的可用性和严格一致性之间出现冲突——因为当我们要求分布式系统具有严格一致性时，很可能就需要牺牲掉系统的可用性。但毋庸置疑的一点是，可用性又是一个所有消费者不允许我们讨价还价的系统属性，比如淘宝网这样在线网站就要求能够7*24小时不间断地对外提供服务，而对于一致性，则更加是所有消费者对于一个软件系统的刚需。因此，在可用性和一致性之间永远无法存在一个两全其美的方案，于是如何构建一个兼顾可用性和一致性的分布式系统成为了无数工程师探讨的难题，出现了诸如CAP和BASE这样的分布式系统经典理论。</p><h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h4><p>CAP理论告诉我们，一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的两项。</p><ul><li><p>一致性</p><p>在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致性的特性。在一致性的需求下，当一个系统在数据一致性的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都可以读取到其最新的值，那么这样的系统被认为具有强一致性（或严格的一致性）。</p></li><li><p>可用性</p><p>可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在<strong>有限的时间内返回结果</strong>。</p></li><li><p>分区容错性</p><p>分区容错性约束了一个分布式系统需要具有如下特性：分布式系统遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性的可用性的服务，除非是整个网络环境环境都发生了故障。需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区。</p></li></ul><p>在进行对CAP定理的应用时，我们就需要抛弃其中的一项，下表是抛弃CAP定理中任意一项特性的场景说明。</p><table><thead><tr><th style="text-align:center"><strong>放弃CAP定理</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:center">放弃P</td><td>如果希望能够避免系统出现分区容错性问题，一种较为简单的做法是将所有的数据都放在一个分布式节点上。这样的做法虽然无法100%地保证系统不会出错，但至少不会碰到由于网络分区带来的负面影响。但同时需要注意的是，放弃P的同时也就意味着放弃类系统的可扩展性</td></tr><tr><td style="text-align:center">放弃A</td><td>放弃可用性，一旦系统遇到网络分区或其他故障时，那么受到影响的服务需要等待一定的时间，因此在等待期间系统无法对外提供正常的服务，即不可用</td></tr><tr><td style="text-align:center">放弃C</td><td>事实上，放弃一致性指的是放弃数据的强一致性，而保留数据的最终一致性。这样的系统无法保证数据保持实时的一致性，但是能够承诺的是，数据最终会达到一个一致的状态。这就引入了一个时间窗口的概念，具体多久能够达到数据一致取决于系统的设计，主要包括数据副本在不同节点之间的复制时间长短</td></tr></tbody></table><p>对于一个分布式系统，分区容错性可以说是一个最基本的要求。既然是分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就称为了一个分布式系统必然需要面对和解决的问题。因此系统架构设计师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡。</p><h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，是由eBay的架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p><ul><li><p>基本可用</p><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。“基本可用”的典型例子：</p></li></ul><p>​        1、响应时间上损失：正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应 时间增加到了1-2秒。</p><p>​        2、功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在大促购物高峰的时候，由于消费 者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能被引导到一个降级页面。</p><ul><li><p>弱状态</p><p>弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p></li></ul><ul><li><p>最终一致性</p><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识分布式架构&quot;&gt;&lt;a href=&quot;#认识分布式架构&quot; class=&quot;headerlink&quot; title=&quot;认识分布式架构&quot;&gt;&lt;/a&gt;认识分布式架构&lt;/h1&gt;&lt;p&gt;随着计算机系统规模变得越来越大，将所有的业务单元集中部署在一个或若干个大型机上的体系结构，已经越来越
      
    
    </summary>
    
    
      <category term="技术架构" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C/C++编程</title>
    <link href="http://yoursite.com/2020/03/10/C++%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89/"/>
    <id>http://yoursite.com/2020/03/10/C++全局变量的声明和定义/</id>
    <published>2020-03-10T11:08:26.522Z</published>
    <updated>2020-03-10T11:08:26.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-全局变量的声明和定义"><a href="#C-全局变量的声明和定义" class="headerlink" title="C++全局变量的声明和定义"></a>C++全局变量的声明和定义</h1><h2 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a><strong>声明与定义</strong></h2><p>函数或变量在声明时，并没有给它实际的物理内存空间，它有时候可保证你的程序编译通过；<br>  函数或变量在定义时，它就在内存中有了实际的物理空间。</p><p>如果你在编译单元中引用的外部变量没有在整个工程中任何一个地方定义的话，那么即使它在编译时可以通过，在连接时也会报错，因为程序在内存中找不到这个变量。</p><p>函数或变量可以声明多次，但定义只能有一次。</p><h2 id="extern作用"><a href="#extern作用" class="headerlink" title="extern作用"></a><strong>extern作用</strong></h2><p>作用一：当它与”C”一起连用时，如extern “C” void fun(int a, int b);，则编译器在编译fun这个函数名时按C的规则去翻译相应的函数名而不是C++的。<br>作用二：当它不与”C”在一起修饰变量或函数时，如在头文件中，extern int g_nNum;，它的作用就是声明函数或变量的作用范围的关键字，其声明的函数和变量可以在本编译单元或其他编译单元中使用。</p><p>即B编译单元要引用A编译单元中定义的全局变量或函数时，B编译单元只要包含A编译单元的头文件即可，在编译阶段，B编译单元虽然找不到该函数或变量，但它不会报错，它会在链接时从A编译单元生成的目标代码中找到此函数。</p><p>extern声明全局变量的时候，表明在一个文件地方声明定义后，其他文件中需要使用的时候需要声明在变量前声明为extern.例如在A.cpp中，声明定义变量g_keyApi;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line">fit::KeyApi::KaClass g_KeyApi = <span class="literal">NULL</span>;</span><br><span class="line">g_KeyApi = <span class="keyword">new</span> KaClass();</span><br></pre></td></tr></table></figure><p>在B.cpp中需要使用g_KeyApi时，可以在文件头部这样声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B.cpp</span></span><br><span class="line"><span class="keyword">extern</span> fit::KeyApi::KaClass g_KeyApi;</span><br><span class="line">g_KeyApi-&gt;signCheck();<span class="comment">//验签</span></span><br></pre></td></tr></table></figure><p>这样可以让B.cpp在编译的时候通过，连接的时候再去找obj。</p><h2 id="静态全局变量-static"><a href="#静态全局变量-static" class="headerlink" title="静态全局变量(static)"></a><strong>静态全局变量(static)</strong></h2><p>注意使用static修饰变量，就不能使用extern来修饰，即static和extern不可同时出现。<br> static修饰的全局变量的声明与定义同时进行，即当你在头文件中使用static声明了全局变量，同时它也被定义了。<br>    static修饰的全局变量的作用域只能是本身的编译单元。在其他编译单元使用它时，只是简单的把其值复制给了其他编译单元，其他编译单元会另外开个内存保存它，在其他编译单元对它的修改并不影响本身在定义时的值。即在其他编译单元A使用它时，它所在的物理地址，和其他编译单元B使用它时，它所在的物理地址不一样，A和B对它所做的修改都不能传递给对方。<br>    多个地方引用静态全局变量所在的头文件，不会出现重定义错误，因为在每个编译单元都对它开辟了额外的空间进行存储。</p><p>注：一般定义static 全局变量时，都把它放在.cpp文件中而不是.h文件中，这样就不会给其他编译单元造成不必要的信息污染。</p><h2 id="全局常量-const"><a href="#全局常量-const" class="headerlink" title="全局常量(const)"></a><strong>全局常量(const)</strong></h2><p>const单独使用时，其特性与static一样（每个编译单元中地址都不一样，不过因为是常量，也不能修改，所以就没有多大关系）。</p><p> const与extern一起使用时，其特性与extern一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span> g_szBuffer[];      <span class="comment">//写入 .h中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> g_szBuffer[] = <span class="string">"123456"</span>; <span class="comment">// 写入.cpp中</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-全局变量的声明和定义&quot;&gt;&lt;a href=&quot;#C-全局变量的声明和定义&quot; class=&quot;headerlink&quot; title=&quot;C++全局变量的声明和定义&quot;&gt;&lt;/a&gt;C++全局变量的声明和定义&lt;/h1&gt;&lt;h2 id=&quot;声明与定义&quot;&gt;&lt;a href=&quot;#声明与定义&quot;
      
    
    </summary>
    
    
      <category term="技术,编程语言" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C/C++编程</title>
    <link href="http://yoursite.com/2020/03/10/%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/10/懒汉模式与饿汉模式/</id>
    <published>2020-03-10T11:06:45.937Z</published>
    <updated>2020-03-10T10:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="懒汉模式与饿汉模式"><a href="#懒汉模式与饿汉模式" class="headerlink" title="懒汉模式与饿汉模式"></a>懒汉模式与饿汉模式</h1><p>单例懒汉模式：需要使用的时候在进行实例化，加载速度快，调用慢。非线程安全</p><p>单例饿汉模式：在声明的时候立即初始化实例化，加载速度慢，调用速度快。线程安全</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;懒汉模式与饿汉模式&quot;&gt;&lt;a href=&quot;#懒汉模式与饿汉模式&quot; class=&quot;headerlink&quot; title=&quot;懒汉模式与饿汉模式&quot;&gt;&lt;/a&gt;懒汉模式与饿汉模式&lt;/h1&gt;&lt;p&gt;单例懒汉模式：需要使用的时候在进行实例化，加载速度快，调用慢。非线程安全&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="技术,编程语言" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Fabric源码分析</title>
    <link href="http://yoursite.com/2020/03/10/fabric/"/>
    <id>http://yoursite.com/2020/03/10/fabric/</id>
    <published>2020-03-10T10:34:28.655Z</published>
    <updated>2020-03-10T10:34:28.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fabric"><a href="#Fabric" class="headerlink" title="Fabric"></a>Fabric</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​     Hyperledger Fabric 是一个模块化架构的分布式账本平台，提供高度的机密性，弹性，灵活性和可扩展性。它旨在支持不同组件的可插拔实现，并且可以容纳生态系统中存在的高度复杂应用。  <strong>超级账本项目为透明、公开、去中心化的企业级分布式账本技术提供开源参考实现。</strong></p><h2 id="区块链是什么"><a href="#区块链是什么" class="headerlink" title="区块链是什么"></a>区块链是什么</h2><h3 id="1-分布式账本（A-Distributed-Ledger）"><a href="#1-分布式账本（A-Distributed-Ledger）" class="headerlink" title="1.分布式账本（A Distributed Ledger）"></a>1.<strong>分布式账本（A Distributed Ledger）</strong></h3><p> 区块链网络的核心是一个分布式账本，用于记录在网络上发生的所有交易。区块链账本通常被描述为去中心化的，因为它被复制到许多网络参与者中，每个参与者都在协作维护。我们将看到，分权和协作是反映企业在现实世界中交换产品和服务方式的强大属性。 </p><p> <img src="http://hyperledger-fabric.readthedocs.io/en/latest/_images/basic_network.png" alt="img"> </p><p> 除了去中心化和协作之外，记录在区块链中的信息只能追加，使用加密技术可保证一旦交易添加在账本中，便无法对其进行修改。这种无法篡改的特性使得判断信息的来源变得很简单，因为参与者可以肯定信息在事后没有被改变。这就是区块链有时被描述为<strong>证明体系</strong>的原因。 </p><h3 id="2-智能合约（Smart-Contracts）"><a href="#2-智能合约（Smart-Contracts）" class="headerlink" title="2.智能合约（Smart Contracts）"></a><strong>2.智能合约（Smart Contracts）</strong></h3><p> 为了支持信息一致性更新 —— 启用一整作用于账本的功能（交易，查询等） —— 区块链网络使用智能合约来提供对账本访问控制。 </p><p> <img src="http://hyperledger-fabric.readthedocs.io/en/latest/_images/Smart_Contract.png" alt="img"> </p><p> 智能合约不仅是简单的封装信息在整个网络中同步，它们也可以被写入以允许参与者的一些交易能自动执行。例如，可以写一份智能合约，通过物品何时到达来决定传输费用。双方一旦同意该条款并写入账本中，当商品到达时，相应的资金将会自动被转入。 </p><h3 id="3-共识（Consensus）"><a href="#3-共识（Consensus）" class="headerlink" title="3.共识（Consensus）"></a><strong>3.共识（Consensus）</strong></h3><p> 通过网络保持分类账交易同步的过程 — 确保账本只有在交易获得相应的参与者批准时才更新，并且当账本更新时，它们以包含相同的顺序区块来更新账本 — 这个过程就称为共识。 </p><p> <img src="http://hyperledger-fabric.readthedocs.io/en/latest/_images/consensus.png" alt="img"> </p><p>我们将在后面学习更多关于账本、智能合约和共识的知识。就目前而言，将区块链视为共享的、复制的交易系统就足够了，该交易系统通过智能合约进行更新，并通过称为共识的协作过程保持一致同步。</p><h2 id="Fabric的特点"><a href="#Fabric的特点" class="headerlink" title="Fabric的特点"></a>Fabric的特点</h2><p> Hyperledger Fabric 是 Hyperledger 中的区块链项目之一。像其他区块链技术一样，它具有账本，使用智能合约，并且系统是参与者管理其交易的。 </p><p> Hyperledger Fabric从其他一些区块链系统中脱颖而出的地方在于它是<strong>私密的</strong>并且是<strong>权限化的</strong>。相对于允许未知身份参与网络的开放式权限系统（需要工作证明等协议来验证交易和保护网络）。Hyperledger Fabric 网络的成员通过注册可信<strong>成员服务提供商（Membership Service Provider 简称 MSP）</strong>来保证系统的私密性。 </p><p> Hyperledger Fabric 还提供多种可热插拔选项。账本数据可以以多种格式来存储，共识机制可以随时切换开关，并支持多种的MSP。 </p><p> Hyperledger Fabric 还提供了创建<strong>频道（channels）</strong>的能力，允许一组参与者创建单独的交易账本。对网络参与者中有潜在的竞争对手的情况下，这是一个特别重要的选择 — 例如，他们向某些参与者提供的特殊价格 — 每位参与者都知道。如果两个参与者都在一个频道，那么这些参与者（没有其他人）就拥有该频道的账本副本。 </p><h3 id="共享账本（Shared-Ledger）"><a href="#共享账本（Shared-Ledger）" class="headerlink" title="共享账本（Shared Ledger）"></a><strong>共享账本（Shared Ledger）</strong></h3><p> Hyperledger Fabric 的账本系统有两个组件：<strong>世界状态（world state）</strong>和<strong>事务日志（transaction log）</strong>。每个参与者都将分类帐的副本分配给所属的每个 Hyperledger Fabric 网络。Hyperledger Fabric 中的网络参与者都有一本账本副本。 </p><p> 世界状态组件描述了在特定时间点下账本的状态。这是相当于账本的数据库。交易日志组件记录了构成世界状态的所有交易;由此得出，账本是世界状态数据库和交易日志历史记录的组合。 </p><p> 账本对世界状态有可替换的数据存储。默认情况下，这是一个 LevelDB 键值存储数据库。事务日志不需要是可插拔的。它只记录区块链网络中使用的账本数据库的前后值。 </p><h3 id="智能合约（Smart-Contracts）"><a href="#智能合约（Smart-Contracts）" class="headerlink" title="智能合约（Smart Contracts）"></a><strong>智能合约（Smart Contracts）</strong></h3><p> Hyperledger Fabric 的智能合约是用 <strong>chaincode</strong> 实现的，并且被区块链外部应用程序所调用，以此来与账本交互。在大多数情况下，chaincode 仅与账本的数据库组件（世界状态）（例如查询）交互，而不与交易日志交互。 </p><h3 id="私密性（Privacy）"><a href="#私密性（Privacy）" class="headerlink" title="私密性（Privacy）"></a><strong>私密性（Privacy）</strong></h3><p> 根据网络的需求，企业对企业（B2B）网络的参与者可能对他们共享多少信息非常敏感。对于其他区块链网络而言，隐私不会成为首要问题。 </p><p> 相遇对其他的区块链网络，隐私（使用频道方法）对于 Hyperledger Fabric 是非常关键的要求。 </p><h3 id="共识（Consensus）"><a href="#共识（Consensus）" class="headerlink" title="共识（Consensus）"></a><strong>共识（Consensus）</strong></h3><p> 交易必须按照发生的顺序写入账本中，网络中不同的参与者皆是如此。要做到这点，必须建立交易顺序，并且必须实施一种方法，用于拒绝错误（或恶意）插入账本的不良交易。 </p><p> 这是一个老生常谈的计算机科学领域，有很多方法可以实现共识算法，每个方法都有不同的利弊。例如，PBFT（Practical Byzantine Fault Tolerance）可以提供文件副本相互通信的机制，以保持每个副本的一致性，即使在发生损坏的情况下。或者，在比特币中，通过计算加密问题（也被称为挖矿）来实现共识，谁先算出来该区块就算谁的。 </p><p>  Hyperledger Fabric 共识机制，其中目前包括 SOLO，Kafka ，会很快将了解到 SBFT（简化的拜占庭容错）。 </p><h2 id="Fabric应用场景"><a href="#Fabric应用场景" class="headerlink" title="Fabric应用场景"></a>Fabric应用场景</h2><p> Fabric由于其联盟链的特性，可以面向企业内部或多个企业之间的商业区块链应用场景，将区块链的维护节点和可见性限制在联盟内部，并用智能合约（链码）重点解决联盟成员间的信任或信息不对等问题，以提高经济活动效率。Fabric主要应用的场景如下：<br>➤金融服务：Fabric可以有效降低交易成本和管控风险、减少跨组织的交易风险，其在金融领域的应用受到了不少银行和金融交易机构的主要推动。<br>➤征信和资产权属管理：Fabric可以促进数据的交易和流动；提供安全可靠的支持。特别是资产权属的管理，利用区块链平台建立的多方信任机制可以有效降低资产交易成本和违约风险。<br>➤国际自动化贸易和供应链管理：Fabric可以简化管理流程中繁琐的手续。利用智能合约，贸易中销售和法律合同可以数字化、可以实现货物监控和实时支付，大大降低了公司的运营成本。 </p><h2 id="Fabric参考手册"><a href="#Fabric参考手册" class="headerlink" title="Fabric参考手册"></a>Fabric参考手册</h2><p><a href="https://hyperledger-fabric-zh-cn.readthedocs.io/zh/latest/docs/Peers.html" target="_blank" rel="noopener">peers对等节点</a> </p><p><a href="https://hyperledger-fabric-zh-cn.readthedocs.io/zh/latest/docs/Ledger.html" target="_blank" rel="noopener">ledger账本</a> </p><h2 id="Fabric的基本框架"><a href="#Fabric的基本框架" class="headerlink" title="Fabric的基本框架"></a>Fabric的基本框架</h2><p> <img src="https://pic2.zhimg.com/80/v2-a77b25f8a3e4d7a4b5d005bbe5b6df89_720w.jpg" alt="img"> </p><h2 id="Fabric的基本逻辑架构"><a href="#Fabric的基本逻辑架构" class="headerlink" title="Fabric的基本逻辑架构"></a><strong>Fabric的基本逻辑架构</strong></h2><p> <img src="https://pic2.zhimg.com/v2-45187b8292aa5ecab715b12a80825aa1_r.jpg" alt="preview"> </p><h2 id="Fabric共识模式"><a href="#Fabric共识模式" class="headerlink" title="Fabric共识模式"></a>Fabric共识模式</h2><p>fabric共识模式采用的 Endorse+Kafka+Commit 的模式，这里我们简称EKC共识。此共识包含以下几个步骤：</p><p>1.请求背书：<br>客户端用自己的私钥对交易进行签名后，按照指定格式将交易和签名信息进行打包，然后将打包后的数据发给背书节点请求背书。</p><p>2.验证背书：<br>背书节点收到背书请求后，验证交易的签名是否正确并调用智能合约验证交易内容是否合法。验证通过的话，背书节点用自己的私钥对背书结果进行签名并按照指定格式打包，然后将打包后的数据发给客户端。</p><p>3.提交交易：<br>客户端收到背书结果后，验证背书结果的签名是否正确。验证通过后，对交易请求和背书结果签名并打包。然后，把打包后的数据发送给orderer节点提交交易。</p><p>4.排序广播：<br>orderer节点收到交易后，验证数据的客户端签名<a href="#_msocom_1">[bJ1]</a> 是否正确。验证通过后，将交易发给kafka集群对应的topic。由于orderer中的对于每个通道都在kafka上监听对应的消息，因此，kafka将消息存放到对应topic上之后，会将消息广播给通道上的所有orderer。因为各个orderer的消息都是由kafka按照相同顺序发送的，因此，这个过程也实现了消息的排序。</p><p>5.打包出块：<br>orderer节点接收到从kafka推送的消息（kafka节点见同步消息不需要验证），当满足出块策略<a href="#_msocom_2">[bJ2]</a> ：缓存交易个数达到区块最大交易数或者时间达到出快时间，则将交易进行打包、对数据签名，然后出块，并将区块分发给peer节点。</p><p>6.验证记账：<br>peer节点接收到区块后，验证交易是否有效即验证区块的交易是否满足背书策略以及区块中交易的读写集版本是否正确<a href="#_msocom_3">[bJ3]</a> 。验证通过的话，执行此交易的内容更改状态数据库。验证失败的话，对此条交易不做任何处理。当区块中的交易全部处理完成后，将区块记录在本地数据库。</p><h2 id="Fabric源码解析"><a href="#Fabric源码解析" class="headerlink" title="Fabric源码解析"></a>Fabric源码解析</h2><h3 id="一、整体结构"><a href="#一、整体结构" class="headerlink" title="一、整体结构"></a>一、整体结构</h3><p>​    Hyperledger Fabric 在 1.0 中，架构已经解耦为三部分： </p><p>​    peer：主要起到 peer 作用，包括 endorser、committer 两种角色； </p><p>​    ca：即原先的 membersrvc，独立成一个新的项目。 </p><p>​    order：起到 order 作用。 </p><p>​    其中，peer 和 order 代码暂时都在 fabric 项目中，未来可能进一步拆分。</p><p>启动过程：<strong>orderer0,peer0,peer1,peer2,peer3,cli</strong>六个容器服务，首先在容器启动的时候order程序,然后在启动peer节点容器，相当于启动peer程序，最后启动cli容器。</p><p><strong>通过docker相关启动脚本，orderer容器先起，各个peer之间其实可以没有先后顺序但是都必须后与orderer容器，最后是cli容器。这说明，orderer服务必须先于peer服务，peer node start命令必须先于peer channel或peer chaincode命令。</strong></p><h3 id="二、源代码"><a href="#二、源代码" class="headerlink" title="二、源代码"></a>二、源代码</h3><p>说明：以下讲解代码基于fabric 1.0版本（<a href="https://github.com/hyperledger/fabric/tree/release-1.0" target="_blank" rel="noopener">github地址</a>）    </p><p>实现fabric功能的核心代码，包括：</p><ul><li><p>​    <strong><a href="">bccsp</a>包</strong>：实现对加解密算法和机制的支持。</p></li><li><p>​    <strong><a href="">common</a>包</strong>：一些通用的模块；</p></li><li>​    <strong><a href="">core</a>包</strong>：大部分核心实现代码都在本包下。其他包的代码封装上层接口，最终调用本包内代码；</li><li>​    <strong><a href="">events</a>包</strong>：支持event框架；</li><li>​    <strong><a href="">examples</a>包</strong>：包括一些示例的chaincode代码；</li><li>​    <strong><a href="">gossip</a>包</strong>：实现gossip协议；</li><li>​    <strong><a href="">msp</a>包</strong>：Member Service Provider 包；</li><li>​    <strong><a href="">order</a>包</strong>：order服务相关的入口和框架代码；</li><li>​    <strong><a href="">peer</a>包</strong>：peer的入口和框架代码；</li><li>​    <strong><a href="">protos</a>包</strong>：包括各种协议和消息的protobuf定义文件和生成的go文件。</li></ul><p>​    一些辅助代码包，包括：</p><ul><li>​    <strong><a href="">bddtests</a>包</strong>: 测试包，含大量bdd测试用例；</li><li>​    <strong><a href="">gotools</a>包</strong>：golang开发相关工具安装；</li><li>​    <strong><a href="">vendor</a>包</strong>： 管理依赖；</li></ul><p>​    安装部署包括：</p><ul><li><p>​    <strong><a href="">busybox</a>包</strong>：busybox环境，精简的Linux;</p></li><li><p>​    <strong><a href="">devenv</a>包</strong>：配置开发环境；</p></li><li><p>​    <strong><a href="">images</a>包</strong>：镜像生成模板等；</p></li><li><p>​    <strong><a href="">scripts</a>包</strong>：各种安装配置脚本；</p></li></ul><h3 id="三、核心过程"><a href="#三、核心过程" class="headerlink" title="三、核心过程"></a>三、核心过程</h3><p>​    总结一下核心核心的过程。</p><h4 id="3-1-Chaincode启动过程"><a href="#3-1-Chaincode启动过程" class="headerlink" title="3.1 Chaincode启动过程"></a>3.1 Chaincode启动过程</h4><p>​    Hyperledger Fabric中，Chaincode默认运行在Docker容器中。Peer通过调用Docker API来创建和启动Chaincode容器。Chaincode容器启动后跟Peer之间创建gRPC连接，双方通过发送ChaincodeMessage来进行交互通信。Chaincode容器利用core.chaincode.shim包提供的接口来向Peer发送请求。</p><p>​    <strong>典型结构</strong></p><p>​    下面给出了链码的典型结构，用户只需要关注到 Init() 和 Invoke() 函数的实现上，在其中利用 </p><p>​    shim.ChaincodeStubInterface 结构，实现跟账本的交互逻辑。</p><p>​    </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span> </span><br><span class="line"><span class="string">"fmt"</span> </span><br><span class="line"><span class="string">"github.com/hyperledger/fabric/core/chaincode/shim"</span> </span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> DemoChaincode <span class="keyword">struct</span> &#123; &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *DemoChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123; </span><br><span class="line"><span class="comment">// more logics using stub here </span></span><br><span class="line"><span class="keyword">return</span> stub.Success(<span class="literal">nil</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *DemoChaincode)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span>&#123;</span><br><span class="line"><span class="comment">// more logics using stub here </span></span><br><span class="line">    <span class="keyword">return</span> stub.Success(<span class="literal">nil</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    err := shim.Start(<span class="built_in">new</span>(DemoChaincode)) </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; </span><br><span class="line">        fmt.Printf(<span class="string">"Error starting DemoChaincode: %s"</span>, err) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    Chaincode首先是一个普通的goland程序，其main方法中调用了shim层的Start()方法。启动过程如下图所示：</p><p><img src="D:\其他\区块链研究\区块链笔记\chaincode.shim.start.png"></p><p>​                                                    图  Chaincode* 启动过程</p><p>首先会进行初始化。包括读取默认配置，创建到 Peer 的gRPC 连接，主要包括 </p><p>NewChaincodeSupportClient(cc *grpc.ClientConn) 和 chaincodeSupportClient.Register(ctx </p><p>context.Context, opts …grpc.CallOption) 两个方法。 </p><p>初始化完成后，创建有限状态机结构（FSM，github.com/looplab/fsm）。FSM 会根据收到的 </p><p>消息和当前状态来触发状态转移，并执行提前设置的操作。 </p><p><em>Peer</em> 侧也利用了类似的 <em>FSM</em> 结构来管理消息响应。 </p><p>之后，利用创建好的 gRPC 连接开始向 Peer 发送第一个 gRPC 消息： </p><p>ChaincodeMessage_REGISTER，将自身注册到 Peer 上。注册成功后开始消息处理循环， </p><p>等待接收来自 Peer 的消息以及自身的状态迁移（nextState）消息。</p><p>后续过程中，Chaincode 和 Peer 利用 FSM 完成一系列对消息的响应运作，如下所示。</p><ul><li>​    Peer 收到来自链码容器的 ChaincodeMessage_REGISTER 消息，将其注册到本地的一 </li></ul><p>个 Handler 结构，返回 ChaincodeMessage_REGISTERED 消息发给链码容器。之后更 </p><p>新状态为 established ，并发送 ChaincodeMessage_READY 消息给链码侧，更新状态 </p><p>为 ready。</p><ul><li>链码侧收到 ChaincodeMessage_REGISTERED 消息后，不进行任何操作，注册成功。 </li></ul><p>更新状态为 established。收到 ChaincodeMessage_READY 消息后更新状态为 ready。</p><ul><li><p>Peer 侧发出 ChaincodeMessage_INIT 消息给链码容器，准备触发链码侧初始化操作。</p></li><li><p>链码容器收到 ChaincodeMessage_INIT 消息，通过 Handler.handleInit() 方法进行进行 </p><p>初始化。主要包括初始化所需的 ChaincodeStub 结构，以及调用链码代码中的 Init() 方 </p><p>法。初始化成功后，返回 ChaincodeMessage_COMPLETED 消息给 Peer。此时，链码 </p><p>容器进入可被调用（Invoke）状态。 </p></li><li><p>链码被调用时，Peer 发出 ChaincodeMessage_TRANSACTION 消息给链码。 </p></li><li><p>链码收到 ChaincodeMessage_TRANSACTION 消息，会调用 Invoke() 方法，根据 Invoke 方法中用户实现的逻辑，可以发出包括 ChaincodeMessage_GET_HISTORY_FOR_KEY、ChaincodeMessage_GET_QUERY_RESULT、ChaincodeMessage_GET_STATE、ChaincodeMessage_GET_STATE_BY_RANGE、 ChaincodeMessage_QUERY_STATE_CLOSE、ChaincodeMessage_QUERY_STATE_NEXT、 ChaincodeMessage_INVOKE_CHAINCODE 等消息给 Peer 侧。Peer 侧收到这些消 息，进行相应的处理，并回复 ChaincodeMessage_RESPONSE 消息。最后，链码侧会 </p><p>回复调用完成的消息 ChaincodeMessage_COMPLETE 给 Peer 侧。</p></li><li><p>在上述过程中，Peer 和链码侧还会定期的发送 ChaincodeMessage_KEEPALIVE 消息给 </p><p>对方，以确保彼此在线。</p></li></ul><h4 id="3-2-Peer节点启动"><a href="#3-2-Peer节点启动" class="headerlink" title="3.2 Peer节点启动"></a>3.2 Peer节点启动</h4><h5 id="3-2-1-Peer背书提案过程"><a href="#3-2-1-Peer背书提案过程" class="headerlink" title="3.2.1 Peer背书提案过程"></a>3.2.1 Peer背书提案过程</h5><p>​    客户端将交易预提案（Transaction Proposal)通过 gRPC 发送给支持 Endorser 角色的 Peer </p><p>进行背书。 </p><p>这些交易提案可能包括链码的安装、实例化、升级、调用、查询；以及 Peer 节点加入和列出 </p><p>通道操作。 </p><p>Peer 接收到请求后，会调用 core/endorser/endorser.go 中 Endorser 结构体 </p><p>的 ProcessProposal(ctx context.Context, signedProp *pb.SignedProposal) </p><p>(*pb.ProposalResponse, error) 方法，进行具体的背书处理。 </p><p>背书过程主要完成如下操作： </p><ul><li><p>检查提案消息的合法性，以及相关的权限； </p></li><li><p>模拟执行提案：启动链码容器，对世界状态的最新版本进行临时快照，基于它执行链 </p><p>码，将结果记录在读写集中； </p></li><li><p>对提案内容和读写集合进行签名，并返回提案响应消息。 </p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">ProcessProposal</span><span class="params">(ctx context.Context, signedProp *pb.SignedProposal)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//检查交易的合法性</span></span><br><span class="line">    prop, hdr, hdrExt, err := validation.ValidateProposalMessage(signedProp)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//该方法主要是Peer节点模拟提案过程，但是不会写入到区块中，当Peer节点模拟完一项提案，将模拟结果保存至读写集。</span></span><br><span class="line">    cd, res, simulationResult, ccevent, err := e.simulateProposal(ctx, chainID, txid, signedProp, prop, hdrExt.ChaincodeId, txsim)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> chainID == <span class="string">""</span> &#123;</span><br><span class="line">        pResp = &amp;pb.ProposalResponse&#123;</span><br><span class="line">            Response: res</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pResp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要过程如下图所示。</p><p><img src="D:\其他\区块链研究\区块链笔记\peer背书过程.jpg" style="zoom:150%"></p><p>​                                             <em>Endorser ProcessProposal</em> 过程</p><ul><li>检查提案合法性；<ul><li>调用 ValidateProposalMessage() 方法对签名的提案进行格式检查，主要包括：<ul><li>Channel 头部格式：是否合法头部类型，由 validateChannelHeader() 完成；</li><li>签名头格式：是否包括了 nonce 和creators 数据，由validateSignatureHeader() 完成； </li><li>签名域：creator 证书 MSP 检查是否合法，签名是否正确，由checkSignatureFromCreator() 完成。</li></ul></li><li>如果是系统链码调用（SCC），检查是否是允许从外部调用的三种 SCC 之一：cscc、lscc、qscc 或 rscc；</li><li>如果 chainID 不为空，获取对应 chain 的账本结构，并检查 TxID 唯一性，确保同一交易未曾提交到账本结构中； </li><li>对于用户链码调用，需要检查 ACL：资源为 PROPOSE ，默认策略是签名提案者在通道上拥有写权限（ CHANNELWRITERS ）。</li></ul></li><li>模拟执行提案 <ul><li>如果 chainID 不为空，获取对应账本的交易模拟器（TxSimulator）和历史查询器（HistoryQueryExecutor），这两个结构将在后续执行链码时被使用。 </li><li>如果 chainID 不为空，调用 simulateProposal() 方法获取模拟执行的结果，检查返回的响应 response 的状态，若不小于错误 500 则创建并返回一个失败的ProposalResponse。 </li></ul></li><li>对提案内容和读写集合进行签名 <ul><li>chainID 非空情况下，调用 endorseProposal() 方法利用 ESCC，对之前得到的模拟执行的结果进行背书。返回 ProposalResponse，检查 simulateProposal 返回的response 的状态，若不小于错误阈值 400（被背书节点反对），返回ProposalResponse 及链码错误 chaincodeError（endorseProposal 里有检查链码执行结果的状态，而 simulateProposal 没有检查）。</li><li>将 response.Payload 赋给 ProposalResponse.Response.Payload（因为simulateProposal 返回的 response 里面包含链码调用的结果）。</li><li>返回响应消息 ProposalResponse。 </li></ul></li></ul><p><strong>simulateProposal</strong> 方法 </p><p>​    simulateProposal 方法会通过执行链码逻辑来获取对状态的修改结果，并存放到读写集合 </p><p>中，主要过程如下： </p><ul><li>从提案结构的载荷中提取 ChaincodeInvocationSpec 结构，其中包含了所调用链码（包括系统链码和用户链码）的路径、名称和版本，以及调用时传入的参数列表；</li><li>检查 ESCC 和 VSCC（尚未实现）；</li><li>对用户链码，检查提案中的实例化策略跟账本上记录的该链码的实例化策略（安装链码时指定）是否一致。防止有人修改权限在其它通道非法实例化。 </li><li>调用 callChaincode() 方法执行 Proposal，返回 Response 和 ChaincodeEvent。<ul><li>调用 core.endorser 包中 SupportImpl.Execute() 方法，该方法主要调用core.chaincode 包中的 ExecuteChaincode() 方法，进一步调用包内的 Execute()方法。调用过程中会把交易模拟器和历史查询器通过上下文结构体传入后续子方法。</li><li>Execute() 方法会调用 ChaincodeSupport.Launch() 方法创建并启动链码容器。启动成功后创建链码 gRPC 消息，通过 ChaincodeSupport.Execute() 方法发送消息给CC 容器，执行相关的合约，并返回执行响应（ChaincodeMessage 结构）。此过程 中会将读写集记录到交易模拟器结构体中。</li></ul></li><li>对于非空 chainID（大部分跟账本相关的操作），执行 GetTxSimulationResults() 拿到执行结果 TxSimulationResults 结构，从中可以解析出读写集数据。</li><li>最终返回链码标准数据结构 ChaincodeDefinition、响应消息 ChaincodeMessage、交易读写集 PubSimulationResults、链码事件 ChaincodeEvent。</li></ul><p><strong>endorseProposal</strong> 方法</p><p>主要过程如下： </p><ul><li>获取被调用的链码指定的背书链码的名字。</li><li>通过 callChaincode() 实现对背书链码的调用，返回响应 response（对 ESCC 的调用同样也会产生 simulation results，但 ESCC 不能背书自己产生的simulation results，需要背书最初被调用的链码产生的 simulation results）。</li><li>检查 response.Status，是否大于等于 400（错误阈值），若是则把 response 赋给proposalResponse.Response 并返回 proposalResponse。</li><li>将 response.Payload解码后（ProposalResponse类型）返回。</li></ul><p><strong>callChaincode</strong> 方法</p><p>主要过程如下： </p><ul><li>判断交易模拟器，不为空则把它加入到Context的K-V存储中。</li><li>判断被call的cc是不是系统链码，创建CCContext（包含通道名、链码名、版本号、交易ID、是否 SCC、签名 Prop、Prop）</li><li>调用 core/chaincode/chaincodeexec.go 下的 ExecuteChaincode()，返回响应 response和 事件ccevent。</li><li>返回 response和ccevent。</li></ul><h4 id="3-3排序服务核心原理和工作过程"><a href="#3-3排序服务核心原理和工作过程" class="headerlink" title="3.3排序服务核心原理和工作过程"></a>3.3排序服务核心原理和工作过程</h4><p>​    排序服务在超级账本 Fabric 网络中起到十分核心的作用。所有交易在发送给 Committer 进行 </p><p>验证接受之前，需要先经过排序服务进行全局排序。 </p><p>在目前架构中，排序服务的功能被抽取出来，作为单独的 fabric-orderer 模块来实现，代码主 </p><p>要在 fabric/orderer 目录下。 </p><p>下面以 Kafka 作为共识插件为例，讲解 Orderer 节点的核心过程。 </p><h5 id="3-3-1工作原理"><a href="#3-3-1工作原理" class="headerlink" title="3.3.1工作原理"></a><strong>3.3.1工作原理</strong></h5><p>Orderer 节点（Ordering Service Node，OSN）在网络中起到代理作用，多个 Orderer 节点 </p><p>会连接到 Kafka 集群，利用 Kafka 的共识功能，完成对网络中交易的排序和打包成区块的工 </p><p>作。</p><p>Fabric 网络提供了多通道特性，为了支持这一特性，同时保障每个 Orderer 节点上数据的一 </p><p>致性，排序服务进行了一些特殊设计。 </p><p>对于每个通道，Orderer 将其映射到 Kafka 集群中的一个 topic （topic 名称与 channelID 相 </p><p>同）上。由于 Orderer 目前并没有使用 Kafka Topic 的多分区负载均衡特性，默认每个 topic </p><p>只创建了一个分区（0 号分区）。 </p><p>此外，Orderer 还在本地维护了针对每个通道的账本（区块链）结构，其中每个区块包括了一 </p><p>组排序后的交易消息，并且被分割为独立区块。  </p><p>核心过程如下所示：</p><p><img src="D:\其他\区块链研究\区块链笔记\orderer核心过程.jpg" style="zoom:150%"></p><p>​                                                      Orderer 节点核心过程</p><ul><li>客户端通过 gRPC 连接发送交易信息到 Orderer 节点的 Broadcast() 接口。</li><li>Orderer 节点收到请求后，提取消息进行解析、检查，通过检查后封装为 Kafka 消息，通过 Produce 接口发送到 Kakfa 集群对应的 topic 分区中。</li><li>当前收到消息数达到 BatchSize.MaxMessageCount 或消息尺寸过大，或超时时间达到 BatchTimeout，则发送分块消息 TTC-X 到 Kafka。</li><li>Kafka 集群维护多个 topic 分区。Kakfa 通过共识算法来确保写入到分区后的消息的一致性。即一旦写入分区，任何 Orderer 节点看到的都是相同的消息队列。</li><li>Orderer 节点在启动后，还默认对本地账本对应的 Kafka 分区数据进行监听，不断从Kafka 拉取（Consume）新的交易消息，并对消息进行处理。满足一定策略情况下（收到 TTX-C 或配置消息）还会将消息打包为区块。</li></ul><h4 id="3-4Orderer-节点启动过程"><a href="#3-4Orderer-节点启动过程" class="headerlink" title="3.4Orderer 节点启动过程"></a><strong>3.4Orderer</strong> 节点启动过程</h4><p>Orderer 节点启动通过 <strong>orderer</strong> 包下的 main() 方法实现，会进一步调用到<strong>orderer/common/server</strong>包中的 <strong>Main()</strong> 方法。</p><p>核心代码如下所示。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main is the entry point of orderer process</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fullCmd := kingpin.MustParse(app.Parse(os.Args[<span class="number">1</span>:]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// "version" command</span></span><br><span class="line">    <span class="keyword">if</span> fullCmd == version.FullCommand() &#123;</span><br><span class="line">        fmt.Println(metadata.GetVersionInfo())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conf := config.Load()</span><br><span class="line">    initializeLoggingLevel(conf)</span><br><span class="line">    initializeLocalMsp(conf)</span><br><span class="line">    </span><br><span class="line">    Start(fullCmd, conf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括配置初始化过程和核心启动过程两个部分：</p><ul><li>config.Load()：从本地配置文件和环境变量中读取配置信息，构建配置树结构。 </li><li>initializeLoggingLevel(conf)：配置日志级别。</li><li>initializeLocalMsp(conf)：配置 MSP 结构。</li><li>Start()：完成启动后的核心工作。 </li></ul><p>核心启动过程都在 orderer/common/server 包中的 Start() 方法，如下图所示。</p><p><img src="D:\其他\区块链研究\区块链笔记\- Orderer 启动的整体过程.jpg" style="zoom:150%"></p><p>​                                                                <em>Orderer</em> 启动的整体过程</p><p>Start() 方法会初始化 gRPC 服务需要的结构，然后启动服务。 </p><p>核心代码如下所示。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(cmd <span class="keyword">string</span>, conf *config.TopLevel)</span></span> &#123;</span><br><span class="line">logger.Debugf(<span class="string">"Start()"</span>)</span><br><span class="line">signer := localmsp.NewSigner()</span><br><span class="line">manager := initializeMultichannelRegistrar(conf, signer)</span><br><span class="line">    server := NewServer(manager, signer, &amp;conf.Debug)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> cmd &#123;</span><br><span class="line">    <span class="keyword">case</span> start.FullCommand(): <span class="comment">// "start" command</span></span><br><span class="line">        logger.Infof(<span class="string">"Starting %s"</span>, metadata.GetVersionInfo())</span><br><span class="line">        initializeProfilingService(conf)</span><br><span class="line">        grpcServer := initializeGrpcServer(conf)</span><br><span class="line">        ab.RegisterAtomicBroadcastServer(grpcServer.Server(), server)</span><br><span class="line">        logger.Info(<span class="string">"Beginning to serve requests"</span>)</span><br><span class="line">        grpcServer.Start()</span><br><span class="line">        <span class="keyword">case</span> benchmark.FullCommand(): <span class="comment">// "benchmark" command</span></span><br><span class="line">        logger.Info(<span class="string">"Starting orderer in benchmark mode"</span>)</span><br><span class="line">        benchmarkServer := performance.GetBenchmarkServer()</span><br><span class="line">        benchmarkServer.RegisterService(server)</span><br><span class="line">        benchmarkServer.Start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括两大部分：</p><ul><li>gRPC 服务结构初始化； </li><li>gRPC 服务启动。</li></ul><h5 id="3-4-1-gRPC-服务结构初始化"><a href="#3-4-1-gRPC-服务结构初始化" class="headerlink" title="3.4.1 gRPC 服务结构初始化"></a><strong>3.4.1 gRPC 服务结构初始化</strong></h5><p>包括创建新的 MSP 签名结构，初始化 Registrar 结构来管理各个账本结构，启动共识过程，以及创建 gRPC 服务端结构。</p><p>核心步骤包括： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signer := localmsp.NewSigner() <span class="comment">// 初始化签名结构</span></span><br><span class="line">manager := initializeMultichannelRegistrar(conf, signer, tlsCallback) <span class="comment">// 初始化账本管理器（Registrar）结构</span></span><br></pre></td></tr></table></figure><p>其中， initializeMultichannelRegistrar(conf, signer) 方法最为关键，核心代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeMultichannelRegistrar</span><span class="params">(conf *config.TopLevel, signer crypto.LocalSigner,callbacks ...<span class="keyword">func</span>(bundle *channelconfig.Bundle)</span>) *<span class="title">multichannel</span>.<span class="title">Registrar</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建操作账本的工厂结构</span></span><br><span class="line">    lf, _ := createLedgerFactory(conf)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是首次启动情况，默认先创建系统通道的本地账本结构</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lf.ChainIDs()) == <span class="number">0</span> &#123;</span><br><span class="line">        logger.Debugf(<span class="string">"There is no chain, hence we must be in bootstrapping"</span>)</span><br><span class="line">        initializeBootstrapChannel(conf, lf)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        logger.Info(<span class="string">"Not bootstrapping because of existing chains"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化共识插件，共识插件负责跟后台的队列打交道</span></span><br><span class="line">    consenters := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]consensus.Consenter)</span><br><span class="line">    consenters[<span class="string">"solo"</span>] = solo.New()</span><br><span class="line">    consenters[<span class="string">"kafka"</span>] = kafka.New(conf.Kafka.TLS, conf.Kafka.Retry, conf.Kafka.Version, conf.Kafka.Verbose)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建各个账本的管理器（Registrar）结构，并启动共识过程</span></span><br><span class="line">    <span class="keyword">return</span> multichannel.NewRegistrar(lf, consenters, signer, callbacks...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用传入的配置信息和签名信息完成如下步骤：</p><ul><li>创建账本操作的工厂结构；</li><li>如果是新启动情况，利用给定的系统初始区块文件初始化系统通道的相关结构；</li><li>完成共识插件（包括 solo 和 kafka 两种）的初始化；</li><li><strong>multichannel.NewRegistrar(lf, consenters, signer)</strong> 方法会扫描本地账本数据（此时至少已存在系统通道），创建 Registrar 结构，并为每个账本都启动共识（如 Kafka 排序）过程。</li></ul><p>说明：<em>Registrar</em> 结构（位于 <em>orderer.common.multichannel</em> 包）是 <em>Orderer</em> 组件中最核心的结构，管理了 <em>Orderer</em> 中所有的账本、共识插件等数据结构。 </p><p><strong>3.4.2 创建 Registrar 结构并启动共识过程</strong></p><p>NewRegistrar(lf, consenters, signer) 方法位于 orderer.common.multichannel 包，负责初始化链支持、消息处理器等重要数据结构，并为各个账本启动共识过程。 </p><p>核心代码如下： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">existingChains := ledgerFactory.ChainIDs()</span><br><span class="line"><span class="keyword">for</span> _, chainID := <span class="keyword">range</span> existingChains &#123; <span class="comment">// 启动本地所有的账本结构的共识过程</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := ledgerResources.ConsortiumsConfig(); ok &#123; <span class="comment">// 如果是系统账本（默认在首次启动时会自动创建）</span></span><br><span class="line">        chain := newChainSupport(r, ledgerResources, consenters, signer)</span><br><span class="line">        chain.Processor = msgprocessor.NewSystemChannel(chain, r.templator, msgprocessor.CreateSystemChannelFilters(r, chain))</span><br><span class="line">        r.chains[chainID] = chain</span><br><span class="line">        r.systemChannelID = chainID</span><br><span class="line">        r.systemChannel = chain</span><br><span class="line">        <span class="keyword">defer</span> chain.start() <span class="comment">// 启动共识过程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果是应用账本</span></span><br><span class="line">        chain := newChainSupport(r, ledgerResources, consenters, signer)</span><br><span class="line">        r.chains[chainID] = chain</span><br><span class="line">        chain.start() <span class="comment">// 启动共识过程</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>chain.start()</strong> 方法负责启动共识过程。以 Kafka 共识插件为例，最终以协程方式调用到 <strong>orderer.consensus.kafka</strong> 包中的 <strong>startThread()</strong> 方法，将在后台持续运行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> startThread(chain)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>startThread()</strong> 方法将为指定的账本结构配置共识服务，并将其启动，核心代码包括：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Producer 结构</span></span><br><span class="line">chain.producer, err = setupProducerForChannel(chain.consenter.retryOptions(), chain.haltChan, chain.SharedConfig().KafkaBrokers(), chain.consenter.brokerConfig(), chain.channel)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 CONNECT 消息给 Kafka，如果失败，则退出</span></span><br><span class="line">sendConnectMessage(chain.consenter.retryOptions(), chain.haltChan, chain.producer, chain.channel)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建处理对应 Kafka topic 的 Consumer 结构</span></span><br><span class="line">chain.parentConsumer, err = setupParentConsumerForChannel(chain.consenter.retryOptions(), chain.haltChan, chain.SharedConfig().KafkaBrokers(), chain.consenter.brokerConfig(), chain.channel)</span><br><span class="line"><span class="comment">// 配置从指定 partition 读取消息的 PartitionConsumer 结构</span></span><br><span class="line">chain.channelConsumer, err = setupChannelConsumerForChannel(chain.consenter.retryOptions(), chain.haltChan, chain.parentConsumer, chain.channel, chain.lastOffsetPersisted+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从该链对应的 Kafka 分区不断读取消息，并进行处理过程</span></span><br><span class="line">chain.processMessagesToBlocks()</span><br></pre></td></tr></table></figure><p>主要包括如下步骤：</p><ul><li>创建到 Kafka 集群的 Producer 结构并发送 CONNECT 消息； </li><li>为对应的 topic 创建 Consumer 结构，并配置从指定分区读取消息的 PartitionConsumer结构； </li><li>对链对应的 Kafka 分区中消息的进行循环处理。</li></ul><h5 id="3-4-2-gRPC服务启动"><a href="#3-4-2-gRPC服务启动" class="headerlink" title="3.4.2 gRPC服务启动 "></a><strong>3.4.2 gRPC服务启动 </strong></h5><p>初始化 gRPC 服务结构，完成绑定并启动监听。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 gRPC 服务端结构</span></span><br><span class="line">server := NewServer(manager, signer, &amp;conf.Debug)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 gRPC 服务连接</span></span><br><span class="line">grpcServer := initializeGrpcServer(conf)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 gRPC 服务并启动</span></span><br><span class="line">ab.RegisterAtomicBroadcastServer(grpcServer.Server(), server)</span><br><span class="line">grpcServer.Start()</span><br></pre></td></tr></table></figure><p>其中， NewServer(manager, signer, &amp;conf.Debug) 方法（位于 orderer.common.server 包）最为核心，将 gRPC 相关的服务结构进行初始化，并绑定到 gRPC 请求上。分别响应 Deliver() 和 Broadcast() 两个 gRPC 调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewServer creates an ab.AtomicBroadcastServer based on the broadcast target and ledger Reader</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(r *multichannel.Registrar, _ crypto.LocalSigner, debug *localconfig.Debug)</span> <span class="title">ab</span>.<span class="title">AtomicBroadcastServer</span></span> &#123;</span><br><span class="line">s := &amp;server&#123;</span><br><span class="line">dh: deliver.NewHandlerImpl(deliverSupport&#123;Registrar: r&#125;),</span><br><span class="line">bh: broadcast.NewHandlerImpl(broadcastSupport&#123;Registrar: r&#125;),</span><br><span class="line">        debug: debug,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-Orderer-节点对排序后消息的处理过程"><a href="#3-5-Orderer-节点对排序后消息的处理过程" class="headerlink" title="3.5 Orderer 节点对排序后消息的处理过程"></a><strong>3.5 Orderer</strong> 节点对排序后消息的处理过程</h4><p>经过排序后的消息，可以认为在网络中已经达成了基本的共识。Orderer 会获取这些消息，进行对应处理（包括打包为区块，更新本地账本结构等）。</p><p>以 Kafka 模式为例，Orderer 节点启动后，会调用 <strong>orderer/consensus/kafka</strong> 模块中 <strong>chainImpl</strong> 结构体的 processMessagesToBlocks() ([]uint64, error) 方法，持续获取 Kafka对应分区中的消息。</p><p><strong>主要过程</strong></p><p><strong>chainImpl</strong>  结构体的 <strong>processMessagesToBlocks()</strong>  方法不断从分区中 Consume 消息并进行处理，同时定时发送 TimeToCut 消息。</p><p>处理消息类型包括 Connect 消息（Producer 启动后发出）、TimeToCut 消息和 Regular 消息（Fabric 消息）。分别调用对应方法进行处理，主要流程如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-chain.haltChan: <span class="comment">// 链故障了，退出</span></span><br><span class="line">        <span class="keyword">case</span> kafkaErr := &lt;-chain.channelConsumer.Errors(): <span class="comment">//获取 Kakfa 消息发生错误</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-chain.errorChan: <span class="comment">// 连接关闭，不进行任何操作</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="comment">//其它错误，OutofRange，关闭 errorChan；否则进行超时重连</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-chain.errorChan: <span class="comment">// 连接仍然关闭，尝试后台进行重连</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> &lt;-topicPartitionSubscriptionResumed: <span class="comment">// 继续</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-deliverSessionTimedOut: <span class="comment">//访问超时，尝试后台进行重连</span></span><br><span class="line">        <span class="keyword">case</span> in, ok := &lt;-chain.channelConsumer.Messages(): <span class="comment">// 核心过程：成功读取到 Kafka消息，进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> msg.Type.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> *ab.KafkaMessage_Connect: <span class="comment">// Kafka 连接消息，忽略</span></span><br><span class="line">            <span class="keyword">case</span> *ab.KafkaMessage_TimeToCut: <span class="comment">// TTC，打包现有的一批消息为区块</span></span><br><span class="line">            <span class="keyword">case</span> *ab.KafkaMessage_Regular: <span class="comment">// 核心处理：Fabric 相关消息，包括配置更新、应用通道交易等</span></span><br><span class="line">            chain.processRegular(msg.GetRegular(), in.Offset)</span><br><span class="line">            <span class="keyword">case</span> &lt;-chain.timer: <span class="comment">//定期发出 TimeToCut 消息到 Kafka</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="3-5-1-Fabric-相关消息的处理"><a href="#3-5-1-Fabric-相关消息的处理" class="headerlink" title="3.5.1 Fabric 相关消息的处理"></a><strong>3.5.1 Fabric 相关消息的处理</strong></h5><p>对于 Fabric 相关消息（包括交易消息和配置消息），具体会调用 chainImpl 结构体的 <strong>processRegular(regularMessage <em>ab.KafkaMessageRegular, receivedOffset int64) error</em></strong>  方法进行处理。</p><p>该方法的核心代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">processRegular</span><span class="params">(regularMessage *ab.KafkaMessageRegular, receivedOffset <span class="keyword">int64</span>)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">env := &amp;cb.Envelope&#123;&#125;</span><br><span class="line">proto.Unmarshal(regularMessage.Payload, env) <span class="comment">// 从载荷中解析出信封结构</span></span><br><span class="line"><span class="keyword">switch</span> regularMessage.Class &#123;</span><br><span class="line"><span class="keyword">case</span> ab.KafkaMessageRegular_NORMAL: <span class="comment">// 普通交易消息</span></span><br><span class="line">chain.ProcessNormalMsg(env) <span class="comment">// 检查消息合法性，分应用链和系统链两种情况</span></span><br><span class="line">commitNormalMsg(env) <span class="comment">// 处理交易消息，满足条件则切块，并写入本地账本</span></span><br><span class="line">        <span class="keyword">case</span> ab.KafkaMessageRegular_CONFIG: <span class="comment">// 配置消息，包括通道头部类型为 CONFIG、CONFIG_UPDATE、ORDERER_TRANSACTION 三种</span></span><br><span class="line">        chain.ProcessConfigMsg(env) <span class="comment">//检查消息合法性，分应用链和系统链两种情况</span></span><br><span class="line">        commitConfigMsg(env) <span class="comment">// 切块，写入账本。如果是 ORDERER_TRANSACTION 消息，创建新的应用通道账本；如果是 CONFIG 消息，更新配置。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-5-2-普通交易消息"><a href="#3-5-2-普通交易消息" class="headerlink" title="3.5.2 普通交易消息"></a><strong>3.5.2 普通交易消息</strong></h5><p>普通交易消息，会检查是否满足生成区块的条件，满足则产生区块并写入本地账本结构。通过内部的 <strong>commitNormalMsg(env)</strong> 方法来完成。</p><p>该方法主要调用  <strong>orderer/common/multichannel</strong>  模块中 <strong>BlockWriter</strong> 结构体的 <strong>CreateNextBlock(messages []<em>cb.Envelope) </em>cb.Block</strong> 方法和  <strong>WriteBlock(block *cb.Block, encodedMetadataValue []byte)</strong>   方法。 </p><p><strong>CreateNextBlock(messages []<em>cb.Envelope) </em>cb.Block</strong> 方法基本过程十分简单，创建新的区块，将传入的交易的信封结构直接序列化到 block.Data.Data[] 域中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/multichannel/blockwriter.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BlockWriter)</span> <span class="title">CreateNextBlock</span><span class="params">(messages []*cb.Envelope)</span> *<span class="title">cb</span>.<span class="title">Block</span></span> &#123;</span><br><span class="line">    previousBlockHash := bw.lastBlock.Header.Hash()</span><br><span class="line">    </span><br><span class="line">    data := &amp;cb.BlockData&#123;</span><br><span class="line">        Data: <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="built_in">len</span>(messages)),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">for</span> i, msg := <span class="keyword">range</span> messages &#123; </span><br><span class="line">        data.Data[i], err = proto.Marshal(msg) </span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; </span><br><span class="line">            logger.Panicf(<span class="string">"Could not marshal envelope: %s"</span>, err) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    block := cb.NewBlock(bw.lastBlock.Header.Number+<span class="number">1</span>, previousBlockHash) </span><br><span class="line">    block.Header.DataHash = data.Hash() </span><br><span class="line">    block.Data = data </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>WriteBlock(block *cb.Block, encodedMetadataValue []byte)</strong>  方法则将 Kafka 相关的元数据也附加到区块结构中，添加区块的签名、最新配置的签名，并写入到本地账本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/multichannel/blockwriter.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BlockWriter)</span> <span class="title">WriteBlock</span><span class="params">(block *cb.Block, encodedMetadataValue []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    bw.committingBlock.Lock()</span><br><span class="line">    bw.lastBlock = block</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> bw.committingBlock.Unlock()</span><br><span class="line">        bw.commitBlock(encodedMetadataValue)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kafka 相关的元数据（KafkaMetadata）包括：</p><ul><li>LastOffsetPersisted：上次消息的偏移量；</li><li>LastOriginalOffsetProcessed：本条消息被重复处理时，最新的偏移量；</li><li>LastResubmittedConfigOffset：上次提交的配置消息的偏移量。</li></ul><h5 id="3-5-3-配置交易消息"><a href="#3-5-3-配置交易消息" class="headerlink" title="3.5.3 配置交易消息"></a><strong>3.5.3 配置交易消息</strong></h5><p>首先会检查消息中配置版本号是否跟当前链上的配置版本号一致。如果不一致，则会更新后生成新的配置信封消息，扔回到后端的共识模块（如 Kafka），并且阻塞新的 Broadcast 消息直到重新提交的消息得到处理。代码片段如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go</span></span><br><span class="line"><span class="keyword">if</span> regularMessage.ConfigSeq &lt; seq &#123; <span class="comment">// 消息中配置版本并非最新版本</span></span><br><span class="line">    configEnv, configSeq, err := chain.ProcessConfigMsg(env)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// For both messages that are ordered for the first time or re-ordered, we set original offset</span></span><br><span class="line">    <span class="comment">// to current received offset and re-order it.</span></span><br><span class="line">    <span class="keyword">if</span> err := chain.configure(configEnv, configSeq, receivedOffset); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"error re-submitting config message because = %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    chain.lastResubmittedConfigOffset = receivedOffset <span class="comment">// Keep track of last resubmitted message offset</span></span><br><span class="line">    chain.doneReprocessingMsgInFlight = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">//Create the channel to block ingress messages</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果版本一致，则调用内部的 commitConfigMsg(env) 方法根据信封结构来产生区块。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">commitConfigMsg := <span class="function"><span class="keyword">func</span><span class="params">(message *cb.Envelope, newOffset <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    batch := chain.BlockCutter().Cut() <span class="comment">// 尝试把收到的交易汇总</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> batch != <span class="literal">nil</span> &#123; <span class="comment">// 如果已经积累了一些交易，则先把它们打包为区块</span></span><br><span class="line">        block := chain.CreateNextBlock(batch)</span><br><span class="line">        metadata := utils.MarshalOrPanic(&amp;ab.KafkaMetadata&#123;</span><br><span class="line">            LastOffsetPersisted: receivedOffset - <span class="number">1</span>,</span><br><span class="line">            LastOriginalOffsetProcessed: chain.lastOriginalOffsetProcessed,</span><br><span class="line">            LastResubmittedConfigOffset: chain.lastResubmittedConfigOffset,</span><br><span class="line">        &#125;)</span><br><span class="line">        chain.WriteBlock(block, metadata)</span><br><span class="line">        chain.lastCutBlockNumber++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    chain.lastOriginalOffsetProcessed = newOffset</span><br><span class="line">    block := chain.CreateNextBlock([]*cb.Envelope&#123;message&#125;) <span class="comment">// 将配置交易生成区块</span></span><br><span class="line">    metadata := utils.MarshalOrPanic(&amp;ab.KafkaMetadata&#123;</span><br><span class="line">        LastOffsetPersisted: receivedOffset,</span><br><span class="line">        LastOriginalOffsetProcessed: chain.lastOriginalOffsetProcessed,</span><br><span class="line">        LastResubmittedConfigOffset: chain.lastResubmittedConfigOffset,</span><br><span class="line">    &#125;)</span><br><span class="line">    chain.WriteConfigBlock(block, metadata) <span class="comment">// 添加区块到系统链</span></span><br><span class="line">    chain.lastCutBlockNumber++</span><br><span class="line">    chain.timer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每个配置消息会单独生成区块。因此，如果之前已经收到了一些普通交易消息，会先把这些消息生成区块。</p><p>接下来，调用 orderer/common/multichannel 模块中 BlockWriter 结构体的 <strong>CreateNextBlock(messages []<em>cb.Envelope) </em>cb.Block</strong> 方法和   <strong>WriteConfigBlock(block *cb.Block, encodedMetadataValue []byte)</strong>  方法来分别打包区块和更新账本结构，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go</span></span><br><span class="line">chain.lastOriginalOffsetProcessed = newOffset</span><br><span class="line">block := chain.CreateNextBlock([]*cb.Envelope&#123;message&#125;)</span><br><span class="line">metadata := utils.MarshalOrPanic(&amp;ab.KafkaMetadata&#123;</span><br><span class="line">    LastOffsetPersisted: receivedOffset,</span><br><span class="line">    LastOriginalOffsetProcessed: chain.lastOriginalOffsetProcessed,</span><br><span class="line">    LastResubmittedConfigOffset: chain.lastResubmittedConfigOffset,</span><br><span class="line">&#125;)</span><br><span class="line">chain.WriteConfigBlock(block, metadata)</span><br><span class="line">chain.lastCutBlockNumber++</span><br><span class="line">chain.timer = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>其中， WriteConfigBlock() 方法执行解析消息和处理的主要逻辑，核心代码如下所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/multichannel/blockwriter.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BlockWriter)</span> <span class="title">WriteConfigBlock</span><span class="params">(block *cb.Block, encodedMetadataValue []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 解析配置交易信封结构，每个区块中只有一个配置交易</span></span><br><span class="line">    ctx, err := utils.ExtractEnvelope(block, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析载荷和通道头结构</span></span><br><span class="line">    payload, err := utils.UnmarshalPayload(ctx.Payload)</span><br><span class="line">    chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按照配置交易内容，执行对应操作</span></span><br><span class="line">    <span class="keyword">switch</span> chdr.Type &#123; <span class="comment">// 排序后只有 ORDERER_TRANSACTION 和 CONFIG 两种类型消息</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int32</span>(cb.HeaderType_ORDERER_TRANSACTION): <span class="comment">// 新建应用通道</span></span><br><span class="line">        newChannelConfig, err := utils.UnmarshalEnvelope(payload.Data)</span><br><span class="line">        <span class="comment">// 创建新的本地账本结构并启动对应的轮询消息过程，实际调用 orderer/common/multichann el.Registrar.newChain(configtx *cb.Envelope)</span></span><br><span class="line">        bw.registrar.newChain(newChannelConfig)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int32</span>(cb.HeaderType_CONFIG): <span class="comment">// 更新通道配置</span></span><br><span class="line">        configEnvelope, err := configtx.UnmarshalConfigEnvelope(payload.Data)</span><br><span class="line">        bundle, err := bw.support.CreateBundle(chdr.ChannelId, configEnvelope.Config)</span><br><span class="line">        bw.support.Update(bundle)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将区块写入到本地账本结构 </span></span><br><span class="line">    bw.WriteBlock(block, encodedMetadataValue)</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-Orderer-节点-Broadcast-请求的处理"><a href="#3-6-Orderer-节点-Broadcast-请求的处理" class="headerlink" title="3.6 Orderer 节点 Broadcast 请求的处理"></a><strong>3.6 Orderer</strong> 节点 <strong>Broadcast</strong> 请求的处理</h4><p>Broadcast，意味着客户端将请求消息（例如完成背书后的交易）通过 gRPC 接口发送给 </p><p>Ordering 服务。Orderer 进行本地验证处理后，会转化为入队消息发给后端共识模块（如 </p><p>Kafka）。 </p><p>发给 Orderer 的 Broadcast 请求消息包括链码的实例化、调用；通道的创建、更新。 </p><p>来自客户端的请求消息，会首先交给 orderer.common.server 包中 server 结构体的 </p><p>Broadcast(srv ab.AtomicBroadcast_BroadcastServer) error 方法处理。该方法主要会调用到 </p><p>orderer.common.broadcast 包中 handlerImpl 结构的 Handle(srv </p><p>ab.AtomicBroadcast_BroadcastServer) error 方法。 </p><p>handlerImpl 结构体十分重要，在 Orderer 整个处理过程中都会用到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> handlerImpl <span class="keyword">struct</span> &#123; </span><br><span class="line"></span><br><span class="line">sm ChannelSupportRegistrar </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bh *handlerImpl)</span> <span class="title">Handle</span><span class="params">(srv ab.AtomicBroadcast_BroadcastServer)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>Broadcast 请求的整体处理过程如下图所示。</p><p><img src="D:\其他\区块链研究\区块链笔记\Orderer节点broadcast处理过程.jpg" style="zoom: 150%"></p><p>​                                                                        图  - Orderer 节点 <em>Broadcast</em> 处理过程</p><p><strong>Handle(srv ab.AtomicBroadcast_BroadcastServer) error</strong> 方法会开启一个循环来从 srv 中读取请求消息并进行处理，直到结束。主要包括解析消息、处理消息（包括配置消息和非配置消息）和返回响应三个步骤。</p><p>核心代码如下所示（位于 <strong>orderer/common/broadcast/broadcast.go#handlerImpl.Handle()</strong> ）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    msg, error := srv.Recv() <span class="comment">// 从请求中提取一个 Envelope 消息</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析消息：判断是否为配置消息；获取对应本地账本结构：由通道头部中指定的通道 ID 决定，本地对应账 本结构不存在时（如新建应用通道）则由系统通道来处理</span></span><br><span class="line">    chdr, isConfig, processor, err := bh.sm.BroadcastChannelSupport(msg)</span><br><span class="line">    <span class="comment">// 检查是否被之前重新提交的消息阻塞</span></span><br><span class="line">    processor.WaitReady()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对应的通道结构对消息进行处理</span></span><br><span class="line">    <span class="keyword">if</span> !isConfig &#123; <span class="comment">// 普通消息</span></span><br><span class="line">        configSeq, err := processor.ProcessNormalMsg(msg) <span class="comment">//消息检查</span></span><br><span class="line">        processor.Order(msg, configSeq) <span class="comment">//入队列操作</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 配置消息，目前只有 CONFIG_UPDATE 类型，如创建、更新通道，或获取配置区块</span></span><br><span class="line">        config, configSeq, err := processor.ProcessConfigUpdateMsg(msg)<span class="comment">// 合并配置更新消息</span></span><br><span class="line">        processor.Configure(config, configSeq) <span class="comment">//入队列操作：相关处理后发给 Kafka</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    srv.Send(&amp;ab.BroadcastResponse&#123;Status: cb.Status_SUCCESS&#125;) <span class="comment">// 返回响应消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分为三个步骤： </p><ul><li>解析消息：判断是否为配置消息，决定消息应由哪个通道结构进行处理，注意对于创建应用通道消息，处理器指定为系统的通道结构；</li><li>处理消息：选用对应的通道结构对消息进行处理，包括普通消息和配置消息；</li><li>返回响应消息给请求方。</li></ul><h5 id="3-6-1-解析消息"><a href="#3-6-1-解析消息" class="headerlink" title="3.6.1 解析消息"></a><strong>3.6.1 解析消息</strong></h5><p>首先，解析消息，获取消息通道头、是否为配置消息、获取对应处理器结构（链结构）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdr, isConfig, processor, err := bh.sm.BroadcastChannelSupport(msg)</span><br></pre></td></tr></table></figure><p>实际上，会映射到 <strong>orderer.common.server</strong> 包中 <strong>broadcastSupport</strong> 结构体的 <strong>BroadcastChannelSupport(msg *cb.Envelope) (*cb.ChannelHeader, bool,broadcast.ChannelSupport, error)</strong> 方法，进一步调用到 orderer.common.multichannel 包中 Registrar 结构体的对应方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/multichannel/registrar.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Registrar)</span> <span class="title">BroadcastChannelSupport</span><span class="params">(msg *cb.Envelope)</span> <span class="params">(*cb.ChannelHeader, <span class="keyword">bool</span>, *ChainSupport, error)</span></span> &#123;</span><br><span class="line">    chdr, err := utils.ChannelHeader(msg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"could not determine channel ID: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cs, ok := r.chains[chdr.ChannelId] <span class="comment">// 应用通道、系统通道</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        cs = r.systemChannel <span class="comment">// 空，则默认为系统通道，如收到新建应用通道请求时，Orderer 本地并没有该应用通道结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    isConfig := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">switch</span> cs.ClassifyMsg(chdr) &#123; <span class="comment">// 只有 CONFIG_UPDATE 会返回 ConfigUpdateMsg</span></span><br><span class="line">    <span class="keyword">case</span> msgprocessor.ConfigUpdateMsg: <span class="comment">// CONFIG_UPDATE 消息，包括创建、更新通道，获取配置区块等</span></span><br><span class="line">        isConfig = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> chdr, isConfig, cs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel 头部从消息信封结构中解析出来；是否为配置信息根据消息头中通道类型进行判断（是否为 cb.HeaderType_CONFIG_UPDATE）；通过字典结构查到对应的 ChainSupport 结构（应用通道、系统通道）作为处理器。之后，利用解析后的结果，分别对不同类型的消息（普通消息、配置消息）进行不同处理。</p><p>对于普通交易消息，主要执行如下两个操作：消息格式检查和入队列操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">configSeq, err := processor.ProcessNormalMsg(msg) <span class="comment">//消息检查</span></span><br><span class="line">processor.Order(msg, configSeq) <span class="comment">//入队列操作</span></span><br></pre></td></tr></table></figure><p>消息检查方法会映射到 <strong>orderer.common.msgprocessor</strong> 包中 <strong>StandardChannel/SystemChannel</strong> 结构体的ProcessNormalMsg(env *cb.Envelope) (configSequint64, err error) 方法，以应用通道为例，实现如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/msgprocessor/standardchannel.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StandardChannel)</span> <span class="title">ProcessNormalMsg</span><span class="params">(env *cb.Envelope)</span> <span class="params">(configSeq <span class="keyword">uint64</span>, err error)</span></span>&#123;</span><br><span class="line">    configSeq = s.support.Sequence() <span class="comment">// 获取配置的序列号，映射到 common.configtx 包中 configManager 结构体的对应方法</span></span><br><span class="line">    err = s.filters.Apply(env) <span class="comment">// 进行过滤检查，实现为 orderer.common.msgprocessor 包中 RuleSet 结构体的对应方法。</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，过滤器会在创建 ChainSupport 结构时候初始化：</p><ul><li>应用通道：orderer.common.mspprocessor 包中的CreateStandardChannelFilters(filterSupport channelconfig.Resources) *RuleSet 方法，包括 EmptyRejectRule、SizeFilter 和SigFilter（ChannelWriters 角色）。</li><li>系统通道：orderer.common.mspprocessor 包中的CreateSystemChannelFilters(chainCreator ChainCreator, ledgerResourceschannelconfig.Resources) *RuleSet 方法，包括 <strong>EmptyRejectRule</strong>、<strong>SizeFilter</strong>、<strong>SigFilter（ChannelWriters 角色）</strong>和 <strong>SystemChannelFilter</strong>。 </li></ul><p><strong>入队列操作</strong> </p><p>入队列操作会根据 consensus 配置的不同映射到 orderer.consensus.solo 包或orderer.consensus.kafka 包中的方法。 </p><p>以 kafka 情况为例，会映射到 chainImpl 结构体的对应方法。该方法会将消息进一步封装为<em>sarama.ProducerMessage</em> 类型消息，通过 enqueue 方法发给 Kafka 后端。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go#chainImpl.Order(）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">Order</span><span class="params">(env *cb.Envelope, configSeq <span class="keyword">uint64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> chain.order(env, configSeq, <span class="keyword">int64</span>(<span class="number">0</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">order</span><span class="params">(env *cb.Envelope, configSeq <span class="keyword">uint64</span>, originalOffset <span class="keyword">int64</span> )</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    marshaledEnv, err := utils.Marshal(env)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot enqueue, unable to marshal envelope because = %s"</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !chain.enqueue(newNormalMessage(marshaledEnv, configSeq, originalOffset)) &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot enqueue"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-2-处理配置交易消息"><a href="#3-6-2-处理配置交易消息" class="headerlink" title="3.6.2 处理配置交易消息"></a><strong>3.6.2 处理配置交易消息</strong></h5><p>对于配置交易消息（CONFIG_UPDATE 类型消息，包括创建、更新通道，获取配置区块等），处理过程与正常消息略有不同，包括合并配置更新消息和入队列操作两个操作。</p><p><strong>合并配置更新</strong></p><p>主要过程包括如下两个步骤：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config, configSeq, err := processor.ProcessConfigUpdateMsg(msg) <span class="comment">// 合并配置更新，生成新的配置信封结构</span></span><br><span class="line">processor.Configure(config, configSeq) <span class="comment">//入队列操作，将生成的配置信封结构消息扔给后端队列（如Kafka)</span></span><br></pre></td></tr></table></figure><p>其中，合并配置更新消息方法会映射到 <strong>orderer.common.msgprocessor</strong> 包中<strong>StandardChannel/SystemChannel</strong> 结构体的 <strong>ProcessConfigUpdateMsg(env *cb.Envelope)(configSeq uint64, err error)</strong> 方法，计算合并后的配置和配置编号。</p><p>以应用通道为例，实现如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/msgprocessor/standardchannel.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StandardChannel)</span> <span class="title">ProcessConfigUpdateMsg</span><span class="params">(env *cb.Envelope)</span> <span class="params">(config *cb.Envelop e, configSeq <span class="keyword">uint64</span>, err error)</span></span> &#123;</span><br><span class="line">    logger.Debugf(<span class="string">"Processing config update message for channel %s"</span>, s.support.ChainID())</span><br><span class="line">    seq := s.support.Sequence() <span class="comment">// 获取当前配置的版本号</span></span><br><span class="line">    err = s.filters.Apply(env) <span class="comment">// 校验权限，是否可以更新配置</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据输入的更新配置交易消息生成配置信封结构：Config 为更新后配置字典；LastUpdate 为输入的更新配置交易</span></span><br><span class="line">    <span class="comment">// 最终调用 `common/configtx` 包下 `ValidatorImpl.ProposeConfigUpdate()` 方法。</span></span><br><span class="line">    configEnvelope, err := s.support.ProposeConfigUpdate(env)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成签名的配置信封结构，通道头类型为 HeaderType_CONFIG。即排序后消息类型将由 CONFIG_UPDATE 变更为 CONFIG</span></span><br><span class="line">    config, err = utils.CreateSignedEnvelope(cb.HeaderType_CONFIG, s.support.ChainID(), s.support.Signer(), configEnvelope, msgVersion, epoch)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    err = s.filters.Apply(config) <span class="comment">// 校验生成的配置消息是否合法</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config, seq, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于系统通道情况，除了调用普通通道结构的对应方法来处理普通的更新配置交易外，还会负责新建应用通道请求。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/common/msgprocessor/systemchannel.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SystemChannel)</span> <span class="title">ProcessConfigUpdateMsg</span><span class="params">(envConfigUpdate *cb.Envelope)</span> <span class="params">(config *cb.Envelope, configSeq <span class="keyword">uint64</span>, err error)</span></span> &#123;</span><br><span class="line">    channelID, err := utils.ChannelID(envConfigUpdate)</span><br><span class="line">    <span class="keyword">if</span> channelID == s.support.ChainID() &#123; <span class="comment">// 更新系统通道的配置交易，与普通通道相同处理</span></span><br><span class="line">        <span class="keyword">return</span> s.StandardChannel.ProcessConfigUpdateMsg(envConfigUpdate)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从系统通道中获取当前最新的配置</span></span><br><span class="line">    <span class="comment">// orderer/common/msgprocessor/systemchannel.go#DefaultTemplator.NewChannelConfig()</span></span><br><span class="line">    bundle, err := s.templator.NewChannelConfig(envConfigUpdate)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并来自客户端的配置更新信封结构，创建配置信封结构 ConfigEnvelope</span></span><br><span class="line">    newChannelConfigEnv, err := bundle.ConfigtxValidator().ProposeConfigUpdate(envConf igUpdate)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 封装新的签名信封结构，其 Payload.Data 是 newChannelConfigEnv</span></span><br><span class="line">    newChannelEnvConfig, err := utils.CreateSignedEnvelope(cb.HeaderType_CONFIG, channelID, s.support.Signer(), newChannelConfigEnv, msgVersion, epoch)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理新建应用通道请求，封装为 ORDERER_TRANSACTION 类型消息</span></span><br><span class="line">    wrappedOrdererTransaction, err := utils.CreateSignedEnvelope(cb.HeaderType_ORDERER_TRANSACTION, s.support.ChainID(), s.support.Signer(), newChannelEnvConfig, msgVersion, epoch)</span><br><span class="line">    s.StandardChannel.filters.Apply(wrappedOrdererTransaction) <span class="comment">// 再次校验配置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回封装后的签名信封结构</span></span><br><span class="line">    <span class="keyword">return</span> wrappedOrdererTransaction, s.support.Sequence(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入队列操作会根据 consensus 配置的不同映射到 orderer.consensus.solo 包或 orderer.consensus.kafka 包中的方法。以 kafka 情况为例，会映射到 chainImpl 结构体的 Configure(config <em>cb.Envelope, configSeq uint64) 方法。该方法会调用 configure(config </em>cb.Envelope, configSeq uint64, originalOffset int64) 方法，将消息进一步封装为 KafkaMessage_Regular 类型消息，通过 enqueue 方法发给 Kafka 后端。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">configure</span><span class="params">(config *cb.Envelope, configSeq <span class="keyword">uint64</span>, originalOffset <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    marshaledConfig, err := utils.Marshal(config)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot enqueue, unable to marshal config because %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 封装为 `KafkaMessageRegular_CONFIG` 类型消息，并通过 producer 发给 Kafka</span></span><br><span class="line">    <span class="keyword">if</span> !chain.enqueue(newConfigMessage(marshaledConfig, configSeq, originalOffset)) &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot enqueue"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，封装为 KafkaMessageRegular_CONFIG 类型消息过程十分简单。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orderer/consensus/kafka/chain.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newConfigMessage</span><span class="params">(config []<span class="keyword">byte</span>, configSeq <span class="keyword">uint64</span>, originalOffset <span class="keyword">int64</span>)</span> *<span class="title">ab</span>.<span class="title">KafkaMessage</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ab.KafkaMessage&#123;</span><br><span class="line">        Type: &amp;ab.KafkaMessage_Regular&#123;</span><br><span class="line">            Regular: &amp;ab.KafkaMessageRegular&#123;</span><br><span class="line">                Payload: config,</span><br><span class="line">                ConfigSeq: configSeq,</span><br><span class="line">                Class: ab.KafkaMessageRegular_CONFIG,</span><br><span class="line">                OriginalOffset: originalOffset,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后 Orderer 将再次从 Kakfa 获取到共识（这里主要是排序）完成的 </p><p>KafkaMessageRegular_CONFIG 消息，进行解析和处理。具体可以参考<strong>Orderer 节点对排序后消息的处理过程</strong>。</p><h5 id="3-6-3-返回响应"><a href="#3-6-3-返回响应" class="headerlink" title="3.6.3 返回响应"></a><strong>3.6.3 返回响应</strong></h5><p>如果处理成功，则返回成功响应消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srv.Send(&amp;ab.BroadcastResponse&#123;Status: cb.Status_SUCCESS&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-7-Orderer-节点-Deliver-请求的处理"><a href="#3-7-Orderer-节点-Deliver-请求的处理" class="headerlink" title="3.7 Orderer 节点 Deliver 请求的处理"></a><strong>3.7 Orderer</strong> 节点 <strong>Deliver</strong> 请求的处理</h4><p>Deliver，意味着客户端通过 gRPC 接口从 Ordering 服务获取数据（例如指定区块的数据）。 </p><p>Orderer 节点收到请求消息，会首先交给 <strong>orderer.common.server</strong> 包中 server 结构体的 </p><p><strong>Deliver(srv ab.AtomicBroadcast_DeliverServer) error</strong> 方法处理。该方法进一步调用 </p><p><strong>orderer.common.deliver</strong> 包中 <strong>deliverServer</strong> 结构的 Handle(srv ab.AtomicBroadcast_DeliverServer) error 方法进行处理。 </p><p>deliverServer 结构体十分重要，完成对 Deliver 请求的处理过程。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> deliverServer <span class="keyword">struct</span> &#123; </span><br><span class="line"></span><br><span class="line">sm SupportManager </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *deliverServer)</span> <span class="title">Handle</span><span class="params">(srv ab.AtomicBroadcast_DeliverServer)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>整体处理过程如下图所示。</p><p><img src="D:\其他\区块链研究\区块链笔记\Orderer 节点 Deliver 处理过程.jpg" style="zoom:150%"></p><p>​                                                                <em>Orderer</em> 节点 <em>Deliver</em> 处理过程</p><p>Handle(srv ab.AtomicBroadcast_DeliverServer) error 方法会开启一个循环来从 srv 中不断读 取请求消息并进行处理，直到结束。 </p><p>核心代码如下所示，包括提取消息和对消息进行处理两个步骤。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">envelope, err := srv.Recv() <span class="comment">// 从请求中提取一个 Envelope 消息</span></span><br><span class="line">    ds.deliverBlocks(srv, envelope) <span class="comment">// 对消息进行处理并答复，核心过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，对单个请求的处理都在 deliverBlocks(srv ab.AtomicBroadcast_DeliverServer, envelope </p><p>*cb.Envelope) 方法中。该方法的处理过程包括<strong>解析消息</strong>、<strong>检查合法性</strong>、<strong>发送区块</strong>以及<strong>返回响</strong> </p><p><strong>应</strong>四个步骤。</p><h5 id="3-7-1-解析消息"><a href="#3-7-1-解析消息" class="headerlink" title="3.7.1 解析消息"></a><strong>3.7.1 解析消息</strong></h5><p>首先，从请求的 Envelope 结构中提取载荷（Payload），进一步从载荷中提取通道头部信息。利用通道头部信息获取对应的本地链结构，并获取当前最新的配置序列号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取载荷</span></span><br><span class="line">payload, err := utils.UnmarshalPayload(envelope.Payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取通道头</span></span><br><span class="line">chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链结构，映射到 orderer.common.multichannel 包中 Registrar 结构体中对应方法</span></span><br><span class="line">chain, ok := ds.sm.GetChain(chdr.ChannelId)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前配置序列号</span></span><br><span class="line">lastConfigSequence := chain.Sequence()</span><br></pre></td></tr></table></figure><h5 id="3-7-2-检查合法性"><a href="#3-7-2-检查合法性" class="headerlink" title="3.7.2 检查合法性"></a><strong>3.7.2 检查合法性</strong></h5><p>包括对权限和 seekInfo 数据进行检查。首先，检查请求方是否对通道拥有读权限。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sf := msgprocessor.NewSigFilter(policies.ChannelReaders, chain.PolicyManager())</span><br><span class="line"><span class="keyword">if</span> err := sf.Apply(envelope); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logger.Warningf(<span class="string">"[channel: %s] Received unauthorized deliver request from %s: %s"</span>,chdr.ChannelId, addr, err)</span><br><span class="line">    <span class="keyword">return</span> sendStatusReply(srv, cb.Status_FORBIDDEN)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，从 Envelope 结构的 payload.data 域中解析出 seekInfo 结构，并检查其合法性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">proto.Unmarshal(payload.Data, seekInfo)</span><br><span class="line">chain.Reader().Iterator(seekInfo.Start)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 seekInfo 的</span></span><br><span class="line">cursor, number := chain.Reader().Iterator(seekInfo.Start)</span><br><span class="line"><span class="keyword">switch</span> stop := seekInfo.Stop.Type.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *ab.SeekPosition_Oldest: <span class="comment">// 截止到最早的区块</span></span><br><span class="line">    stopNum = number</span><br><span class="line">    <span class="keyword">case</span> *ab.SeekPosition_Newest: <span class="comment">// 截止到最新的区块</span></span><br><span class="line">    stopNum = chain.Reader().Height() - <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> *ab.SeekPosition_Specified: <span class="comment">// 截止到特定的区块</span></span><br><span class="line">    stopNum = stop.Specified.Number</span><br><span class="line">    <span class="keyword">if</span> stopNum &lt; number &#123;</span><br><span class="line">        logger.Warningf(<span class="string">"[channel: %s] Received invalid seekInfo message from %s: star t number %d greater than stop number %d"</span>, chdr.ChannelId, addr, number, stopNum)</span><br><span class="line">        <span class="keyword">return</span> sendStatusReply(srv, cb.Status_BAD_REQUEST)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-7-3-发送区块"><a href="#3-7-3-发送区块" class="headerlink" title="3.7.3 发送区块"></a><strong>3.7.3 发送区块</strong></h5><p>在指定的起始和截止范围内，逐个从本地账本读取区块，并发送对应的区块数据，核心代码如下所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    block, status := cursor.Next() <span class="comment">// 获取区块</span></span><br><span class="line">    sendBlockReply(srv, block) <span class="comment">// 发送区块</span></span><br><span class="line">    <span class="keyword">if</span> stopNum == block.Header.Number &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-7-4-返回响应"><a href="#3-7-4-返回响应" class="headerlink" title="3.7.4 返回响应"></a><strong>3.7.4 返回响应</strong></h5><p>如果处理成功，则返回成功响应消息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendStatusReply(srv, cb.Status_SUCCESS)</span><br></pre></td></tr></table></figure><h4 id="3-8-客户端执行创建通道"><a href="#3-8-客户端执行创建通道" class="headerlink" title="3.8 客户端执行创建通道"></a>3.8 客户端执行创建通道</h4><p>主要步骤包括： </p><ul><li>客户端调用 sendCreateChainTransaction()，检查指定的配置交易文件，或者利用默认配 </li></ul><p>置，构造一个创建应用通道的配置交易结构，封装为 Envelope，指定 channel 头部类型 </p><p>为 CONFIG_UPDATE。 </p><ul><li>客户端发送配置交易到 Ordering 服务。 </li></ul><ul><li><p>Orderer 收到 CONFIG_UPDATE 消息后，检查指定的通道还不存在，则开始新建过程 </p><p>（参考 orderer/configupdate/configupdate.go 文件），构造该应用通道的初始区块。 </p><ul><li>Orderer 首先检查通道应用（Application）配置中的组织都在创建的联盟 （Consortium）配置组织中。</li><li>之后从系统通道中获取 Orderer 相关的配置，并创建应用通道配置，对应 mod_policy 为系统通道配置中的联盟指定信息。</li><li>接下来根据 CONFIG_UPDATE 消息的内容更新获取到的配置信息。所有配置发生变更后版本号都要更新。</li><li>最后，创建签名 Proposal 消息（头部类型为 ORDERER_TRANSACTION），发送到系统通道中，完成应用通道的创建过程。</li></ul></li><li><p>客户端利用 gRPC 通道从 Orderer 服务获取到该应用通道的初始区块（<strong>具体过程类似fetch 命令）。 </strong></p></li><li><p>客户端将收到的区块写入到本地的 chainID + “.block” 文件。这个文件后续会被需要加入到通道的节点使用。</p></li></ul><h4 id="3-9-客户端执行加入通道"><a href="#3-9-客户端执行加入通道" class="headerlink" title="3.9 客户端执行加入通道"></a>3.9 客户端执行加入通道</h4><p>主要步骤包括： </p><ul><li>客户端首先创建一个 ChaincodeSpec 结构，其 input 中的 Args 第一个参数是 </li></ul><p>CSCC.JoinChain（指定调用配置链码的操作），第二个参数为所加入通道的初始区块。 </p><ul><li><p>利用 ChaincodeSpec 构造一个 ChaincodeInvocationSpec 结构。 </p></li><li><p>利用 ChaincodeInvocationSpec，创建 Proposal 结构并进行签名，channel 头部类型为 </p></li></ul><p>CONFIG。 </p><ul><li>客户端通过 gRPC 将 Proposal 签名后发给 Endorser（所操作的 Peer），调用 </li></ul><p>ProcessProposal(ctx context.Context, in *SignedProposal, opts …grpc.CallOption) </p><p>(*ProposalResponse, error) 方法进行处理，主要通过配置系统链码进行本地链的初始化 </p><p>工作。 </p><ul><li>初始化完成后，即可收到来自通道内的 Gossip 消息等。 </li></ul><p>其中，比较重要的数据结构包括 ChaincodeSpec、ChaincodeInvocationSpec、Proposal </p><p>等。 </p><h4 id="3-10-客户端执行链码安装"><a href="#3-10-客户端执行链码安装" class="headerlink" title="3.10 客户端执行链码安装"></a>3.10 客户端执行链码安装</h4><h5 id="链码安装过程"><a href="#链码安装过程" class="headerlink" title="链码安装过程"></a>链码安装过程</h5><p>​        链码安装主要包括两个部分： </p><ul><li><p>客户端封装安装消息； </p></li><li><p>Peer 节点处理请求。 </p></li></ul><h5 id="3-10-1-客户端封装安装消息"><a href="#3-10-1-客户端封装安装消息" class="headerlink" title="3.10.1  客户端封装安装消息"></a>3.10.1  客户端封装安装消息</h5><p>客户端将链码的源码和环境等内容封装为一个链码安装打包文件（Chaincode Install </p><p>Package，CIP），并传输到指定的 Peer 节点。此过程只需要跟 Peer 节点打交道。 </p><p>主要步骤包括： </p><ul><li><p>首先是构造带签名的提案结构（SignedProposal）。 </p><ul><li><p>调用 InitCmdFactory(isEndorserRequired, isOrdererRequired bool) </p><p>​    (*ChaincodeCmdFactory, error) 方法，初始化 EndoserClient（跟 Peer 通信）、 </p><p>​    BroadcastClient（跟 Orderer 通信）、Signer（签名操作）等辅助结构体。所有链 </p><p>​    码子命令都会执行该过程，会根据需求具体初始化不同的结构。 </p></li><li><p>然后根据命令行参数进行解析，判断是根据传入的打包文件来直接读取 </p><p>​    ChaincodeDeploymentSpec（CDS）结构，还是根据传入参数从本地链码源代码文 </p><p>​    件来构造生成。 </p></li><li><p>以本地重新构造情况为例，首先根据命令行中传入的路径、名称等信息，构造生成 </p><p>ChaincodeSpec（CS）结构。 </p></li><li><p>利用 ChaincodeSpec 结构，结合链码包数据生成一个 ChaincodeDeploymentSpec </p><p>结构（chainID 为空），调用本地的 install(msg proto.Message, cf </p><p>*ChaincodeCmdFactory) error 方法。 </p></li><li><p>install 方法基于传入的 ChaincodeDeploymentSpec 结构，构造一个对生命周期管理 </p><p>系统链码（LSCC）调用的 ChaincodeSpec 结构，其中，Type 为 </p><p>ChaincodeSpec_GOLANG，ChaincodeId.Name 为“lscc”，Input 为 </p><p>“install”+ChaincodeDeploymentSpec。进一步地，构造了一个 LSCC 的 </p><p>ChaincodeInvocationSpec（CIS）结构，对 ChaincodeSpec 结构进行封装。 </p></li><li><p>基于 LSCC 的 ChaincodeInvocationSpec 结构，添加头部结构，生成一个提案 </p><p>（Proposal）结构。其中，通道头部中类型为 ENDORSER_TRANSACTION，TxID </p><p>为对随机数+签名实体，进行 Hash。 </p></li><li><p>对 Proposal 进行签名，转化为一个签名后的提案消息结构 SignedProposal。 </p></li></ul></li></ul><ul><li>将带签名的提案结构通过 EndorserClient 经由 gRPC 通道发送给 Peer 的 </li></ul><p>ProcessProposal(ctx context.Context, in *SignedProposal, opts …grpc.CallOption) </p><p>(*ProposalResponse, error) 接口。 </p><ul><li>Peer 模拟运行生命周期链码的调用交易进行处理，检查格式、签名和权限等，通过则保</li></ul><p>86客户端执行链码安装 存到本地文件系统。 </p><h4 id="3-11客户端执行链码实例化"><a href="#3-11客户端执行链码实例化" class="headerlink" title="3.11客户端执行链码实例化"></a>3.11客户端执行链码实例化</h4><p>主要步骤包括：</p><ul><li>首先，类似链码安装命令，需要创建一个 SignedProposal 消息。注意 instantiate 和upgrade 支持 policy、escc、vscc 等参数。LSCC 的 ChaincodeSpec 结构中，Input 中包括类型（“deploy”）、通道 ID、ChaincodeDeploymentSpec 结构、背书策略、escc 和vscc 等。 </li><li>调用 EndorserClient，发送 gRPC 消息，将签名后的 Proposal 发给指定的 Peer 节点（Endorser），调用 ProcessProposal(ctx context.Context, in *<em>SignedProposal, opts …grpc.CallOption) (</em>*ProposalResponse, error) 方法，进行背书处理。节点会模拟运行LSCC 的调用交易，启动链码容器。实例化成功后会返回 ProposalResponse 消息（其中包括背书签名）。</li><li>根据 Peer 返回的 ProposalResponse 消息，创建一个 SignedTX（Envelop 结构的交易，带有签名）。</li><li>使用 BroadcastClient 将交易消息通过 gRPC 通道发给 Orderer，Orderer 会进行全网排序，并广播给 Peer 进行确认提交。</li></ul><h4 id="3-12-客户端执行链码调用"><a href="#3-12-客户端执行链码调用" class="headerlink" title="3.12 客户端执行链码调用"></a>3.12 客户端执行链码调用</h4><p>基本过程如下： </p><ul><li>首先，也是要创建一个 SignedProposal 消息。根据传入的各种参数，生成 ChaincodeSpec 结构（其中，Input 为传入的调用参数）。然后，根据 ChaincodeSpec、chainID、签名实体等，生成 ChaincodeInvocationSpec 结构。进而封装生成 Proposal 结构（通道头部中类型为ENDORSER_TRANSACTION），并进行签名。</li><li>调用 EndorserClient，发送 gRPC 消息，将签名后的 Proposal 发给指定的 Peer 节点 （Endorser），调用 ProcessProposal(ctx context.Context, in <em>SignedProposal, opts…grpc.CallOption) (</em>*ProposalResponse, error) 方法，进行背书处理。节点会模拟运行链码调用交易，成功后会返回 ProposalResponse 消息（带有背书签名）。</li><li>根据 Peer 返回的 ProposalResponse 消息，创建一个 SignedTX（Envelop 结构的交易，带有签名）。</li><li>使用 BroadcastClient 将交易消息通过 gRPC 通道发给 Orderer 进行全网排序并广播给Peer 进行确认提交。</li></ul><p>注意 invoke 是异步操作，invoke 成功只能保证交易已经进入 Orderer 进行排序，但无法保证 </p><p>最终写到账本中（例如交易未通过 Committer 验证而被拒绝）。需要通过 eventHub 或查询 </p><p>方式来进行确认交易是否最终写入到账本上。 </p><h4 id="3-13-客户端执行链码查询"><a href="#3-13-客户端执行链码查询" class="headerlink" title="3.13 客户端执行链码查询"></a>3.13 客户端执行链码查询</h4><p>主要过程如下:</p><ul><li>根据传入的各种参数，最终构造签名提案，通过 endorserClient 发送给指定的 Peer。</li><li>成功的话，获取到 ProposalResponse，打印出 proposalResp.Response.Payload 内容。</li></ul><p>需要注意 invoke 和 query 的区别，query 不需要创建 SignedTx 发送到 Orderer，而且会返回 </p><p>查询的结果。 </p><h2 id="Fabric词汇"><a href="#Fabric词汇" class="headerlink" title="Fabric词汇"></a>Fabric词汇</h2><h3 id="Anchor-Peer-锚节点"><a href="#Anchor-Peer-锚节点" class="headerlink" title="Anchor Peer - 锚节点"></a>Anchor Peer - 锚节点</h3><p>A peer node on a channel that all other peers can discover and communicate with. Each <a href="https://hyperledgercn.github.io/hyperledgerDocs/glossary/#Member" target="_blank" rel="noopener">Member</a> on a channel has an anchor peer (or multiple anchor peers to prevent single point of failure), allowing for peers belonging to different Members to discover all existing peers on a channel.</p><p>锚节点是通道中能被所有对等节点探测、并能与之进行通信的一种对等节点。通道中的每个成员都有一个（或多个，以防单点故障）锚节点，允许属于不同成员身份的节点来发现通道中存在的其它节点。</p><h3 id="Block-区块"><a href="#Block-区块" class="headerlink" title="Block - 区块"></a>Block - 区块</h3><p>An ordered set of transactions that is cryptographically linked to the preceding block(s) on a channel.</p><p>在一个通道上，（区块是）一组有序交易的集合。区块往往通过密码学手段（Hash 值）连接到前导区块。</p><p> 区块是一组有序的交易集合，在通道中经过加密（哈希加密）后与前序区块连接。</p><h3 id="Chain-链"><a href="#Chain-链" class="headerlink" title="Chain - 链"></a>Chain - 链</h3><p>The ledger’s chain is a transaction log structured as hash-linked blocks of transactions. Peers receive blocks of transactions from the ordering service, mark the block’s transactions as valid or invalid based on endorsement policies and concurrency violations, and append the block to the hash chain on the peer’s file system.</p><p>chain就是block之间以hash连接为结构的交易日志。peer从order service接收交易block，并根据背书策略和并发冲突标记block上的交易是否有效，然后将该block追加到peer文件系统中的hash chain上。</p><p> 账本的链是一个交易区块经过“哈希连接”结构化的交易日志。对等节点从排序服务收到交易区块，基于背书策略和并发冲突来标注区块的交易为有效或者无效状态，并且将区块追加到对等节点文件系统的哈希链中。 </p><h3 id="Chaincode-链码"><a href="#Chaincode-链码" class="headerlink" title="Chaincode - 链码"></a>Chaincode - 链码</h3><p>Chaincode is software, running on a ledger, to encode assets and the transaction instructions (business logic) for modifying the assets.</p><p>链码是一个运行在账本上的软件，它可以对资产进行编码，其中的交易指令（或者叫业务逻辑）也可以用来修改资产。</p><h3 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel - 通道"></a>Channel - 通道</h3><p>A channel is a private blockchain overlay on a Fabric network, allowing for data isolation and confidentiality. A channel-specific ledger is shared across the peers in the channel, and transacting parties must be properly authenticated to a channel in order to interact with it. Channels are defined by a <a href="https://hyperledgercn.github.io/hyperledgerDocs/glossary/#Configuration-Block" target="_blank" rel="noopener">Configuration-Block</a>.</p><p>通道是构建在“Fabric”网络上的私有区块链，实现了数据的隔离和保密。通道特定的账本在通道中是与所有对等节点共享的，并且交易方必须通过该通道的正确验证才能与账本进行交互。通道是由一个“配置块”来定义的。</p><h3 id="Commitment-提交"><a href="#Commitment-提交" class="headerlink" title="Commitment - 提交"></a>Commitment - 提交</h3><p>Each <a href="https://hyperledgercn.github.io/hyperledgerDocs/glossary/#Peer" target="_blank" rel="noopener">Peer</a> on a channel validates ordered blocks of transactions and then commits (writes-appends) the blocks to its replica of the channel <a href="https://hyperledgercn.github.io/hyperledgerDocs/glossary/#Ledger" target="_blank" rel="noopener">Ledger</a>. Peers also mark each transaction in each block as valid or invalid.</p><p>一个通道中的每个对等节点都会验证交易的有序区块，然后将区块提交（写或追加）至该通道上账本的各个副本。对等节点也会标记每个区块中的每笔交易的状态是有效或者无效。</p><h3 id="Consensus-共识"><a href="#Consensus-共识" class="headerlink" title="Consensus - 共识"></a>Consensus - 共识</h3><p>A broader term overarching the entire transactional flow, which serves to generate an agreement on the order and to confirm the correctness of the set of transactions constituting a block.</p><p>共识是贯穿整个交易流程的广义术语，其用于产生一个对于排序的同意书和确认构成区块的交易集的正确性。</p><h3 id="Current-State-当前状态"><a href="#Current-State-当前状态" class="headerlink" title="Current State - 当前状态"></a>Current State - 当前状态</h3><p>The current state of the ledger represents the latest values for all keys ever included in its chain transaction log. Peers commit the latest values to ledger current state for each valid transaction included in a processed block. Since current state represents all latest key values known to the channel, it is sometimes referred to as World State. Chaincode executes transaction proposals against current state data.</p><p>ledger的current state表示其chain交易log中所有key的最新值。peer会将处理过的block中的每个交易对应的修改value提交到ledger的current state，由于current state表示channel所知的所有最新的k-v，所以current state也被称为World State。Chaincode执行交易proposal就是针对的current state。</p><h3 id="Dynamic-Membership-动态成员"><a href="#Dynamic-Membership-动态成员" class="headerlink" title="Dynamic Membership - 动态成员"></a>Dynamic Membership - 动态成员</h3><p>Fabric supports the addition-removal of members, peers, and ordering service nodes, without compromising the operationality of the overall network. Dynamic membership is critical when business relationships adjust and entities need to be added-removed for various reasons.</p><p>Fabric支持动态添加-移除members、peers和ordering服务节点，而不会影响整个网络的操作性。当业务关系调整或因各种原因需添加-移除实体时，Dynamic Membership至关重要。</p><h3 id="Endorsement-背书"><a href="#Endorsement-背书" class="headerlink" title="Endorsement - 背书"></a>Endorsement - 背书</h3><p>Refers to the process where specific peer nodes execute a transaction and return a <code>YES-NO</code> response to the client application that generated the transaction proposal. Chaincode applications have corresponding endorsement policies, in which the endorsing peers are specified.</p><p>Endorsement 是指一个peer执行一个交易并返回<code>YES-NO</code>给生成交易proposal的client app 的过程。chaincode具有相应的endorsement policies，其中指定了endorsing peer。</p><h3 id="Endorsement-policy-背书策略"><a href="#Endorsement-policy-背书策略" class="headerlink" title="Endorsement policy - 背书策略"></a>Endorsement policy - 背书策略</h3><p>Defines the peer nodes on a channel that must execute transactions attached to a specific chaincode application, and the required combination of responses (endorsements). A policy could require that a transaction be endorsed by a minimum number of endorsing peers, a minimum percentage of endorsing peers, or by all endorsing peers that are assigned to a specific chaincode application. Policies can be curated based on the application and the desired level of resilience against misbehavior (deliberate or not) by the endorsing peers. A distinct endorsement policy for install and instantiate transactions is also required.</p><p>Endorsement policy定义了依赖于特定chaincode执行交易的channel上的peer和响应结果（endorsements）的必要组合条件（即返回Yes或No的条件）。Endorsement policy可指定对于某一chaincode，可以对交易背书的最小背书节点数或者最小背书节点百分比。背书策略由背书节点基于应用程序和对抵御不良行为的期望水平来组织管理。在install和instantiate Chaincode（deploy tx）时需要指定背书策略。</p><h3 id="Fabric-ca"><a href="#Fabric-ca" class="headerlink" title="Fabric-ca"></a>Fabric-ca</h3><p>Fabric-ca is the default Certificate Authority component, which issues PKI-based certificates to network member organizations and their users. The CA issues one root certificate (rootCert) to each member, one enrollment certificate (eCert) to each authorized user, and a number of transaction certificates (tCerts) for each eCert.</p><p>Fabric-ca是默认的证书管理组件，它向网络成员及其用户颁发基于PKI的证书。CA为每个成员颁发一个根证书（rootCert），为每个授权用户颁发一个注册证书（eCert），为每个注册证书颁发大量交易证书（tCerts）。</p><h3 id="Genesis-Block-初始区块"><a href="#Genesis-Block-初始区块" class="headerlink" title="Genesis Block - 初始区块"></a>Genesis Block - 初始区块</h3><p>The configuration block that initializes a blockchain network or channel, and also serves as the first block on a chain.</p><p>Genesis Block是初始化区块链网络或channel的配置区块，也是链上的第一个区块。</p><h3 id="Gossip-Protocol-Gossip协议"><a href="#Gossip-Protocol-Gossip协议" class="headerlink" title="Gossip Protocol - Gossip协议"></a>Gossip Protocol - Gossip协议</h3><p>The gossip data dissemination protocol performs three functions: 1) manages peer discovery and channel membership; 2) disseminates ledger data across all peers on the channel; 3) syncs ledger state across all peers on the channel. Refer to the <a href="http://--hyperledger-fabric.readthedocs.io-en-latest-gossip.html/" target="_blank" rel="noopener">Gossip</a> topic for more details.</p><p>Gossip数据传输协议有三项功能：1）管理peer发现和channel成员；2）channel上的所有peer间广播账本数据；3）channel上的所有peer间同步账本数据。</p><h3 id="Initialize-初始化"><a href="#Initialize-初始化" class="headerlink" title="Initialize - 初始化"></a>Initialize - 初始化</h3><p>A method to initialize a chaincode application.</p><p>一个初始化chaincode程序的方法。</p><h3 id="Install-安装"><a href="#Install-安装" class="headerlink" title="Install - 安装"></a>Install - 安装</h3><p>The process of placing a chaincode on a peer’s file system.</p><p>将chaincode放到peer的文件系统的过程。<em>（译注：即将ChaincodeDeploymentSpec信息存到chaincodeInstallPath-chaincodeName.chainVersion文件中）</em></p><h3 id="Instantiate-实例化"><a href="#Instantiate-实例化" class="headerlink" title="Instantiate - 实例化"></a>Instantiate - 实例化</h3><p>The process of starting a chaincode container.</p><p>启动chaincode容器的过程。<em>（译注：在lccc中将ChaincodeData保存到state中，然后deploy Chaincode并执行Init方法）</em></p><h3 id="Invoke-调用"><a href="#Invoke-调用" class="headerlink" title="Invoke - 调用"></a>Invoke - 调用</h3><p>Used to call chaincode functions. Invocations are captured as transaction proposals, which then pass through a modular flow of endorsement, ordering, validation, committal. The structure of invoke is a function and an array of arguments.</p><p>用于调用chaincode内的函数。Chaincode invoke就是一个交易proposal，然后执行模块化的流程（背书、共识、 验证、 提交）。invoke的结构就是一个函数和一个参数数组。</p><h3 id="Leading-Peer-主导节点"><a href="#Leading-Peer-主导节点" class="headerlink" title="Leading Peer - 主导节点"></a>Leading Peer - 主导节点</h3><p>Each <a href="https://hyperledgercn.github.io/hyperledgerDocs/glossary/#Member" target="_blank" rel="noopener">Member</a> can own multiple peers on each channel that it subscribes to. One of these peers is serves as the leading peer for the channel, in order to communicate with the network ordering service on behalf of the member. The ordering service “delivers” blocks to the leading peer(s) on a channel, who then distribute them to other peers within the same member cluster.</p><p>每一个Member在其订阅的channel上可以拥有多个peer，其中一个peer会作为channel的leading peer代表该Member与ordering service通信。ordering service将block传递给leading peer，该peer再将此block分发给同一member下的其他peer。</p><h3 id="Ledger-账本"><a href="#Ledger-账本" class="headerlink" title="Ledger - 账本"></a>Ledger - 账本</h3><p>A ledger is a channel’s chain and current state data which is maintained by each peer on the channel.</p><p>Ledger是个channel的chain和由channel中每个peer维护的world state。<em>（这个解释有点怪）</em></p><h3 id="Member-成员"><a href="#Member-成员" class="headerlink" title="Member - 成员"></a>Member - 成员</h3><p>A legally separate entity that owns a unique root certificate for the network. Network components such as peer nodes and application clients will be linked to a member.</p><p>拥有网络唯一根证书的合法独立实体。像peer节点和app client这样的网络组件会链接到一个Member。</p><h3 id="Membership-Service-Provider-MSP"><a href="#Membership-Service-Provider-MSP" class="headerlink" title="Membership Service Provider - MSP"></a>Membership Service Provider - MSP</h3><p>The Membership Service Provider (MSP) refers to an abstract component of the system that provides credentials to clients, and peers for them to participate in a Hyperledger Fabric network. Clients use these credentials to authenticate their transactions, and peers use these credentials to authenticate transaction processing results (endorsements). While strongly connected to the transaction processing components of the systems, this interface aims to have membership services components defined, in such a way that alternate implementations of this can be smoothly plugged in without modifying the core of transaction processing components of the system.</p><p>MSP是指为client和peer提供证书的系统抽象组件。Client用证书来认证他们的交易；peer用证书认证其交易背书。该接口与系统的交易处理组件密切相关，旨在使已定义的成员身份服务组件以这种方式顺利插入而不会修改系统的交易处理组件的核心。</p><h3 id="Membership-Services-成员服务"><a href="#Membership-Services-成员服务" class="headerlink" title="Membership Services - 成员服务"></a>Membership Services - 成员服务</h3><p>Membership Services authenticates, authorizes, and manages identities on a permissioned blockchain network. The membership services code that runs in peers and orderers both authenticates and authorizes blockchain operations. It is a PKI-based implementation of the Membership Services Provider (MSP) abstraction.</p><p>成员服务在许可的区块链网络上认证、授权和管理身份。在peer和order中运行的成员服务的代码都会认证和授权区块链操作。它是基于PKI的MSP实现。</p><p>The <code>fabric-ca</code> component is an implementation of membership services to manage identities. In particular, it handles the issuance and revocation of enrollment certificates and transaction certificates.</p><p><code>fabric-ca</code>组件实现了成员服务，来管理身份。特别的，它处理ECert和TCert的颁发和撤销。</p><p>An enrollment certificate is a long-term identity credential; a transaction certificate is a short-term identity credential which is both anonymous and un-linkable.</p><p>ECert是长期的身份凭证；TCert是短期的身份凭证，是匿名和不可链接的。</p><h3 id="Ordering-Service-排序服务或共识服务"><a href="#Ordering-Service-排序服务或共识服务" class="headerlink" title="Ordering Service - 排序服务或共识服务"></a>Ordering Service - 排序服务或共识服务</h3><p>A defined collective of nodes that orders transactions into a block. The ordering service exists independent of the peer processes and orders transactions on a first-come-first-serve basis for all channel’s on the network. The ordering service is designed to support pluggable implementations beyond the out-of-the-box SOLO and Kafka varieties. The ordering service is a common binding for the overall network; it contains the cryptographic identity material tied to each <a href="https://hyperledgercn.github.io/hyperledgerDocs/glossary/#Member" target="_blank" rel="noopener">Member</a>.</p><p>将交易排序放入block的节点的集合。ordering service独立于peer流程之外，并以先到先得的方式为网络上所有的channel作交易排序。ordering service支持可插拔实现，目前默认实现了SOLO和Kafka。ordering service是整个网络的公用binding，包含与每个Member相关的加密材料。</p><h3 id="Peer-节点"><a href="#Peer-节点" class="headerlink" title="Peer - 节点"></a>Peer - 节点</h3><p>A network entity that maintains a ledger and runs chaincode containers in order to perform read-write operations to the ledger. Peers are owned and maintained by members.</p><p>一个网络实体，维护ledger并运行Chaincode容器来对ledger执行read-write操作。peer由Member拥有和维护。</p><h3 id="Policy-策略"><a href="#Policy-策略" class="headerlink" title="Policy - 策略"></a>Policy - 策略</h3><p>There are policies for endorsement, validation, block committal, chaincode management and network-channel management.</p><p>有背书策略，校验策略，区块提交策略，Chaincode管理策略和网络-通道管理策略。</p><h3 id="Proposal-提案"><a href="#Proposal-提案" class="headerlink" title="Proposal - 提案"></a>Proposal - 提案</h3><p>A request for endorsement that is aimed at specific peers on a channel. Each proposal is either an instantiate or an invoke (read-write) request.</p><p>一种针对channel中某peer的背书请求。每个proposal要么是Chaincode instantiate要么是Chaincode invoke。</p><h3 id="Query-查询"><a href="#Query-查询" class="headerlink" title="Query - 查询"></a>Query - 查询</h3><p>A query requests the value of a key(s) against the current state.</p><p>对于current state中某个key的value的查询请求。</p><h3 id="Software-Development-Kit-SDK"><a href="#Software-Development-Kit-SDK" class="headerlink" title="Software Development Kit - SDK"></a>Software Development Kit - SDK</h3><p>The Hyperledger Fabric client SDK provides a structured environment of libraries for developers to write and test chaincode applications. The SDK is fully configurable and extensible through a standard interface. Components, including cryptographic algorithms for signatures, logging frameworks and state stores, are easily swapped in and out of the SDK. The SDK API uses protocol buffers over gRPC for transaction processing, membership services, node traversal and event handling applications to communicate across the fabric. The SDK comes in multiple flavors - Node.js, Java. and Python.</p><p>SDK为开发人员提供了一个结构化的库环境，用于编写和测试链码应用程序。SDK完全可以通过标准接口实现配置和扩展，像签名的加密算法、日志框架和state存储这样的组件都可以轻松地实现替换。SDK API使用gRPC进行交易处理，成员服务、节点遍历以及事件处理都是据此与fabric通信。目前SDK支持Node.js、Java和Python。</p><h3 id="State-Database-stateDB"><a href="#State-Database-stateDB" class="headerlink" title="State Database - stateDB"></a>State Database - stateDB</h3><p>Current state data is stored in a state database for efficient reads and queries from chaincode. These databases include levelDB and couchDB.</p><p>为了从Chaincode中高效的读写，Current state 数据存储在stateDB中，包括levelDB和couchDB。</p><h3 id="System-Chain-系统链"><a href="#System-Chain-系统链" class="headerlink" title="System Chain - 系统链"></a>System Chain - 系统链</h3><p>Contains a configuration block defining the network at a system level. The system chain lives within the ordering service, and similar to a channel, has an initial configuration containing information such as: MSP information, policies, and configuration details. Any change to the overall network (e.g. a new org joining or a new ordering node being added) will result in a new configuration block being added to the system chain.</p><p>包含在系统级定义网络的配置区块。系统链存在于ordering service中，与channel类似，具有包含以下信息的初始配置：MSP信息、策略和信息配置。对整个网络的任何变化（例如新的Org加入或者添加新的Ordering节点）将导致新的配置区块被添加到系统链。</p><p>The system chain can be thought of as the common binding for a channel or group of channels. For instance, a collection of financial institutions may form a consortium (represented through the system chain), and then proceed to create channels relative to their aligned and varying business agendas.</p><p>系统链可看做是一个channel或一组channel的公用binding。例如，金融机构的集合可以形成一个财团（以system chain表示），然后根据其相同或不同的业务创建channel。</p><h3 id="Transaction-交易"><a href="#Transaction-交易" class="headerlink" title="Transaction - 交易"></a>Transaction - 交易</h3><p>An invoke or instantiate operation. Invokes are requests to read-write data from the ledger. Instantiate is a request to start a chaincode container on a peer.</p><p>Chaincode的invoke或instantiate操作。Invoke是从ledger中请求read-write set；Instantiate是请求在peer上启动Chaincode容器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Fabric&quot;&gt;&lt;a href=&quot;#Fabric&quot; class=&quot;headerlink&quot; title=&quot;Fabric&quot;&gt;&lt;/a&gt;Fabric&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>malloc、calloc、realloc的区别</title>
    <link href="http://yoursite.com/2019/01/24/malloc/"/>
    <id>http://yoursite.com/2019/01/24/malloc/</id>
    <published>2019-01-24T01:36:39.984Z</published>
    <updated>2019-01-24T01:36:39.984Z</updated>
    
    <content type="html"><![CDATA[<p>C语言跟内存申请相关的函数主要有 alloca、calloc、malloc、free、realloc等.<br>    <1>alloca是向栈申请内存,因此无需释放.<br>    <2>malloc分配的内存是位于堆中的,并且没有初始化内存的内容,因此基本上malloc之后,调用函数memset来初始化这部分的内存空间.<br>    <3>calloc则将初始化这部分的内存,设置为0.<br>    <4>realloc则对malloc申请的内存进行大小的调整.<br>    <5>申请的内存最终需要通过函数free来释放.<br>    当程序运行过程中malloc了,但是没有free的话,会造成内存泄漏.一部分的内存没有被使用,但是由于没有free,因此系统认为这部分内存还在使用,造成不断的向系统申请内存,使得系统可用内存不断减少.但是内存泄漏仅仅指程序在运行时,程序退出时,OS将回收所有的资源.因此,适当的重起一下程序,有时候还是有点作用.<br>【attention】<br>    三个函数的申明分别是:<br>        void<em> malloc(unsigned size);<br>        void</em> realloc(void<em> ptr, unsigned newsize);<br>        void</em> calloc(size_t numElements, size_t sizeOfElement);<br>    都在stdlib.h函数库内，它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL.<br>    (1)函数malloc()<br>        在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的首地址.<br>    (2)函数calloc()<br>        与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数，即在内存中申请numElements<em>sizeOfElement字节大小的连续地址空间.<br>    (3)函数realloc()<br>        给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度.<br>    区别:<br>    (1)函数malloc不能初始化所分配的内存空间,而函数calloc能.如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0;反之, 如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据.也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题.<br>    (2)函数calloc() 会将所分配的内存空间中的每一位都初始化为零,也就是说,如果你是为字符类型或整数类型的元素分配内存,那么这些元素将保证会被初始化为0;如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针;如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零.<br>    (3)函数malloc向系统申请分配指定size个字节的内存空间.返回类型是 void</em>类型.void<em>表示未确定类型的指针.C,C++规定，void</em> 类型可以强制转换为任何其它类型的指针.<br>    (4)realloc可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变.当然，对于缩小，则被缩小的那一部分的内容会丢失.realloc并不保证调整后的内存空间和原来的内存空间保持同一内存地址.相反，realloc返回的指针很可能指向一个新的地址.<br>    (5)realloc是从堆上分配内存的.当扩大一块内存空间时，realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平；如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上.这句话传递的一个重要的信息就是数据可能被移动.</5></4></3></2></1></p><p><a href="https://blog.csdn.net/u014170207/article/details/53126340" target="_blank" rel="noopener">reference</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C语言跟内存申请相关的函数主要有 alloca、calloc、malloc、free、realloc等.&lt;br&gt;    &lt;1&gt;alloca是向栈申请内存,因此无需释放.&lt;br&gt;    &lt;2&gt;malloc分配的内存是位于堆中的,并且没有初始化内存的内容,因此基本上malloc
      
    
    </summary>
    
    
      <category term="技术 编程语言 C" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C/"/>
    
  </entry>
  
  <entry>
    <title>C时间戳</title>
    <link href="http://yoursite.com/2019/01/12/C_time/"/>
    <id>http://yoursite.com/2019/01/12/C_time/</id>
    <published>2019-01-12T09:50:32.897Z</published>
    <updated>2019-01-12T09:50:32.897Z</updated>
    
    <content type="html"><![CDATA[<h5 id="clock-、time-、clock-gettime-和gettimeofday-函数的用法和区别"><a href="#clock-、time-、clock-gettime-和gettimeofday-函数的用法和区别" class="headerlink" title="clock()、time()、clock_gettime()和gettimeofday()函数的用法和区别"></a>clock()、time()、clock_gettime()和gettimeofday()函数的用法和区别</h5><p>1.精确度比较:</p><p>以下是各种精确度的类型转换:<br>1秒=1000毫秒(ms), 1毫秒=1/1000秒(s)；<br>1秒=1000000 微秒(μs), 1微秒=1/1000000秒(s)；<br>1秒=1000000000 纳秒(ns),1纳秒=1/1000000000秒(s)；</p><p>clock()函数的精确度是10毫秒(ms)<br>times()函数的精确度是10毫秒(ms)<br>gettimofday()函数的精确度是微秒(μs)<br>clock_gettime()函数的计量单位为十亿分之一，也就是纳秒(ns)</p><p><a href="https://www.cnblogs.com/krythur/archive/2013/02/25/2932647.html" target="_blank" rel="noopener">详情</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;clock-、time-、clock-gettime-和gettimeofday-函数的用法和区别&quot;&gt;&lt;a href=&quot;#clock-、time-、clock-gettime-和gettimeofday-函数的用法和区别&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="技术 C" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-C/"/>
    
  </entry>
  
  <entry>
    <title>STL常用API</title>
    <link href="http://yoursite.com/2019/01/04/stl/"/>
    <id>http://yoursite.com/2019/01/04/stl/</id>
    <published>2019-01-04T02:55:33.638Z</published>
    <updated>2019-01-04T02:55:33.634Z</updated>
    
    <content type="html"><![CDATA[<h5 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h5><p>常用容器：array、vector、deque、list、queue、stack<br>要求：序列的元素必须是严格的线性顺序排序。因此序列中的元素具有确定的顺序，可以执行将值插入到特定位置、删除特定区间等操作。</p><h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/array/array/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/array/array/</a></p><h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/vector/vector/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/vector/vector/</a></p><h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/deque/deque/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/deque/deque/</a></p><h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/list/list/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/list/list/</a></p><h5 id="queue（适配器）"><a href="#queue（适配器）" class="headerlink" title="queue（适配器）"></a>queue（适配器）</h5><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/queue/queue/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/queue/queue/</a></p><h5 id="stack-适配器"><a href="#stack-适配器" class="headerlink" title="stack(适配器)"></a>stack(适配器)</h5><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/stack/stack/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/stack/stack/</a></p><p>C/C++STL常用容器用法总结：<a href="https://blog.csdn.net/weixin_41162823/article/details/79759081" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41162823/article/details/79759081</a></p><h5 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h5><p>关联容器与序列容器有着根本性的不同，序列容器的元素是按照在容器中的位置来顺序保存和访问的，而关联容器的元素是按关键元素来保存和访问的。关联容器支持高效的关键字查找与访问。两个主要的关联容器类型是map与set。</p><p>1.set<br>1.1 简介：set里面每个元素只存有一个key，它支持高效的关键字查询操作。set对应数学中的“集合”。</p><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/set/set/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/set/set/</a></p><p>1.2 特点：</p><p>储存同一类型的数据元素（这点和vector、queue等其他容器相同）<br>每个元素的值都唯一（没有重复的元素）<br>根据元素的值自动排列大小（有序性）<br>无法直接修改元素<br>高效的插入删除操作<br>1.3 声明：set<t> a</t></p><p>set<int> a={0,1,6,2,3};<br>for(auto it = a.begin();it != a.end();it++)    cout &lt;&lt; *it;//输出01236<br>1.4 常用函数</int></p><p>以下设 set<t> a,其中a是T类型的set容器。</t></p><p>表达式</p><p>返回类型</p><p>说明</p><p>a.begin()</p><p>返回指向第一个元素的迭代器</p><p>a.end()</p><p>返回指向超尾的迭代器</p><p>a.clear()</p><p>清空容器a</p><p>a.empty()</p><p>判断容器是否为空</p><p>a.size()</p><p>返回当前容器元素个数</p><p>a.count(x)</p><pre><code>返回容器a中元素x的个数</code></pre><p>1.6 插入元素：</p><p>a.insert(x) :其中a为set<t>型容器，x为T型变量<br>    set<int> a={0,1,2,9};<br>    a.insert(6);<br>    for(auto it = a.begin();it != a.end();it++)    cout &lt;&lt; <em>it;//输出01269<br>a.insert(first,second):其中first为指向区间左侧的迭代器，second为指向右侧的迭代器。作用是将first到second区间内元素插入到a（左闭右开）。<br>set<int> a = {0,1,2,9};<br>set<int> b = {3,4,5};<br>auto first = b.begin();<br>auto second = b.end();<br>a.insert(first,second);<br>for(auto it = a.begin();it != a.end();it++)    cout &lt;&lt; </int></int></em>it;<br>插入元素会自动插入到合适的位置，使整个集合有序</int></t></p><p>1.7 删除元素：</p><p>a.erase(x)：删除建值为x的元素<br>a.erase(first,second)：删除first到second区间内的元素（左闭右开）<br>a.erase(iterator):删除迭代器指向的元素<br>set中的删除操作是不进行任何的错误检查的，比如定位器的是否合法等等，所以用的时候自己一定要注意。<br>1.8 lower_bound 和 upper_bound 迭代器：</p><p>lower_bound（x1）:返回第一个不小于键参数x1的元素的迭代器<br>upper_bound（x2）:返回最后一个大于键参数x2的元素的迭代器<br>由以上俩个函数，可以得到一个目标区间，即包含集合中从’x1’到’x2’的所有元素</p><p>#include<iostream></iostream></p><p>#include<set></set></p><p>#include<algorithm><br>using namespace std;<br>int main()<br>{<br>    set<int> a = {0,1,2,5,9};<br>    auto it2 = a.lower_bound(2);//返回指向第一个大于等于x的元素的迭代器<br>    auto it = a.upper_bound(2);//返回指向第一个大于x的元素的迭代器<br>    cout &lt;&lt; <em>it2 &lt;&lt; endl;//输出为2<br>    cout &lt;&lt; </em>it &lt;&lt; endl;//输出为5<br>    return 0;<br>}<br>1.9 set_union() 与 set_intersection()</int></algorithm></p><p>set_union():对集合取并集</p><p>set_union()函数接受5个迭代器参数。前两个迭代器定义了第一个集合的区间，接下来的俩个迭代器定义了第二个集合的区间，最后一个迭代器是输出迭代器，指出将结果集合复制到什么位置。例如：要将A与B的集合复制到C中，可以这样写：</p><p>#include<iostream></iostream></p><p>#include<set></set></p><p>#include<algorithm><br>using namespace std;<br>int main()<br>{<br>    set<int> A = {1,2,3}, B= {2,4,5},C;<br>    set_union(A.begin(),A.end(),B.begin(),B.end(),<br>            insert_iterator&lt;set<int> &gt;(C,C.begin()));<br>    for(auto it = C.begin();it != C.end();it++)<br>        cout &lt;&lt; *it &lt;&lt;” “;<br>    return 0;<br>}<br>注意：</int></int></algorithm></p><p>其中第五个参数不能写C.begin(),原因有两个：首先，关联集合将建看作常量，所以C.begin()返回的迭代器是常量迭代器，不能作为输出迭代器(详情请参考迭代器相关概念)。其次，与copy()相同，set_union()将覆盖容器中已有的数据，并且要求容器用足够的空间容纳新信息，而C不满足，因为它是空的。</p><p>解决方法：可以创建一个匿名的insert_iterator,将信息复制给C。如上述代码所为。另一种方法如下：</p><p>set_union(A.begin(),A.end(),B.begin(),B.end(),<br>        inserter(C,C.begin()));//调用inserter<br>set_intersection():对集合取交集，它的接口与set_union()相同。</p><p>附：使用set_union()和set_intersection()还有另一种技巧。由于需要五个迭代器，看起来会很累赘和麻烦，如果多次使用会增加出错的几率，所以我们可以试试用宏定义的方法来简化代码。如下：</p><p>#include<iostream></iostream></p><p>#include<set></set></p><p>#include<algorithm><br>using namespace std;</algorithm></p><p>#define ALL(x) x.begin(),x.end()</p><p>#define INS(x) inserter(x,x.begin())<br>int main()<br>{<br>    set<int> A = {1,2,3}, B= {2,4,5},C;<br>    set_union(ALL(A),ALL(B),INS(C));<br>    for(auto it = C.begin();it != C.end();it++)<br>        cout &lt;&lt; *it &lt;&lt;” “;<br>    return 0;<br>}<br>其中使用到了宏定义。<br>1.10 set的几个问题：</int></p><p>（1）为何map和set的插入删除效率比用其他序列容器高？</p><p>因为对于关联容器来说，不需要做内存拷贝和内存移动。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。</p><p>（2）为何每次insert之后，以前保存的iterator不会失效？</p><p>iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则：不要使用过期的iterator。</p><p>（3）当数据元素增多时，set的插入和搜索速度变化如何？</p><p>如果你知道log2的关系你应该就彻底了解这个答案。在set中查找是使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个元素，最多比较5次。那么有10000个呢？最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次。看见了吧，当数据量增大一倍的时候，搜索次数只不过多了1次，多了1/14的搜索时间而已。你明白这个道理后，就可以安心往里面放入元素了。</p><p>2.map<br>2.1 简介：如果说set对应数学中的“集合”，那么map对应的就是“映射”。map是一种key-value型容器，其中key是关键字，起到索引作用，而value就是其对应的值。与set不同的是它支持下标访问。头文件是<map></map></p><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/map/map/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/map/map/</a></p><p>2.2 特点：</p><p>增加和删除节点对迭代器的影响很小(高效的插入与删除)<br>快速的查找（同set）<br>自动建立key-value的对应，key和value可以是任何你需要的类型<br>可以根据key修改value的记录<br>支持下标[]操作<br>2.3 声明：map&lt;T1,T2&gt; m</p><p>其中T1是key类型，T2是value类型，m就是一个T1-T2的key-value。</p><p>map&lt;string,int&gt; m;//声明一个key为string，value为int的map型容器<br>下述代码更清楚的解释了map容器的特点：</p><p>#include<iostream></iostream></p><p>#include<map><br>using namespace std;<br>int main()<br>{<br>    map&lt;string,int&gt; m;<br>    m[“abc”] = 5;<br>    m[“cdf”] = 6;<br>    m[“b”] = 1;<br>    for(auto it = m.begin();it != m.end();it++)<br>        cout &lt;&lt; it-&gt;first &lt;&lt;” “ &lt;&lt; it-&gt;second &lt;&lt; endl;<br>    return 0;<br>}<br>在上述代码中，m容器被按照key的字典序升序排列了，而且我们可以通过将key当作索引来获取value的值。（同时这也是一种插入方法）</map></p><p>2.4 插入元素：</p><p>使用insert()函数插入pair类型的元素<br>使用下标操作向map容器中插入元素<br>map&lt;string,int&gt; m;<br>    m.insert(make_pair(“b”,6));//insert插入<br>    m[“a”] = 5;//使用下标插入<br>2.5 删除元素：</p><p>erase(key):删除键为key的元素<br>erase(it):删除迭代器it所指向的元素</p><p>#include<iostream></iostream></p><p>#include<map><br>using namespace std;<br>int main()<br>{<br>    map&lt;string,int&gt; m;<br>    m.insert(make_pair(“b”,6));<br>    m[“a”] = 5;<br>    m[“c”] = 5;<br>    m[“d”] = 5;<br>    m[“e”] = 5;</map></p><pre><code>m.erase(&quot;d&quot;);auto pr = m.begin();m.erase(pr);for(auto it = m.begin();it != m.end();it++)    cout &lt;&lt; it-&gt;first &lt;&lt;&quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;return 0;</code></pre><p>}<br>2.6 map容器的遍历：</p><p>使用迭代器遍历（代码如上）<br>注：使用迭代器遍历map容器，其中每一个元素可以看成是pair类型的，访问第一个位置的key值可以用it-&gt;first访问，第二个位置value的值可以用it-&gt;second访问，其中it是指向该元素的迭代器。<br>2.7 常用函数：</p><p>下表中m为map类型的容器，it为和m同类型的迭代器，key表示该类型的一个键。</p><p>表达式</p><p>返回类型</p><p>说明</p><p>m.Count(key)</p><p>返回map中key出现的次数（0或1）</p><p>m.find(key)</p><p>迭代器</p><p>返回指向key位置的迭代器.若无则返回m.end()</p><p>m.insert(make_pair( ) )</p><p>插入一个元素(必须以pair形式插入)</p><p>m.erase(it)</p><p>删除迭代器it所指向的元素</p><p>m.erase(key)</p><p>删除键值为key的元素</p><p>m.size()</p><p>返回m中元素的个数</p><p>m.clear()</p><p>清空m容器</p><p>m.empty()</p><p>bool</p><p>判断容器是否为空。空则返回true</p><p>m.lower_bound(key)</p><p>迭代器</p><p>返回指向第一个键值不小于key的元素的迭代器</p><p>m.upper_bound(key)</p><p>迭代器</p><p>返回指向第一个键值大于key的元素的迭代器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;序列容器&quot;&gt;&lt;a href=&quot;#序列容器&quot; class=&quot;headerlink&quot; title=&quot;序列容器&quot;&gt;&lt;/a&gt;序列容器&lt;/h5&gt;&lt;p&gt;常用容器：array、vector、deque、list、queue、stack&lt;br&gt;要求：序列的元素必须是严格的线性顺序
      
    
    </summary>
    
    
      <category term="技术 技术 编程语言 C++11" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C-11/"/>
    
  </entry>
  
  <entry>
    <title>MySQL远程连接问题</title>
    <link href="http://yoursite.com/2019/01/04/mysql_1/"/>
    <id>http://yoursite.com/2019/01/04/mysql_1/</id>
    <published>2019-01-04T02:47:48.016Z</published>
    <updated>2019-01-04T02:45:38.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="如何让MySQL可以远程连接"><a href="#如何让MySQL可以远程连接" class="headerlink" title="如何让MySQL可以远程连接"></a>如何让MySQL可以远程连接</h5><p>1.本地防火墙是否关闭<br>    ufw status;</p><p>2.mysql配置文件my.cnf<br>    注释掉 #bind 127.0.0.1 绑定本地地址</p><p>3.MySQL数据库user远程权限<br>    grant all privileges on <em>.</em> to ‘root‘@’%’ identified by ‘123456’ with grant option;<br>flush privileges;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;如何让MySQL可以远程连接&quot;&gt;&lt;a href=&quot;#如何让MySQL可以远程连接&quot; class=&quot;headerlink&quot; title=&quot;如何让MySQL可以远程连接&quot;&gt;&lt;/a&gt;如何让MySQL可以远程连接&lt;/h5&gt;&lt;p&gt;1.本地防火墙是否关闭&lt;br&gt;    ufw
      
    
    </summary>
    
    
      <category term="mysql 数据库" scheme="http://yoursite.com/tags/mysql-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>C++11新特性</title>
    <link href="http://yoursite.com/2018/12/27/c++11featrues/"/>
    <id>http://yoursite.com/2018/12/27/c++11featrues/</id>
    <published>2018-12-27T09:25:59.968Z</published>
    <updated>2018-12-27T09:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1.Lambda 表达式"></a>1.Lambda 表达式</h5><p>Lambda 表达式就是用于创建<strong>匿名函数</strong>的。<br>为什么说 lambda 表达式如此激动人心呢？举一个例子。标准 C++ 库中有一个常用算法的库，其中提供了很多算法函数，比如 sort() 和 find()。这些函数通常需要提供一个“谓词函数 predicate function”。所谓谓词函数，就是进行一个操作用的临时函数。比如 find() 需要一个谓词，用于查找元素满足的条件；能够满足谓词函数的元素才会被查找出来。<strong>这样的谓词函数，使用临时的匿名函数，既可以减少函数数量，又会让代码变得清晰易读。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;<span class="keyword">return</span>-type &#123;body&#125;</span><br></pre></td></tr></table></figure><p>最简单的例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> abssort(float *x, unsigned N)</span><br><span class="line">&#123;</span><br><span class="line">  std::sort(x,</span><br><span class="line">            x + N,</span><br><span class="line">            [](float a, float b) &#123; <span class="keyword">return</span> std::abs(a) &lt; std::abs(b); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要注意：</p><ol><li>返回值类型-&gt;return-type可以省略，由语言自动推导，但前提是只有当 lambda 表达式中的语句“足够简单”，才能自动推断返回值类型。</li><li>引入 lambda 表达式的前导符是一对方括号，称为 lambda 引入符（lambda-introducer）。lambda 表达式可以使用与其相同范围 scope 内的变量。这个引入符的作用就是表明，其后的 lambda 表达式以何种方式使用（正式的术语是“捕获”）这些变量（这些变量能够在 lambda 表达式中被捕获，其实就是构成了一个闭包）。</li><li>捕获类型可以以下类型：</li></ol><ul><li>[]  // 不捕获任何外部变量</li><li>[=] // 以值的形式捕获所有外部变量</li><li>[&amp;] // 以引用形式捕获所有外部变量</li><li>[x, &amp;y] // x 以传值形式捕获，y 以引用形式捕获</li><li>[=, &amp;z]// z 以引用形式捕获，其余变量以传值形式捕获</li><li>[&amp;, x] // x 以值的形式捕获，其余变量以引用形式捕获</li></ul><ol start="4"><li>对于[=]或[&amp;]的形式，lambda 表达式可以直接使用  this 指针 。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</li><li>对于下面的例子，[=]意味着，lambda 表达式以传值的形式捕获外部变量。C++ 11 标准说，如果以传值的形式捕获外部变量，那么，lambda 体不允许修改外部变量，对 f0 的任何修改都会引发编译错误。但是，注意在 lambda 表达式前声明了mutable关键字，这就允许了 lambda 表达式体修改 f0 的值。因此不会报错。但由于是传值的，虽然在 lambda 表达式中对 f0 有了修改，但由于是传值的，外部的 f0 依然不会被修改。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float f0 = <span class="number">1.0</span>;</span><br><span class="line">std::cout &lt;&lt; [=](float f) mutable &#123; <span class="keyword">return</span> f0 += std::abs(f); &#125; (<span class="number">-3.5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">'\n'</span> &lt;&lt; f0 &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>– 混合机制的实例如下（f0 通过引用被捕获，而其它变量，比如 f1 则是通过值被捕获）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float f0 = <span class="number">1.0</span>f;</span><br><span class="line">float f1 = <span class="number">10.0</span>f;</span><br><span class="line">std::cout &lt;&lt; [=, &amp;f0](float a) &#123; <span class="keyword">return</span> f0 += f1 + std::abs(a); &#125; (<span class="number">-3.5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">'\n'</span> &lt;&lt; f0 &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p><strong>C++引入Lambda的最主要原因:</strong><br>1）可以定义匿名函数；<br>2）<strong>编译器会把其转成函数对象</strong>；为什么以前STL中的ptr_fun()这个函数对象不能用？（ptr_fun()就是把一个自然函数转成函数对象的）原因是，ptr_fun() 的局限是其接收的自然函数只能有1或2个参数。<br>3）”闭包”，限制了别人的访问，更私有；</p><h5 id="2-自动类型推导和-decltype"><a href="#2-自动类型推导和-decltype" class="headerlink" title="2.自动类型推导和 decltype"></a>2.自动类型推导和 decltype</h5><p>在 C++03 中，声明对象的同时必须指明其类型，其实大多数情况下，声明对象的同时也会包括一个初始值，C++11 在这种情况下就能够让你声明对象时不再指定类型了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto x = <span class="number">0</span>; <span class="comment">//0 是 int 类型，所以 x 也是 int 类型  </span></span><br><span class="line">auto c = <span class="string">'a'</span>; <span class="comment">//char  </span></span><br><span class="line">auto d = <span class="number">0.5</span>; <span class="comment">//double  </span></span><br><span class="line">auto national_debt = <span class="number">14400000000000</span>LL;<span class="comment">//long long</span></span><br></pre></td></tr></table></figure><p>这个特性在对象的类型很大很长的时候很有用，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">void</span> func(<span class="keyword">const</span> vector&lt;int&gt; &amp;vi)  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="comment">//vector&lt;int&gt;::const_iterator ci=vi.begin(); </span></span><br><span class="line">  auto ci=vi.begin();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++11 也提供了从对象或表达式中“俘获”类型的机制，新的操作符 decltype 可以从一个表达式中“俘获”其结果的类型并“返回”：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vector&lt;int&gt; vi;  </span><br><span class="line">typedef decltype (vi.begin()) CIT;  </span><br><span class="line">CIT another_const_iterator;</span><br></pre></td></tr></table></figure><p><strong>注意： auto作为函数返回值时，只能用于定义函数，不能用于声明函数</strong></p><h5 id="3-统一的初始化语法"><a href="#3-统一的初始化语法" class="headerlink" title="3.统一的初始化语法"></a>3.统一的初始化语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//括号内初始化</span></span><br><span class="line">std::string s(<span class="string">"hello"</span>);  </span><br><span class="line">int m=int(); <span class="comment">//default initialization </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//等号形式的</span></span><br><span class="line">std::string s=<span class="string">"hello"</span>;  </span><br><span class="line">int x=<span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对于 POD 集合，又可以用大括号</span></span><br><span class="line">int arr[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  </span><br><span class="line">struct tm today=&#123;<span class="number">0</span>&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//最后还有构造函数的成员初始化：</span></span><br><span class="line">struct S &#123;  </span><br><span class="line"> int x;  </span><br><span class="line"> S(): x(<span class="number">0</span>) &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure><p>C++11 就用大括号一统天下了!<br>对于容器来说，终于可以摆脱 push_back() 调用了，C++11中可以直观地初始化容器了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 container initializer  </span></span><br><span class="line">vector vs&lt;string&gt;=&#123; <span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"third"</span>&#125;;  </span><br><span class="line">map singers =  </span><br><span class="line">  &#123; &#123;<span class="string">"Lady Gaga"</span>, <span class="string">"+1 (212) 555-7890"</span>&#125;,  </span><br><span class="line">    &#123;<span class="string">"Beyonce Knowles"</span>, <span class="string">"+1 (212) 555-0987"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>而类中的数据成员初始化也得到了支持：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">  int a=<span class="number">7</span>; <span class="comment">//C++11 only  </span></span><br><span class="line">public:  </span><br><span class="line">  C();  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-deleted-函数和-defaulted-函数"><a href="#4-deleted-函数和-defaulted-函数" class="headerlink" title="4.deleted 函数和 defaulted 函数"></a>4.deleted 函数和 defaulted 函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct A  </span><br><span class="line">&#123;  </span><br><span class="line">    A()=<span class="keyword">default</span>; <span class="comment">//C++11  </span></span><br><span class="line">    virtual ~A()=<span class="keyword">default</span>; <span class="comment">//C++11  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>=default; 指示编译器生成该函数的默认实现。这有两个好处：一是让程序员轻松了，少敲键盘，二是有更好的性能。<br>与 defaulted 函数相对的就是 deleted 函数, 实现 non copy-able 防止对象拷贝，要想禁止拷贝，用 =deleted 声明一下两个关键的成员函数就可以了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int func()=<span class="keyword">delete</span>;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//防止对象拷贝的实现</span></span><br><span class="line">struct NoCopy  </span><br><span class="line">&#123;  </span><br><span class="line">    NoCopy &amp; operator =(<span class="keyword">const</span> NoCopy &amp;) = <span class="keyword">delete</span>;  </span><br><span class="line">    NoCopy(<span class="keyword">const</span> NoCopy &amp;) = <span class="keyword">delete</span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">NoCopy a;  </span><br><span class="line">NoCopy b(a); <span class="comment">//编译错误，拷贝构造函数是 deleted 函数</span></span><br></pre></td></tr></table></figure><h5 id="5-nullptr"><a href="#5-nullptr" class="headerlink" title="5.nullptr"></a>5.nullptr</h5><p>nullptr 是一个新的 C++ 关键字，它是空指针常量，它是用来替代高风险的 NULL 宏和 0 字面量的。nullptr 是强类型的,所有跟指针有关的地方都可以用 nullptr，包括函数指针和成员指针：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> f(int); <span class="comment">//#1  </span></span><br><span class="line"><span class="keyword">void</span> f(char *);<span class="comment">//#2  </span></span><br><span class="line"><span class="comment">//C++03  </span></span><br><span class="line">f(<span class="number">0</span>); <span class="comment">//调用的是哪个 f?  </span></span><br><span class="line"><span class="comment">//C++11  </span></span><br><span class="line">f(nullptr) <span class="comment">//毫无疑问，调用的是 #2  </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> char *pc=str.c_str(); <span class="comment">//data pointers  </span></span><br><span class="line"><span class="keyword">if</span> (pc != nullptr)  </span><br><span class="line">  cout &lt;&lt; pc &lt;&lt; endl;  </span><br><span class="line">int (A::*pmf)()=nullptr; <span class="comment">//指向成员函数的指针  </span></span><br><span class="line"><span class="keyword">void</span> (*pmf)()=nullptr; <span class="comment">//指向函数的指针</span></span><br></pre></td></tr></table></figure><h5 id="6-右值引用"><a href="#6-右值引用" class="headerlink" title="6.右值引用"></a>6.右值引用</h5><p>在 C++03 中的引用类型是只绑定左值的，C++11 引用一个新的引用类型叫右值引用类型，它是绑定到右值的，如临时对象或字面量。<br>增加右值引用的主要原因是为了<strong>实现 move 语义</strong>。与传统的拷贝不同，move 的意思是目标对象“窃取”原对象的资源，并将源置于“空”状态。当拷贝一个对象时，其实代价昂贵且无必要，move 操作就可以替代它。如在 string 交换的时候，使用 move 意义就有巨大的性能提升，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原方案很慢，因为需要申请内存，然后拷贝字符；</span></span><br><span class="line">[cpp] view plain copy</span><br><span class="line"><span class="keyword">void</span> naiveswap(string &amp;a, string &amp; b)  </span><br><span class="line">&#123;  </span><br><span class="line">    string temp = a;  </span><br><span class="line">    a=b;  </span><br><span class="line">    b=temp;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用move就只需要交换两个数据成员，无须申请、释放内存和拷贝字符数组；</span></span><br><span class="line"><span class="keyword">void</span> moveswapstr(string&amp; empty, string &amp; filled)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//pseudo code, but you get the idea  </span></span><br><span class="line">    size_t sz=empty.size();  </span><br><span class="line">    <span class="keyword">const</span> char *p= empty.data();  </span><br><span class="line">    <span class="comment">//move filled's resources to empty  </span></span><br><span class="line">    empty.setsize(filled.size());  </span><br><span class="line">    empty.setdata(filled.data());  </span><br><span class="line">    <span class="comment">//filled becomes empty  </span></span><br><span class="line">    filled.setsize(sz);  </span><br><span class="line">    filled.setdata(p);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现支持 move 的类，需要声明 move 构造函数和 move 赋值操作符，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    Movable (Movable&amp;&amp;); <span class="comment">//move constructor  </span></span><br><span class="line">    Movable&amp;&amp; operator=(Movable&amp;&amp;); <span class="comment">//move assignment operator  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="C-11-的标准库"><a href="#C-11-的标准库" class="headerlink" title="C++11 的标准库"></a>C++11 的标准库</h5><p>线程库、新的智能指针类、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-Lambda-表达式&quot;&gt;&lt;a href=&quot;#1-Lambda-表达式&quot; class=&quot;headerlink&quot; title=&quot;1.Lambda 表达式&quot;&gt;&lt;/a&gt;1.Lambda 表达式&lt;/h5&gt;&lt;p&gt;Lambda 表达式就是用于创建&lt;strong&gt;匿名函数&lt;/
      
    
    </summary>
    
    
      <category term="技术 编程语言 C++11" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C-11/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="http://yoursite.com/2018/12/27/docker/"/>
    <id>http://yoursite.com/2018/12/27/docker/</id>
    <published>2018-12-27T02:50:02.862Z</published>
    <updated>2018-12-27T02:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="docker是什么？"><a href="#docker是什么？" class="headerlink" title="docker是什么？"></a>docker是什么？</h5><p>docker是一个开源的容器引擎，它基于LCX容器技术，使用Go语言开发。<br>源代码托管在Github上，并遵从Apache2.0协议。<br>Docker采用C/S架构，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。</p><p>简单来说：Docker就是一种快速解决生产问题的一种技术手段。<br>简单点：Docker就是对容器进行操作管理的工具</p><h5 id="docker优缺点"><a href="#docker优缺点" class="headerlink" title="docker优缺点"></a>docker优缺点</h5><p><strong>优点：</strong><br>多：    适用场景多<br>快：    环境部署快、更新快<br>好：    好多人在用<br>省：    省钱省力省人工</p><p><strong>缺点：</strong><br>太腻歪人：  依赖操作系统<br>不善沟通：  依赖网络<br>不善理财：  银行U盾等场景不能用</p><h5 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h5><p>搜索 ： docker search 【image_name】<br>获取 ： docker pull 【image_name】<br>查看 ： docker image 【image_name】<br>docker image -a 列出本地的image（包括已删除的镜像记录）<br>镜像重命名： docker tag [old_name]:[old_version]  [new_name]:[new_verdion]<br>删除镜像：docker rmi [image_id]<br>导出镜像：（将已下载好的镜像，导出到本地）<br>                docker save  -o [导出镜像名称]   [本地镜像]<br>                例：docker save -o nginx.tar nginx</p><p>导入镜像： docker load  &lt; [image.tar_name]</p><h5 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h5><p>查看容器： docker ps<br>启动容器三种方式：</p><ol><li><p>基于镜像新建一个容器并启动<br>docker  run  &lt;参数，可选&gt;   [docker_image]  [执行命令]<br><strong>docker run 其实是两个命令的结合体docker create + docker start</strong></p></li><li><p>将关闭的容器重新启动<br>docker  start   [container_id]</p></li><li><p>守护进程方式启动(常用方式)<br>docker  run  -d  [image_name]   command…<br>例：docker run  -d nginx</p></li></ol><p>关闭容器： docker stop  [container_id]</p><p>删除容器的三种方式：<br>1.正常删除- - -删除已关闭的<br>docker  rm [container_id]</p><p>2.强制删除- - - 删除正在运行的<br>docker rm  -f  [container_id]</p><p>3.强制批量删除- - - 删除全部容器<br>docker rm  -f $(docker ps -a -q)</p><p>进入容器三种方法：<br>1.创建容器的同事并且进入容器<br>docker  run  –name  [container_name] -it [docker_image]  /bin/bash</p><p>2.手工方式进入容器<br>docker exec -it  容器id   /bin/bash</p><p>3.生产方式进入容器<br> 我们生产中常用的进入容器方法是使用脚本，脚本内容如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"># 定义进入仓库函数</span><br><span class="line">docker_in()&#123;</span><br><span class="line">  NAME_ID=$<span class="number">1</span></span><br><span class="line">  PID=$(docker inspect --format &#123;&#123;.State.Pid&#125;&#125; $NAME_ID)</span><br><span class="line">  nsenter --target $PID --mount --uts --ipc --net --pid</span><br><span class="line">&#125;</span><br><span class="line">docker_in $<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;docker是什么？&quot;&gt;&lt;a href=&quot;#docker是什么？&quot; class=&quot;headerlink&quot; title=&quot;docker是什么？&quot;&gt;&lt;/a&gt;docker是什么？&lt;/h5&gt;&lt;p&gt;docker是一个开源的容器引擎，它基于LCX容器技术，使用Go语言开发。&lt;
      
    
    </summary>
    
    
      <category term="技术 容器" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>IO阻塞与非阻塞一篇就够了</title>
    <link href="http://yoursite.com/2018/12/27/io_sync/"/>
    <id>http://yoursite.com/2018/12/27/io_sync/</id>
    <published>2018-12-27T02:49:55.298Z</published>
    <updated>2018-12-27T01:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么叫IO"><a href="#什么叫IO" class="headerlink" title="什么叫IO"></a>什么叫IO</h5><p>io通常是指计算机系统输入和输出的称呼，包括设备（键盘鼠标显示器）、总线、磁盘读写、内存等都称之为IO。</p><h5 id="IO阻塞与非阻塞"><a href="#IO阻塞与非阻塞" class="headerlink" title="IO阻塞与非阻塞"></a>IO阻塞与非阻塞</h5><p>阻塞（block）：用户态进程切换至内核态进程（read，write，accept等API函数系统调用），用户态进程一直处于挂起状态，直至内核态返回，继续工作。</p><p>非阻塞（nonblock）:用户态进程切换至内核态进程（read，write，accept等API函数系统调用），内核态进程会立马返回数据或状态码给用户态进程，用户态进程无需处于挂起状态，一直处于忙碌状态。</p><h5 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h5><p>同步（synchronous）:一个服务进行数据请求时，服务方立马告知请求结果，若数据不满足，请求方会再次主动发送请求到服务方，直至请求方得到满意的回复。（期望的结果）</p><p>异步（asynchronous）：客户向服务方请求，服务方也会立马回复请求方，不同的是，客户请求方只留下一个回调函数，用来让服务方等待条件满足后，主动通知客户方最终结果。（此方式客户方只请求了一次服务方）</p><ul><li>阻塞、非阻塞和同步异步是两个不同的概念。 </li><li>同步与异步最大的差异是对待结果的返回方式不一样。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;什么叫IO&quot;&gt;&lt;a href=&quot;#什么叫IO&quot; class=&quot;headerlink&quot; title=&quot;什么叫IO&quot;&gt;&lt;/a&gt;什么叫IO&lt;/h5&gt;&lt;p&gt;io通常是指计算机系统输入和输出的称呼，包括设备（键盘鼠标显示器）、总线、磁盘读写、内存等都称之为IO。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="技术 linux" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-linux/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2018/12/26/threadpool/"/>
    <id>http://yoursite.com/2018/12/26/threadpool/</id>
    <published>2018-12-26T14:13:35.349Z</published>
    <updated>2018-12-26T14:13:35.345Z</updated>
    
    <content type="html"><![CDATA[<h5 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h5><p>在那些情况下我们会使用到多线程：</p><p>1.阻塞调用（阻塞IO调用、等待资源）<br>2.耗时的计算（读写文件、复杂的计算）<br>3.高密度任务（高并发低延时的网络IO请求）<br>面临以上情况时都去临时创建线程会带来什么问题：</p><p>1.创建了太多的线程，系统资源就会被浪费，而且会浪费时间去创建和销毁线程。<br>2.创建线程太慢，导致执行任务结果返回过慢。<br>3.销毁线程太慢，可能会影响别的进程使用资源。<br>所以：创建多个线程，放在池子里不销毁，要用的时候就把任务丢给池子里的线程去执行，这就是线程池。<br>OK，问题来了任务由谁产生（生产者），如何丢给线程池的某个线程（消费者）？这个问题的回答需从以下几方面：</p><p>1） 生产者采用什么方式与消费者同步？<br>2） 任务如何保存？<br>3） 生产者之间的同步方式，消费者之间的同步方式？</p><p>一下所有的代码设计适用于单生产者多消费者模式</p><h5 id="条件变量结合互斥锁-任务队列"><a href="#条件变量结合互斥锁-任务队列" class="headerlink" title="条件变量结合互斥锁 + 任务队列"></a>条件变量结合互斥锁 + 任务队列</h5><p>设计如何：</p><p><img src="https://github.com/zhiyong0804/f-threadpool/blob/master/cond_mutex.png?raw=true" alt="enter description here"></p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">typedef struct queue_task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* (*run)(<span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">void</span>* argv;</span><br><span class="line">&#125;task_t;</span><br><span class="line"></span><br><span class="line">typedef struct queue</span><br><span class="line">&#123;</span><br><span class="line">    int      head;</span><br><span class="line">    int      tail;</span><br><span class="line">    int      size;</span><br><span class="line">    int      capcity;</span><br><span class="line">    task_t*  tasks;</span><br><span class="line">&#125; queue_t;</span><br><span class="line"></span><br><span class="line">typedef struct async_queue</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_t  mutex;</span><br><span class="line">    pthread_cond_t   cond;</span><br><span class="line">    int              waiting_threads;</span><br><span class="line"></span><br><span class="line">    queue_t*         queue;</span><br><span class="line">    int              quit;   <span class="comment">// 0 表示不退出  1 表示退出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调试变量 */</span></span><br><span class="line">    long long        tasked;  <span class="comment">// 已经处理完的任务数量</span></span><br><span class="line">&#125; async_queue_t;</span><br></pre></td></tr></table></figure><p>取任务的代码设计如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">task_t* async_cond_queue_pop_head(async_queue_t* q, int timeout)</span><br><span class="line">&#123;</span><br><span class="line">    task_t *task = NULL;</span><br><span class="line">    struct timeval now;</span><br><span class="line">    struct timespec outtime;</span><br><span class="line">    pthread_mutex_lock(&amp;(q-&gt;mutex));</span><br><span class="line">    <span class="keyword">if</span> (queue_is_empty(q-&gt;queue))</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;waiting_threads++;</span><br><span class="line">        <span class="keyword">while</span> (queue_is_empty(q-&gt;queue) &amp;&amp; (q-&gt;quit == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            gettimeofday(&amp;now, NULL);</span><br><span class="line">            <span class="keyword">if</span> (now.tv_usec + timeout &gt; <span class="number">1000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                outtime.tv_sec = now.tv_sec + <span class="number">1</span>;</span><br><span class="line">                outtime.tv_nsec = ((now.tv_usec + timeout) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                outtime.tv_sec = now.tv_sec;</span><br><span class="line">                outtime.tv_nsec = (now.tv_usec + timeout) * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_cond_timedwait(&amp;(q-&gt;cond), &amp;(q-&gt;mutex), &amp;outtime);</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;waiting_threads--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task = queue_pop_head(q-&gt;queue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调试代码 */</span></span><br><span class="line">    <span class="keyword">if</span> (task)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;tasked ++;</span><br><span class="line">        <span class="keyword">static</span> long long precision = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> ((q-&gt;tasked % precision ) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            time_t current_stm = get_current_timestamp();</span><br><span class="line">            precision *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;(q-&gt;mutex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情见：<a href="https://github.com/zhiyong0804/f-threadpool/blob/master/async_cond_queue.c" target="_blank" rel="noopener">https://github.com/zhiyong0804/f-threadpool/blob/master/async_cond_queue.c</a></p><p>不足：</p><p>因为Mutex引起线程挂起和唤醒的操作，在IO密集型的服务器上不是特别高效（实测过）；<br>条件变量必须和互斥锁相结合使用，使用起来较麻烦；<br>条件变量不能像eventfd一样为I/O事件驱动。<br>管道可以和I/O复用很好的融合，但是管道比eventfd多用了一个文件描述符，而且管道内核还得给其管理的缓冲区，eventfd则不需要，因此eventfd比起管道要高效。</p><h5 id="eventfd-epoll"><a href="#eventfd-epoll" class="headerlink" title="eventfd + epoll"></a>eventfd + epoll</h5><p>队列的设计：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct async_queue</span><br><span class="line">&#123;</span><br><span class="line">    queue_t*         queue;</span><br><span class="line">    int              quit;   <span class="comment">// 0 表示不退出  1 表示退出</span></span><br><span class="line"></span><br><span class="line">    int              efd;     <span class="comment">//event fd,</span></span><br><span class="line">    int              epollfd; <span class="comment">// epoll fd</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调试变量 */</span></span><br><span class="line">    long long        tasked;  <span class="comment">// 已经处理完的任务数量</span></span><br><span class="line">&#125; async_queue_t;</span><br></pre></td></tr></table></figure><p>插入任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BOOL async_eventfd_queue_push_tail(async_queue_t* q, task_t *task)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long long i = <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">if</span> (!queue_is_full(q-&gt;queue))</span><br><span class="line">    &#123;</span><br><span class="line">        queue_push_tail(q-&gt;queue, task);</span><br><span class="line"></span><br><span class="line">        struct epoll_event ev;</span><br><span class="line">        int efd = eventfd(<span class="number">0</span>, EFD_CLOEXEC | EFD_NONBLOCK);</span><br><span class="line">        <span class="keyword">if</span> (efd == <span class="number">-1</span>) printf(<span class="string">"eventfd create: %s"</span>, strerror(errno));</span><br><span class="line">        ev.events = EPOLLIN ;<span class="comment">// | EPOLLLT;</span></span><br><span class="line">        ev.data.fd = efd;</span><br><span class="line">        <span class="keyword">if</span> (epoll_ctl(q-&gt;epollfd, EPOLL_CTL_ADD, efd, &amp;ev) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> NULL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(efd, &amp;i, sizeof (i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">task_t* async_eventfd_queue_pop_head(async_queue_t* q, int timeout)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long long i = <span class="number">0</span>;</span><br><span class="line">    struct epoll_event events[MAX_EVENTS];</span><br><span class="line">    int nfds = epoll_wait(q-&gt;epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        read(events[<span class="number">0</span>].data.fd, &amp;i, sizeof (i));</span><br><span class="line">        close(events[<span class="number">0</span>].data.fd); <span class="comment">// <span class="doctag">NOTE:</span> need to close here</span></span><br><span class="line">        task_t* task = queue_pop_head(q-&gt;queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 调试代码 */</span></span><br><span class="line">        <span class="keyword">if</span> (task)</span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;tasked ++;</span><br><span class="line">            <span class="keyword">static</span> long long precision = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> ((q-&gt;tasked % precision ) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                time_t current_stm = get_current_timestamp();</span><br><span class="line">                printf(<span class="string">"%d tasks cost : %d\n"</span>, precision, current_stm - start_stm);</span><br><span class="line">                precision *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为eventfd每次写数据后，只会唤醒一个epoll_wait所在的线程，so，确保了同一时刻仅有一个线程取任务。<br>代码详情：<a href="https://github.com/zhiyong0804/f-threadpool/blob/master/async_eventfd_queue.c" target="_blank" rel="noopener">https://github.com/zhiyong0804/f-threadpool/blob/master/async_eventfd_queue.c</a></p><p>不足：<br>上面两种方案，所有的线程共用同一个队列，所以消费者线程之间取任务时需要做同步，生产者和消费者也需要做同步。用一个形象的图可以表示如下：<br><img src="https://github.com/zhiyong0804/f-threadpool/blob/master/fuck.png?raw=true" alt="enter description here"></p><h5 id="eventfd-epoll-多队列的设计"><a href="#eventfd-epoll-多队列的设计" class="headerlink" title="eventfd + epoll + 多队列的设计"></a>eventfd + epoll + 多队列的设计</h5><p>设计思想如下图：<br><img src="https://github.com/zhiyong0804/f-threadpool/blob/master/multiple.png?raw=true" alt="enter description here"></p><p>代码详情见：<a href="https://github.com/zhiyong0804/StreamingServer" target="_blank" rel="noopener">https://github.com/zhiyong0804/StreamingServer</a><br>Oh my god, huge project, where can i find thre thread pool source. 说来话长，这个代码是EasyDarwin的源码，但是因为某种原因，EasyDarwin的源码不再共享，取而代之的打赏的二维码，so， 我把他们的源码做了局部的修改，然后重新提交，且命名为StreamingServer，里面的设计是采用条件变量做同步的，但是多队列的思想是可以沿袭的，打算加班用eventfd实现。</p><p>这样一种设计是不是让我们能够想到下面这幅图呢？<br><img src="https://github.com/zhiyong0804/f-threadpool/blob/master/lijiao.jpg?raw=true" alt="enter description here"></p><p>之前所有的道路遇到十字路口时（共享了资源），只能使用信号灯去同步汽车的行驶，现如今，把共享资源fuck掉了，用立交桥，爽吧！！！？</p><p>并行编程是很难的，可以参考以下这篇论文:</p><p>并发编程的11个问题英文版：<a href="http://www.it610.com/article/4462577.htm" target="_blank" rel="noopener">http://www.it610.com/article/4462577.htm</a><br>并发编程的11个问题中文版：<a href="https://blog.csdn.net/mergerly/article/details/39028861" target="_blank" rel="noopener">https://blog.csdn.net/mergerly/article/details/39028861</a><br>我也并不聪明，可是当我2年前接触到ZeroMQ这个项目时，我特别惊叹于Pieter Hintjens的一些观点，“真正的并发就是不共享资源”</p><p>so，方案四的设计</p><h5 id="Lock-free"><a href="#Lock-free" class="headerlink" title="Lock-free"></a>Lock-free</h5><p>当我们在第三种方案上，增加了多队列，即每线程每队列时，实际上我们的队列设计变成了一个单生产者单消费者共享的队列，但是这个队列的写指针（tail）仅会被生产者使用，读指针（head）仅会被消费者使用，实际上没有共享任何资源，当然queue_t的size变量，我正在重构把它拿掉。</p><p><strong>OK，那么在这种设计下，消费者线程如何“等待”如何“取”任务？</strong></p><p>实际上，上面的三种方案对于消费者线程都是被动等待通知，收到通知则去取任务，实际上，我们完全可以设计成“轮询”的方案，就是不停地看自己的任务队列里是否有任务，没有就循环一次，中间当然可以加上sched_yield操作，让其它的线程能够得到调度。</p><h5 id="线程池的尺寸设计多大合适？"><a href="#线程池的尺寸设计多大合适？" class="headerlink" title="线程池的尺寸设计多大合适？"></a>线程池的尺寸设计多大合适？</h5><p>CPU密集型的：<br>thread size = N + 1;<br>IO密集型的：<br>thread size = 2*N + 1;</p><p>当然这不是绝对的，所以在mariadb的线程池是可以动态调整这个尺寸的。</p><p>——————————————全文完—————————————————–</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;为什么需要线程池&quot;&gt;&lt;a href=&quot;#为什么需要线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么需要线程池&quot;&gt;&lt;/a&gt;为什么需要线程池&lt;/h5&gt;&lt;p&gt;在那些情况下我们会使用到多线程：&lt;/p&gt;
&lt;p&gt;1.阻塞调用（阻塞IO调用、等待资源）&lt;br
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Mutex的实现原理</title>
    <link href="http://yoursite.com/2018/12/26/mutex/"/>
    <id>http://yoursite.com/2018/12/26/mutex/</id>
    <published>2018-12-26T13:34:02.511Z</published>
    <updated>2018-12-26T13:31:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>互斥锁主要用于实现内核中的互斥访问功能。内核互斥锁是在原子 API 之上实现的，但这对于内核用户是不可见的。对它的访问必须遵循一些规则：同一时间只能有一个任务持有互斥锁，而且只有这个任务可以对互斥锁进行解锁。互斥锁不能进行递归锁定或解锁。一个互斥锁对象必须通过其API初始化，而不能使用memset或复制初始化。一个任务在持有互斥锁的时候是不能结束的。互斥锁所使用的内存区域是不能被释放的。使用中的互斥锁是不能被重新初始化的。并且互斥锁不能用于中断上下文。但是互斥锁比当前的内核信号量选项更快，并且更加紧凑，因此如果它们满足您的需求，那么它们将是您明智的选择。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.15</span> kernel</span><br><span class="line">include/linux/mutex.h</span><br><span class="line">struct mutex &#123;</span><br><span class="line">atomic_long_towner;</span><br><span class="line">spinlock_twait_lock;</span><br><span class="line">#ifdef CONFIG_MUTEX_SPIN_ON_OWNER</span><br><span class="line">struct optimistic_spin_queue osq; <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line">#endif</span><br><span class="line">struct list_headwait_list;</span><br><span class="line">#ifdef CONFIG_DEBUG_MUTEXES</span><br><span class="line"><span class="keyword">void</span>*magic;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="line">struct lockdep_mapdep_map;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1.owner<br>锁的持有者, 如果没有task持有则为0，否则是获取到锁的pid。<br>2.wait_lock<br>自旋锁，内核用来保护代码执行区的。<br>3.wait_list<br>等待队列，是一个链表，如果task没有获取owner == 0，则把task加入到这个等待队列，并且将进程设置为TASK_UNINTERRUPTIBLE状态，直到被wakeup调用唤醒执行。</p><h3 id="mutex-lock"><a href="#mutex-lock" class="headerlink" title="mutex_lock"></a>mutex_lock</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux/kener/locking/mutex.c:252</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mutex_lock - acquire the mutex</span></span><br><span class="line"><span class="comment"> * @lock: the mutex to be acquired</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Lock the mutex exclusively for this task. If the mutex is not</span></span><br><span class="line"><span class="comment"> * available right now, it will sleep until it can get it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The mutex must later on be released by the same task that</span></span><br><span class="line"><span class="comment"> * acquired it. Recursive locking is not allowed. The task</span></span><br><span class="line"><span class="comment"> * may not exit without first unlocking the mutex. Also, kernel</span></span><br><span class="line"><span class="comment"> * memory where the mutex resides must not be freed with</span></span><br><span class="line"><span class="comment"> * the mutex still locked. The mutex must first be initialized</span></span><br><span class="line"><span class="comment"> * (or statically defined) before it can be locked. memset()-ing</span></span><br><span class="line"><span class="comment"> * the mutex to 0 is not allowed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (The CONFIG_DEBUG_MUTEXES .config option turns on debugging</span></span><br><span class="line"><span class="comment"> * checks that will enforce the restrictions and will also do</span></span><br><span class="line"><span class="comment"> * deadlock debugging)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is similar to (but not equivalent to) down().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __sched mutex_lock(struct mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!__mutex_trylock_fast(lock))</span><br><span class="line">__mutex_lock_slowpath(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline bool __mutex_trylock_fast(struct mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long curr = (unsigned long)current;</span><br><span class="line">unsigned long zero = <span class="number">0</span>UL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (atomic_long_try_cmpxchg_acquire(&amp;lock-&gt;owner, &amp;zero, curr))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lock a mutex (possibly interruptible), slowpath:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline int __sched</span><br><span class="line">__mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,</span><br><span class="line">    struct lockdep_map *nest_lock, unsigned long ip,</span><br><span class="line">    struct ww_acquire_ctx *ww_ctx, <span class="keyword">const</span> bool use_ww_ctx)</span><br><span class="line">&#123;</span><br><span class="line">struct mutex_waiter waiter;</span><br><span class="line">bool first = <span class="literal">false</span>;</span><br><span class="line">struct ww_mutex *ww;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line">ww = container_of(lock, struct ww_mutex, base);</span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx) &#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(ww_ctx == READ_ONCE(ww-&gt;ctx)))</span><br><span class="line"><span class="keyword">return</span> -EALREADY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reset the wounded flag after a kill. No other process can</span></span><br><span class="line"><span class="comment"> * race and wound us here since they can't have a valid owner</span></span><br><span class="line"><span class="comment"> * pointer if we don't have any locks held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ww_ctx-&gt;acquired == <span class="number">0</span>)</span><br><span class="line">ww_ctx-&gt;wounded = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preempt_disable();</span><br><span class="line">mutex_acquire_nest(&amp;lock-&gt;dep_map, subclass, <span class="number">0</span>, nest_lock, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock) ||</span><br><span class="line">    mutex_optimistic_spin(lock, ww_ctx, use_ww_ctx, NULL)) &#123;</span><br><span class="line"><span class="comment">/* got the lock, yay! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx)</span><br><span class="line">ww_mutex_set_context_fastpath(ww, ww_ctx);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * After waiting to acquire the wait_lock, try again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock)) &#123;</span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx)</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line"></span><br><span class="line">goto skip_wait;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug_mutex_lock_common(lock, &amp;waiter);</span><br><span class="line"></span><br><span class="line">lock_contended(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!use_ww_ctx) &#123;</span><br><span class="line"><span class="comment">/* add waiting tasks to the end of the waitqueue (FIFO): */</span></span><br><span class="line">__mutex_add_waiter(lock, &amp;waiter, &amp;lock-&gt;wait_list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEBUG_MUTEXES</span><br><span class="line">waiter.ww_ctx = MUTEX_POISON_WW_CTX;</span><br><span class="line">#endif</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add in stamp order, waking up waiters that must kill</span></span><br><span class="line"><span class="comment"> * themselves.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = __ww_mutex_add_waiter(&amp;waiter, lock, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">goto err_early_kill;</span><br><span class="line"></span><br><span class="line">waiter.ww_ctx = ww_ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">waiter.task = current;</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Once we hold wait_lock, we're serialized against</span></span><br><span class="line"><span class="comment"> * mutex_unlock() handing the lock off to us, do a trylock</span></span><br><span class="line"><span class="comment"> * before testing the error conditions to make sure we pick up</span></span><br><span class="line"><span class="comment"> * the handoff.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock))</span><br><span class="line">goto acquired;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check for signals and kill conditions while holding</span></span><br><span class="line"><span class="comment"> * wait_lock. This ensures the lock cancellation is ordered</span></span><br><span class="line"><span class="comment"> * against mutex_unlock() and wake-ups do not go missing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal_pending_state(state, current))) &#123;</span><br><span class="line">ret = -EINTR;</span><br><span class="line">goto err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx) &#123;</span><br><span class="line">ret = __ww_mutex_check_kill(lock, &amp;waiter, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">goto err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ww_mutex needs to always recheck its position since its waiter</span></span><br><span class="line"><span class="comment"> * list is not FIFO ordered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((use_ww_ctx &amp;&amp; ww_ctx) || !first) &#123;</span><br><span class="line">first = __mutex_waiter_is_first(lock, &amp;waiter);</span><br><span class="line"><span class="keyword">if</span> (first)</span><br><span class="line">__mutex_set_flag(lock, MUTEX_FLAG_HANDOFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Here we order against unlock; we must either see it change</span></span><br><span class="line"><span class="comment"> * state back to RUNNING and fall through the next schedule(),</span></span><br><span class="line"><span class="comment"> * or we must see its unlock and acquire.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock) ||</span><br><span class="line">    (first &amp;&amp; mutex_optimistic_spin(lock, ww_ctx, use_ww_ctx, &amp;waiter)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">&#125;</span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">acquired:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wound-Wait; we stole the lock (!first_waiter), check the</span></span><br><span class="line"><span class="comment"> * waiters as anyone might want to wound us.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!ww_ctx-&gt;is_wait_die &amp;&amp;</span><br><span class="line">    !__mutex_waiter_is_first(lock, &amp;waiter))</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_remove_waiter(lock, &amp;waiter, current);</span><br><span class="line"><span class="keyword">if</span> (likely(list_empty(&amp;lock-&gt;wait_list)))</span><br><span class="line">__mutex_clear_flag(lock, MUTEX_FLAGS);</span><br><span class="line"></span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line"></span><br><span class="line">skip_wait:</span><br><span class="line"><span class="comment">/* got the lock - cleanup and rejoice! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx)</span><br><span class="line">ww_mutex_lock_acquired(ww, ww_ctx);</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">mutex_remove_waiter(lock, &amp;waiter, current);</span><br><span class="line">err_early_kill:</span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line">mutex_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, ip);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码可以看出，如果task获取不到锁，则先把自己加入到等待队列，并且设置进程状态为TASK_UNINTERRUPTIBLE，让出CPU的执行。</p><h3 id="mutex-unlock"><a href="#mutex-unlock" class="headerlink" title="mutex_unlock"></a>mutex_unlock</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mutex_unlock - release the mutex</span></span><br><span class="line"><span class="comment"> * @lock: the mutex to be released</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unlock a mutex that has been locked by this task previously.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function must not be used in interrupt context. Unlocking</span></span><br><span class="line"><span class="comment"> * of a not locked mutex is not allowed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is similar to (but not equivalent to) up().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __sched mutex_unlock(struct mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">#ifndef CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="line"><span class="keyword">if</span> (__mutex_unlock_fast(lock))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">#endif</span><br><span class="line">__mutex_unlock_slowpath(lock, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Release the lock, slowpath:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __sched __mutex_unlock_slowpath(struct mutex *lock, unsigned long ip)</span><br><span class="line">&#123;</span><br><span class="line">struct task_struct *next = NULL;</span><br><span class="line">DEFINE_WAKE_Q(wake_q);</span><br><span class="line">unsigned long owner;</span><br><span class="line"></span><br><span class="line">mutex_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, ip);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Release the lock before (potentially) taking the spinlock such that</span></span><br><span class="line"><span class="comment"> * other contenders can get on with things ASAP.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Except when HANDOFF, in that case we must not clear the owner field,</span></span><br><span class="line"><span class="comment"> * but instead set it to the top waiter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">owner = atomic_long_read(&amp;lock-&gt;owner);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">unsigned long old;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEBUG_MUTEXES</span><br><span class="line">DEBUG_LOCKS_WARN_ON(__owner_task(owner) != current);</span><br><span class="line">DEBUG_LOCKS_WARN_ON(owner &amp; MUTEX_FLAG_PICKUP);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (owner &amp; MUTEX_FLAG_HANDOFF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">old = atomic_long_cmpxchg_release(&amp;lock-&gt;owner, owner,</span><br><span class="line">  __owner_flags(owner));</span><br><span class="line"><span class="keyword">if</span> (old == owner) &#123;</span><br><span class="line"><span class="keyword">if</span> (owner &amp; MUTEX_FLAG_WAITERS)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">owner = old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">debug_mutex_unlock(lock);</span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;lock-&gt;wait_list)) &#123;</span><br><span class="line"><span class="comment">/* get the first entry from the wait-list: */</span></span><br><span class="line">struct mutex_waiter *waiter =</span><br><span class="line">list_first_entry(&amp;lock-&gt;wait_list,</span><br><span class="line"> struct mutex_waiter, list);</span><br><span class="line"></span><br><span class="line">next = waiter-&gt;task;</span><br><span class="line"></span><br><span class="line">debug_mutex_wake_waiter(lock, waiter);</span><br><span class="line">wake_q_add(&amp;wake_q, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (owner &amp; MUTEX_FLAG_HANDOFF)</span><br><span class="line">__mutex_handoff(lock, next);</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line"></span><br><span class="line">wake_up_q(&amp;wake_q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放锁时，先检查ower是否是自己，如果是的，则从等待队列（wait_list）拿取第一个task，并且调用wake_up_q去唤醒task，task恢复执行。</p><p>——————————————全文完—————————————————–</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;互斥锁主要用于实现内核中的互斥访问功能。内核互斥锁是在原子 API 之上实现的，但这对于内核用户是不可见的。对它的访问必须遵循一些规则：同一时间只能有一个任务持有互斥锁，而且只有这个任务可以对互斥锁进行解锁。互斥锁不能进行递归锁定或解锁。一个互斥锁对象必须通过其API初始化
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>协程</title>
    <link href="http://yoursite.com/2018/12/26/xiecheng/"/>
    <id>http://yoursite.com/2018/12/26/xiecheng/</id>
    <published>2018-12-26T12:39:35.468Z</published>
    <updated>2018-12-26T12:39:35.464Z</updated>
    
    <content type="html"><![CDATA[<p>协程，英文（coroutines）,是一种比线程更加轻量级的存在。</p><ol><li>一个进程可以拥有多个线程，一个线程也可以拥有多个协程。</li><li>最重要的是，协程不是被操作系统内核所管理（内核调用），而完全是由用户态程序所控制（用户态执行）。</li><li>这样带来的好处就是性能得到了很大的提升，不像进程线程切换带来的消耗资源，cpu的调度。</li><li>协程的开销远远小于线程的开销。</li><li>协程并不想线程需要锁机制，协程中控制共享资源不加锁，只需要判断状态就好，所以执行效率比多线程高的多。</li></ol><p>因为协程是一个线程执行，那怎么利用多核CPU呢？<br>        最简单的方法就是多进程+协程，既充分利用多核，又充分发挥协程的高效率。</p><p>==协程允许我们写同步代码的逻辑，却做着异步的事，避免回调嵌套，使得代码逻辑清晰（协程是追求极限性能和优美的代码结构产物）==</p><p><em>参考手册</em> : <a href="http://ntycobook.ntytcp.com/" target="_blank" rel="noopener">协程详细介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;协程，英文（coroutines）,是一种比线程更加轻量级的存在。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个进程可以拥有多个线程，一个线程也可以拥有多个协程。&lt;/li&gt;
&lt;li&gt;最重要的是，协程不是被操作系统内核所管理（内核调用），而完全是由用户态程序所控制（用户态执行）。&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://yoursite.com/2018/12/26/git/"/>
    <id>http://yoursite.com/2018/12/26/git/</id>
    <published>2018-12-26T12:36:16.198Z</published>
    <updated>2018-12-26T12:36:16.198Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-git与SVN的区别"><a href="#1-git与SVN的区别" class="headerlink" title="1.git与SVN的区别"></a>1.git与SVN的区别</h5><p>git是分布式版本控制系统。必须客户端连接上服务端才能正常工作。<br>svn是集中式版本控制系统。每台机器就是一个单独运行的库，方便高效便捷的开发。</p><h5 id="2-git常用命令"><a href="#2-git常用命令" class="headerlink" title="2.git常用命令"></a>2.git常用命令</h5><p>git config -global ; 配置环境信息<br>git init ；将目录变成git管理的仓库，初始化仓库<br>git add ;提交到暂存区<br>git commit; 提交到本地仓<br>git status ;查看仓库是否有文件未提交<br>git diff 文件名；比较文件<br>git reset -hard HEAD~100;回到前100个版本<br>git reset -hard(版本号)；回到指定的版本号<br>git  reflog；取得版本号</p><p>git checkout -b ;创建并且换到分支<br>git branch dev ；创建分支<br>git checkout dev；切换分支<br>git merge dev; 将dev分支上的内容合并到主支master上<br>git branch -d name;删除分支</p><p><em>参考手册</em> :  <a href="http://47.106.79.26:4000/" target="_blank" rel="noopener">git详细介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-git与SVN的区别&quot;&gt;&lt;a href=&quot;#1-git与SVN的区别&quot; class=&quot;headerlink&quot; title=&quot;1.git与SVN的区别&quot;&gt;&lt;/a&gt;1.git与SVN的区别&lt;/h5&gt;&lt;p&gt;git是分布式版本控制系统。必须客户端连接上服务端才能正常工
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Lua脚本式编程</title>
    <link href="http://yoursite.com/2018/12/26/lua/"/>
    <id>http://yoursite.com/2018/12/26/lua/</id>
    <published>2018-12-26T08:58:27.539Z</published>
    <updated>2018-12-26T08:57:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h3><p>单行注释：–<br>多行注释：–[[ 内容–]]</p><p>lua最好<strong>不要使用</strong>下划线加大字母的标识符，因为lua的保留字是这样的。<br>lua不允许使用特殊字符如@$%来定义标志符。</p><p>默认情况下，变量总是认为全局。<br>删除全局变量，只需要将变量赋值nil .</p><p>lua的数据类型：nil 、boolean、number、string、userdata、function、thread和table。</p><p>nil作为比较时应该加上双引号，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type(x) == &quot;nil&quot;</span><br></pre></td></tr></table></figure><p>boolean类型只有两个可选值：true 和 false<br>lua把false和nil看作是“假”，其他都为真。</p><p>number（数字）：lua只有一种number类型，double双精度类型，默认类型可以修改luaconf.h里面的定义。</p><p>string（字符串）：由一对双引号或单引号来表示，也可以用2个方括号“[[ ]]”来表示“一块”字符串。</p><p>对一个数字字符串上进行算术操作时，lua会尝试将这个数字字符串转换成一个数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(“<span class="number">2</span>”+<span class="number">6</span>)   <span class="number">8.0</span></span><br><span class="line">print(<span class="string">"2"</span>+<span class="string">"6"</span>) <span class="number">8.0</span></span><br></pre></td></tr></table></figure><p>字符串连接使用的是 . .如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"a"</span> .. <span class="string">"b"</span>)  ab</span><br><span class="line">print(<span class="number">157</span> .. <span class="number">428</span>) <span class="number">157428</span></span><br></pre></td></tr></table></figure><p>#计算字符串的长度。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len =<span class="string">"www.runoob.com"</span></span><br><span class="line">print(#len)                 14</span><br><span class="line">print(#"www.runoob.com") 14</span><br></pre></td></tr></table></figure><h3 id="2-宿主语言C-C"><a href="#2-宿主语言C-C" class="headerlink" title="2.宿主语言C/C++"></a>2.宿主语言C/C++</h3><p>==虚拟栈==<br>        无论何时lua调用C，被调用的函数都得到一个新的栈，这个栈独立于C函数本身的栈，也独立于之前的栈。<br>        方便起见，所有正对栈的API查询操作都不严格遵守栈的操作规则。而是可以用一个索引来指向栈上的任何元素：<br>        ==正的索引指的是栈上的绝对位置（从1开始），负的索引指从栈顶开始的偏移量。==</p><p>Lua_checkstack:扩大可用堆栈的尺寸<br>LUA_MINSTACK一般被定义为20。</p><p>压入栈的数据类型包括数值、字符串、指针、table、闭包。</p><p><img src="./attachments/1545806848964.drawio.html" alt="Diagram"></p><p>Lua_pushcclosure(L,func,0)；创建并压入一个闭包<br>Lua_createtable(L,0,0)；新建并压入一个表<br>Lua_pushnumber(L,343)；压入一个数字<br>Lua_pushstring(L,”Nystr”)；压入一个字符串</p><p>Lua中，number、boolean、nil、lightuserdata四种类型的值是直接存在栈上元素里和垃圾回收无关。<br>Lua中，string、table、closure、userdata、thread存在栈上元素里的只是指针，他们都会在生命周期结束后被垃圾回收。</p><p>Lua_push<em>族函数都有“创建一个类型的值并压入”的语义。<br>Lua value -&gt; C value时，是通过Lua_to</em>族api实现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">取表中元素 </span><br><span class="line"><span class="keyword">void</span> lua_getfield(lua_state *L,int index,<span class="keyword">const</span> char *K)</span><br><span class="line">操作： arr = stack[index]</span><br><span class="line">stack.push(arr[K])</span><br><span class="line">取表中键为K的元素，这里的表是由index指向的栈上的一个表。</span><br><span class="line">栈高度+<span class="number">1</span>，栈顶元素是（stack[index]）[K]。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本语法&quot;&gt;&lt;a href=&quot;#1-基本语法&quot; class=&quot;headerlink&quot; title=&quot;1.基本语法&quot;&gt;&lt;/a&gt;1.基本语法&lt;/h3&gt;&lt;p&gt;单行注释：–&lt;br&gt;多行注释：–[[ 内容–]]&lt;/p&gt;
&lt;p&gt;lua最好&lt;strong&gt;不要使用&lt;/str
      
    
    </summary>
    
    
      <category term="技术,编程语言" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP通讯知识</title>
    <link href="http://yoursite.com/2018/11/25/TCP-IP%E9%80%9A%E8%AE%AF%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/11/25/TCP-IP通讯知识/</id>
    <published>2018-11-25T07:28:09.000Z</published>
    <updated>2018-11-25T07:28:51.974Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="TCP" scheme="http://yoursite.com/categories/TCP/"/>
    
    
      <category term="TCP网络通信" scheme="http://yoursite.com/tags/TCP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>test_md</title>
    <link href="http://yoursite.com/2018/11/23/test-md/"/>
    <id>http://yoursite.com/2018/11/23/test-md/</id>
    <published>2018-11-23T12:06:11.000Z</published>
    <updated>2018-11-25T07:09:53.890Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="test" scheme="http://yoursite.com/categories/test/"/>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/11/23/hello-world/"/>
    <id>http://yoursite.com/2017/11/23/hello-world/</id>
    <published>2017-11-23T12:06:11.000Z</published>
    <updated>2018-11-25T07:23:27.648Z</updated>
    
    <content type="html"><![CDATA[<p>notshow: true<br>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;notshow: true&lt;br&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a hr
      
    
    </summary>
    
      <category term="hexo查询" scheme="http://yoursite.com/categories/hexo%E6%9F%A5%E8%AF%A2/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
