<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JackYu&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/7d6859529934feb0edca87907b1ce4e0</icon>
  <subtitle>Nothing is impossible!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-24T01:36:39.984Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JackYu</name>
    <email>1134735533@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>malloc、calloc、realloc的区别</title>
    <link href="http://yoursite.com/2019/01/24/malloc/"/>
    <id>http://yoursite.com/2019/01/24/malloc/</id>
    <published>2019-01-24T01:36:39.984Z</published>
    <updated>2019-01-24T01:36:39.984Z</updated>
    
    <content type="html"><![CDATA[<p>C语言跟内存申请相关的函数主要有 alloca、calloc、malloc、free、realloc等.<br>    <1>alloca是向栈申请内存,因此无需释放.<br>    <2>malloc分配的内存是位于堆中的,并且没有初始化内存的内容,因此基本上malloc之后,调用函数memset来初始化这部分的内存空间.<br>    <3>calloc则将初始化这部分的内存,设置为0.<br>    <4>realloc则对malloc申请的内存进行大小的调整.<br>    <5>申请的内存最终需要通过函数free来释放.<br>    当程序运行过程中malloc了,但是没有free的话,会造成内存泄漏.一部分的内存没有被使用,但是由于没有free,因此系统认为这部分内存还在使用,造成不断的向系统申请内存,使得系统可用内存不断减少.但是内存泄漏仅仅指程序在运行时,程序退出时,OS将回收所有的资源.因此,适当的重起一下程序,有时候还是有点作用.<br>【attention】<br>    三个函数的申明分别是:<br>        void<em> malloc(unsigned size);<br>        void</em> realloc(void<em> ptr, unsigned newsize);<br>        void</em> calloc(size_t numElements, size_t sizeOfElement);<br>    都在stdlib.h函数库内，它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL.<br>    (1)函数malloc()<br>        在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的首地址.<br>    (2)函数calloc()<br>        与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数，即在内存中申请numElements<em>sizeOfElement字节大小的连续地址空间.<br>    (3)函数realloc()<br>        给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度.<br>    区别:<br>    (1)函数malloc不能初始化所分配的内存空间,而函数calloc能.如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0;反之, 如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据.也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题.<br>    (2)函数calloc() 会将所分配的内存空间中的每一位都初始化为零,也就是说,如果你是为字符类型或整数类型的元素分配内存,那么这些元素将保证会被初始化为0;如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针;如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零.<br>    (3)函数malloc向系统申请分配指定size个字节的内存空间.返回类型是 void</em>类型.void<em>表示未确定类型的指针.C,C++规定，void</em> 类型可以强制转换为任何其它类型的指针.<br>    (4)realloc可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变.当然，对于缩小，则被缩小的那一部分的内容会丢失.realloc并不保证调整后的内存空间和原来的内存空间保持同一内存地址.相反，realloc返回的指针很可能指向一个新的地址.<br>    (5)realloc是从堆上分配内存的.当扩大一块内存空间时，realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平；如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上.这句话传递的一个重要的信息就是数据可能被移动.</5></4></3></2></1></p><p><a href="https://blog.csdn.net/u014170207/article/details/53126340" target="_blank" rel="noopener">reference</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C语言跟内存申请相关的函数主要有 alloca、calloc、malloc、free、realloc等.&lt;br&gt;    &lt;1&gt;alloca是向栈申请内存,因此无需释放.&lt;br&gt;    &lt;2&gt;malloc分配的内存是位于堆中的,并且没有初始化内存的内容,因此基本上malloc
      
    
    </summary>
    
    
      <category term="技术 编程语言 C" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C/"/>
    
  </entry>
  
  <entry>
    <title>C时间戳</title>
    <link href="http://yoursite.com/2019/01/12/C_time/"/>
    <id>http://yoursite.com/2019/01/12/C_time/</id>
    <published>2019-01-12T09:50:32.897Z</published>
    <updated>2019-01-12T09:50:32.897Z</updated>
    
    <content type="html"><![CDATA[<h5 id="clock-、time-、clock-gettime-和gettimeofday-函数的用法和区别"><a href="#clock-、time-、clock-gettime-和gettimeofday-函数的用法和区别" class="headerlink" title="clock()、time()、clock_gettime()和gettimeofday()函数的用法和区别"></a>clock()、time()、clock_gettime()和gettimeofday()函数的用法和区别</h5><p>1.精确度比较:</p><p>以下是各种精确度的类型转换:<br>1秒=1000毫秒(ms), 1毫秒=1/1000秒(s)；<br>1秒=1000000 微秒(μs), 1微秒=1/1000000秒(s)；<br>1秒=1000000000 纳秒(ns),1纳秒=1/1000000000秒(s)；</p><p>clock()函数的精确度是10毫秒(ms)<br>times()函数的精确度是10毫秒(ms)<br>gettimofday()函数的精确度是微秒(μs)<br>clock_gettime()函数的计量单位为十亿分之一，也就是纳秒(ns)</p><p><a href="https://www.cnblogs.com/krythur/archive/2013/02/25/2932647.html" target="_blank" rel="noopener">详情</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;clock-、time-、clock-gettime-和gettimeofday-函数的用法和区别&quot;&gt;&lt;a href=&quot;#clock-、time-、clock-gettime-和gettimeofday-函数的用法和区别&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="技术 C" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-C/"/>
    
  </entry>
  
  <entry>
    <title>STL常用API</title>
    <link href="http://yoursite.com/2019/01/04/stl/"/>
    <id>http://yoursite.com/2019/01/04/stl/</id>
    <published>2019-01-04T02:55:33.638Z</published>
    <updated>2019-01-04T02:55:33.634Z</updated>
    
    <content type="html"><![CDATA[<h5 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h5><p>常用容器：array、vector、deque、list、queue、stack<br>要求：序列的元素必须是严格的线性顺序排序。因此序列中的元素具有确定的顺序，可以执行将值插入到特定位置、删除特定区间等操作。</p><h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/array/array/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/array/array/</a></p><h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/vector/vector/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/vector/vector/</a></p><h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/deque/deque/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/deque/deque/</a></p><h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/list/list/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/list/list/</a></p><h5 id="queue（适配器）"><a href="#queue（适配器）" class="headerlink" title="queue（适配器）"></a>queue（适配器）</h5><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/queue/queue/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/queue/queue/</a></p><h5 id="stack-适配器"><a href="#stack-适配器" class="headerlink" title="stack(适配器)"></a>stack(适配器)</h5><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/stack/stack/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/stack/stack/</a></p><p>C/C++STL常用容器用法总结：<a href="https://blog.csdn.net/weixin_41162823/article/details/79759081" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41162823/article/details/79759081</a></p><h5 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h5><p>关联容器与序列容器有着根本性的不同，序列容器的元素是按照在容器中的位置来顺序保存和访问的，而关联容器的元素是按关键元素来保存和访问的。关联容器支持高效的关键字查找与访问。两个主要的关联容器类型是map与set。</p><p>1.set<br>1.1 简介：set里面每个元素只存有一个key，它支持高效的关键字查询操作。set对应数学中的“集合”。</p><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/set/set/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/set/set/</a></p><p>1.2 特点：</p><p>储存同一类型的数据元素（这点和vector、queue等其他容器相同）<br>每个元素的值都唯一（没有重复的元素）<br>根据元素的值自动排列大小（有序性）<br>无法直接修改元素<br>高效的插入删除操作<br>1.3 声明：set<t> a</t></p><p>set<int> a={0,1,6,2,3};<br>for(auto it = a.begin();it != a.end();it++)    cout &lt;&lt; *it;//输出01236<br>1.4 常用函数</int></p><p>以下设 set<t> a,其中a是T类型的set容器。</t></p><p>表达式</p><p>返回类型</p><p>说明</p><p>a.begin()</p><p>返回指向第一个元素的迭代器</p><p>a.end()</p><p>返回指向超尾的迭代器</p><p>a.clear()</p><p>清空容器a</p><p>a.empty()</p><p>判断容器是否为空</p><p>a.size()</p><p>返回当前容器元素个数</p><p>a.count(x)</p><pre><code>返回容器a中元素x的个数</code></pre><p>1.6 插入元素：</p><p>a.insert(x) :其中a为set<t>型容器，x为T型变量<br>    set<int> a={0,1,2,9};<br>    a.insert(6);<br>    for(auto it = a.begin();it != a.end();it++)    cout &lt;&lt; <em>it;//输出01269<br>a.insert(first,second):其中first为指向区间左侧的迭代器，second为指向右侧的迭代器。作用是将first到second区间内元素插入到a（左闭右开）。<br>set<int> a = {0,1,2,9};<br>set<int> b = {3,4,5};<br>auto first = b.begin();<br>auto second = b.end();<br>a.insert(first,second);<br>for(auto it = a.begin();it != a.end();it++)    cout &lt;&lt; </int></int></em>it;<br>插入元素会自动插入到合适的位置，使整个集合有序</int></t></p><p>1.7 删除元素：</p><p>a.erase(x)：删除建值为x的元素<br>a.erase(first,second)：删除first到second区间内的元素（左闭右开）<br>a.erase(iterator):删除迭代器指向的元素<br>set中的删除操作是不进行任何的错误检查的，比如定位器的是否合法等等，所以用的时候自己一定要注意。<br>1.8 lower_bound 和 upper_bound 迭代器：</p><p>lower_bound（x1）:返回第一个不小于键参数x1的元素的迭代器<br>upper_bound（x2）:返回最后一个大于键参数x2的元素的迭代器<br>由以上俩个函数，可以得到一个目标区间，即包含集合中从’x1’到’x2’的所有元素</p><p>#include<iostream></iostream></p><p>#include<set></set></p><p>#include<algorithm><br>using namespace std;<br>int main()<br>{<br>    set<int> a = {0,1,2,5,9};<br>    auto it2 = a.lower_bound(2);//返回指向第一个大于等于x的元素的迭代器<br>    auto it = a.upper_bound(2);//返回指向第一个大于x的元素的迭代器<br>    cout &lt;&lt; <em>it2 &lt;&lt; endl;//输出为2<br>    cout &lt;&lt; </em>it &lt;&lt; endl;//输出为5<br>    return 0;<br>}<br>1.9 set_union() 与 set_intersection()</int></algorithm></p><p>set_union():对集合取并集</p><p>set_union()函数接受5个迭代器参数。前两个迭代器定义了第一个集合的区间，接下来的俩个迭代器定义了第二个集合的区间，最后一个迭代器是输出迭代器，指出将结果集合复制到什么位置。例如：要将A与B的集合复制到C中，可以这样写：</p><p>#include<iostream></iostream></p><p>#include<set></set></p><p>#include<algorithm><br>using namespace std;<br>int main()<br>{<br>    set<int> A = {1,2,3}, B= {2,4,5},C;<br>    set_union(A.begin(),A.end(),B.begin(),B.end(),<br>            insert_iterator&lt;set<int> &gt;(C,C.begin()));<br>    for(auto it = C.begin();it != C.end();it++)<br>        cout &lt;&lt; *it &lt;&lt;” “;<br>    return 0;<br>}<br>注意：</int></int></algorithm></p><p>其中第五个参数不能写C.begin(),原因有两个：首先，关联集合将建看作常量，所以C.begin()返回的迭代器是常量迭代器，不能作为输出迭代器(详情请参考迭代器相关概念)。其次，与copy()相同，set_union()将覆盖容器中已有的数据，并且要求容器用足够的空间容纳新信息，而C不满足，因为它是空的。</p><p>解决方法：可以创建一个匿名的insert_iterator,将信息复制给C。如上述代码所为。另一种方法如下：</p><p>set_union(A.begin(),A.end(),B.begin(),B.end(),<br>        inserter(C,C.begin()));//调用inserter<br>set_intersection():对集合取交集，它的接口与set_union()相同。</p><p>附：使用set_union()和set_intersection()还有另一种技巧。由于需要五个迭代器，看起来会很累赘和麻烦，如果多次使用会增加出错的几率，所以我们可以试试用宏定义的方法来简化代码。如下：</p><p>#include<iostream></iostream></p><p>#include<set></set></p><p>#include<algorithm><br>using namespace std;</algorithm></p><p>#define ALL(x) x.begin(),x.end()</p><p>#define INS(x) inserter(x,x.begin())<br>int main()<br>{<br>    set<int> A = {1,2,3}, B= {2,4,5},C;<br>    set_union(ALL(A),ALL(B),INS(C));<br>    for(auto it = C.begin();it != C.end();it++)<br>        cout &lt;&lt; *it &lt;&lt;” “;<br>    return 0;<br>}<br>其中使用到了宏定义。<br>1.10 set的几个问题：</int></p><p>（1）为何map和set的插入删除效率比用其他序列容器高？</p><p>因为对于关联容器来说，不需要做内存拷贝和内存移动。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。</p><p>（2）为何每次insert之后，以前保存的iterator不会失效？</p><p>iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则：不要使用过期的iterator。</p><p>（3）当数据元素增多时，set的插入和搜索速度变化如何？</p><p>如果你知道log2的关系你应该就彻底了解这个答案。在set中查找是使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个元素，最多比较5次。那么有10000个呢？最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次。看见了吧，当数据量增大一倍的时候，搜索次数只不过多了1次，多了1/14的搜索时间而已。你明白这个道理后，就可以安心往里面放入元素了。</p><p>2.map<br>2.1 简介：如果说set对应数学中的“集合”，那么map对应的就是“映射”。map是一种key-value型容器，其中key是关键字，起到索引作用，而value就是其对应的值。与set不同的是它支持下标访问。头文件是<map></map></p><p>具体语法参考：<br><a href="http://www.cplusplus.com/reference/map/map/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/map/map/</a></p><p>2.2 特点：</p><p>增加和删除节点对迭代器的影响很小(高效的插入与删除)<br>快速的查找（同set）<br>自动建立key-value的对应，key和value可以是任何你需要的类型<br>可以根据key修改value的记录<br>支持下标[]操作<br>2.3 声明：map&lt;T1,T2&gt; m</p><p>其中T1是key类型，T2是value类型，m就是一个T1-T2的key-value。</p><p>map&lt;string,int&gt; m;//声明一个key为string，value为int的map型容器<br>下述代码更清楚的解释了map容器的特点：</p><p>#include<iostream></iostream></p><p>#include<map><br>using namespace std;<br>int main()<br>{<br>    map&lt;string,int&gt; m;<br>    m[“abc”] = 5;<br>    m[“cdf”] = 6;<br>    m[“b”] = 1;<br>    for(auto it = m.begin();it != m.end();it++)<br>        cout &lt;&lt; it-&gt;first &lt;&lt;” “ &lt;&lt; it-&gt;second &lt;&lt; endl;<br>    return 0;<br>}<br>在上述代码中，m容器被按照key的字典序升序排列了，而且我们可以通过将key当作索引来获取value的值。（同时这也是一种插入方法）</map></p><p>2.4 插入元素：</p><p>使用insert()函数插入pair类型的元素<br>使用下标操作向map容器中插入元素<br>map&lt;string,int&gt; m;<br>    m.insert(make_pair(“b”,6));//insert插入<br>    m[“a”] = 5;//使用下标插入<br>2.5 删除元素：</p><p>erase(key):删除键为key的元素<br>erase(it):删除迭代器it所指向的元素</p><p>#include<iostream></iostream></p><p>#include<map><br>using namespace std;<br>int main()<br>{<br>    map&lt;string,int&gt; m;<br>    m.insert(make_pair(“b”,6));<br>    m[“a”] = 5;<br>    m[“c”] = 5;<br>    m[“d”] = 5;<br>    m[“e”] = 5;</map></p><pre><code>m.erase(&quot;d&quot;);auto pr = m.begin();m.erase(pr);for(auto it = m.begin();it != m.end();it++)    cout &lt;&lt; it-&gt;first &lt;&lt;&quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;return 0;</code></pre><p>}<br>2.6 map容器的遍历：</p><p>使用迭代器遍历（代码如上）<br>注：使用迭代器遍历map容器，其中每一个元素可以看成是pair类型的，访问第一个位置的key值可以用it-&gt;first访问，第二个位置value的值可以用it-&gt;second访问，其中it是指向该元素的迭代器。<br>2.7 常用函数：</p><p>下表中m为map类型的容器，it为和m同类型的迭代器，key表示该类型的一个键。</p><p>表达式</p><p>返回类型</p><p>说明</p><p>m.Count(key)</p><p>返回map中key出现的次数（0或1）</p><p>m.find(key)</p><p>迭代器</p><p>返回指向key位置的迭代器.若无则返回m.end()</p><p>m.insert(make_pair( ) )</p><p>插入一个元素(必须以pair形式插入)</p><p>m.erase(it)</p><p>删除迭代器it所指向的元素</p><p>m.erase(key)</p><p>删除键值为key的元素</p><p>m.size()</p><p>返回m中元素的个数</p><p>m.clear()</p><p>清空m容器</p><p>m.empty()</p><p>bool</p><p>判断容器是否为空。空则返回true</p><p>m.lower_bound(key)</p><p>迭代器</p><p>返回指向第一个键值不小于key的元素的迭代器</p><p>m.upper_bound(key)</p><p>迭代器</p><p>返回指向第一个键值大于key的元素的迭代器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;序列容器&quot;&gt;&lt;a href=&quot;#序列容器&quot; class=&quot;headerlink&quot; title=&quot;序列容器&quot;&gt;&lt;/a&gt;序列容器&lt;/h5&gt;&lt;p&gt;常用容器：array、vector、deque、list、queue、stack&lt;br&gt;要求：序列的元素必须是严格的线性顺序
      
    
    </summary>
    
    
      <category term="技术 技术 编程语言 C++11" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C-11/"/>
    
  </entry>
  
  <entry>
    <title>MySQL远程连接问题</title>
    <link href="http://yoursite.com/2019/01/04/mysql_1/"/>
    <id>http://yoursite.com/2019/01/04/mysql_1/</id>
    <published>2019-01-04T02:47:48.016Z</published>
    <updated>2019-01-04T02:45:38.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="如何让MySQL可以远程连接"><a href="#如何让MySQL可以远程连接" class="headerlink" title="如何让MySQL可以远程连接"></a>如何让MySQL可以远程连接</h5><p>1.本地防火墙是否关闭<br>    ufw status;</p><p>2.mysql配置文件my.cnf<br>    注释掉 #bind 127.0.0.1 绑定本地地址</p><p>3.MySQL数据库user远程权限<br>    grant all privileges on <em>.</em> to ‘root‘@’%’ identified by ‘123456’ with grant option;<br>flush privileges;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;如何让MySQL可以远程连接&quot;&gt;&lt;a href=&quot;#如何让MySQL可以远程连接&quot; class=&quot;headerlink&quot; title=&quot;如何让MySQL可以远程连接&quot;&gt;&lt;/a&gt;如何让MySQL可以远程连接&lt;/h5&gt;&lt;p&gt;1.本地防火墙是否关闭&lt;br&gt;    ufw
      
    
    </summary>
    
    
      <category term="mysql 数据库" scheme="http://yoursite.com/tags/mysql-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>C++11新特性</title>
    <link href="http://yoursite.com/2018/12/27/c++11featrues/"/>
    <id>http://yoursite.com/2018/12/27/c++11featrues/</id>
    <published>2018-12-27T09:25:59.968Z</published>
    <updated>2018-12-27T09:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1.Lambda 表达式"></a>1.Lambda 表达式</h5><p>Lambda 表达式就是用于创建<strong>匿名函数</strong>的。<br>为什么说 lambda 表达式如此激动人心呢？举一个例子。标准 C++ 库中有一个常用算法的库，其中提供了很多算法函数，比如 sort() 和 find()。这些函数通常需要提供一个“谓词函数 predicate function”。所谓谓词函数，就是进行一个操作用的临时函数。比如 find() 需要一个谓词，用于查找元素满足的条件；能够满足谓词函数的元素才会被查找出来。<strong>这样的谓词函数，使用临时的匿名函数，既可以减少函数数量，又会让代码变得清晰易读。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;<span class="keyword">return</span>-type &#123;body&#125;</span><br></pre></td></tr></table></figure><p>最简单的例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> abssort(float *x, unsigned N)</span><br><span class="line">&#123;</span><br><span class="line">  std::sort(x,</span><br><span class="line">            x + N,</span><br><span class="line">            [](float a, float b) &#123; <span class="keyword">return</span> std::abs(a) &lt; std::abs(b); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要注意：</p><ol><li>返回值类型-&gt;return-type可以省略，由语言自动推导，但前提是只有当 lambda 表达式中的语句“足够简单”，才能自动推断返回值类型。</li><li>引入 lambda 表达式的前导符是一对方括号，称为 lambda 引入符（lambda-introducer）。lambda 表达式可以使用与其相同范围 scope 内的变量。这个引入符的作用就是表明，其后的 lambda 表达式以何种方式使用（正式的术语是“捕获”）这些变量（这些变量能够在 lambda 表达式中被捕获，其实就是构成了一个闭包）。</li><li>捕获类型可以以下类型：</li></ol><ul><li>[]  // 不捕获任何外部变量</li><li>[=] // 以值的形式捕获所有外部变量</li><li>[&amp;] // 以引用形式捕获所有外部变量</li><li>[x, &amp;y] // x 以传值形式捕获，y 以引用形式捕获</li><li>[=, &amp;z]// z 以引用形式捕获，其余变量以传值形式捕获</li><li>[&amp;, x] // x 以值的形式捕获，其余变量以引用形式捕获</li></ul><ol start="4"><li>对于[=]或[&amp;]的形式，lambda 表达式可以直接使用  this 指针 。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</li><li>对于下面的例子，[=]意味着，lambda 表达式以传值的形式捕获外部变量。C++ 11 标准说，如果以传值的形式捕获外部变量，那么，lambda 体不允许修改外部变量，对 f0 的任何修改都会引发编译错误。但是，注意在 lambda 表达式前声明了mutable关键字，这就允许了 lambda 表达式体修改 f0 的值。因此不会报错。但由于是传值的，虽然在 lambda 表达式中对 f0 有了修改，但由于是传值的，外部的 f0 依然不会被修改。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float f0 = <span class="number">1.0</span>;</span><br><span class="line">std::cout &lt;&lt; [=](float f) mutable &#123; <span class="keyword">return</span> f0 += std::abs(f); &#125; (<span class="number">-3.5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">'\n'</span> &lt;&lt; f0 &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p>– 混合机制的实例如下（f0 通过引用被捕获，而其它变量，比如 f1 则是通过值被捕获）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float f0 = <span class="number">1.0</span>f;</span><br><span class="line">float f1 = <span class="number">10.0</span>f;</span><br><span class="line">std::cout &lt;&lt; [=, &amp;f0](float a) &#123; <span class="keyword">return</span> f0 += f1 + std::abs(a); &#125; (<span class="number">-3.5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">'\n'</span> &lt;&lt; f0 &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p><strong>C++引入Lambda的最主要原因:</strong><br>1）可以定义匿名函数；<br>2）<strong>编译器会把其转成函数对象</strong>；为什么以前STL中的ptr_fun()这个函数对象不能用？（ptr_fun()就是把一个自然函数转成函数对象的）原因是，ptr_fun() 的局限是其接收的自然函数只能有1或2个参数。<br>3）”闭包”，限制了别人的访问，更私有；</p><h5 id="2-自动类型推导和-decltype"><a href="#2-自动类型推导和-decltype" class="headerlink" title="2.自动类型推导和 decltype"></a>2.自动类型推导和 decltype</h5><p>在 C++03 中，声明对象的同时必须指明其类型，其实大多数情况下，声明对象的同时也会包括一个初始值，C++11 在这种情况下就能够让你声明对象时不再指定类型了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto x = <span class="number">0</span>; <span class="comment">//0 是 int 类型，所以 x 也是 int 类型  </span></span><br><span class="line">auto c = <span class="string">'a'</span>; <span class="comment">//char  </span></span><br><span class="line">auto d = <span class="number">0.5</span>; <span class="comment">//double  </span></span><br><span class="line">auto national_debt = <span class="number">14400000000000</span>LL;<span class="comment">//long long</span></span><br></pre></td></tr></table></figure><p>这个特性在对象的类型很大很长的时候很有用，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">void</span> func(<span class="keyword">const</span> vector&lt;int&gt; &amp;vi)  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="comment">//vector&lt;int&gt;::const_iterator ci=vi.begin(); </span></span><br><span class="line">  auto ci=vi.begin();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++11 也提供了从对象或表达式中“俘获”类型的机制，新的操作符 decltype 可以从一个表达式中“俘获”其结果的类型并“返回”：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vector&lt;int&gt; vi;  </span><br><span class="line">typedef decltype (vi.begin()) CIT;  </span><br><span class="line">CIT another_const_iterator;</span><br></pre></td></tr></table></figure><p><strong>注意： auto作为函数返回值时，只能用于定义函数，不能用于声明函数</strong></p><h5 id="3-统一的初始化语法"><a href="#3-统一的初始化语法" class="headerlink" title="3.统一的初始化语法"></a>3.统一的初始化语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//括号内初始化</span></span><br><span class="line">std::string s(<span class="string">"hello"</span>);  </span><br><span class="line">int m=int(); <span class="comment">//default initialization </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//等号形式的</span></span><br><span class="line">std::string s=<span class="string">"hello"</span>;  </span><br><span class="line">int x=<span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对于 POD 集合，又可以用大括号</span></span><br><span class="line">int arr[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  </span><br><span class="line">struct tm today=&#123;<span class="number">0</span>&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//最后还有构造函数的成员初始化：</span></span><br><span class="line">struct S &#123;  </span><br><span class="line"> int x;  </span><br><span class="line"> S(): x(<span class="number">0</span>) &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure><p>C++11 就用大括号一统天下了!<br>对于容器来说，终于可以摆脱 push_back() 调用了，C++11中可以直观地初始化容器了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 container initializer  </span></span><br><span class="line">vector vs&lt;string&gt;=&#123; <span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"third"</span>&#125;;  </span><br><span class="line">map singers =  </span><br><span class="line">  &#123; &#123;<span class="string">"Lady Gaga"</span>, <span class="string">"+1 (212) 555-7890"</span>&#125;,  </span><br><span class="line">    &#123;<span class="string">"Beyonce Knowles"</span>, <span class="string">"+1 (212) 555-0987"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>而类中的数据成员初始化也得到了支持：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">  int a=<span class="number">7</span>; <span class="comment">//C++11 only  </span></span><br><span class="line">public:  </span><br><span class="line">  C();  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-deleted-函数和-defaulted-函数"><a href="#4-deleted-函数和-defaulted-函数" class="headerlink" title="4.deleted 函数和 defaulted 函数"></a>4.deleted 函数和 defaulted 函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct A  </span><br><span class="line">&#123;  </span><br><span class="line">    A()=<span class="keyword">default</span>; <span class="comment">//C++11  </span></span><br><span class="line">    virtual ~A()=<span class="keyword">default</span>; <span class="comment">//C++11  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>=default; 指示编译器生成该函数的默认实现。这有两个好处：一是让程序员轻松了，少敲键盘，二是有更好的性能。<br>与 defaulted 函数相对的就是 deleted 函数, 实现 non copy-able 防止对象拷贝，要想禁止拷贝，用 =deleted 声明一下两个关键的成员函数就可以了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int func()=<span class="keyword">delete</span>;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//防止对象拷贝的实现</span></span><br><span class="line">struct NoCopy  </span><br><span class="line">&#123;  </span><br><span class="line">    NoCopy &amp; operator =(<span class="keyword">const</span> NoCopy &amp;) = <span class="keyword">delete</span>;  </span><br><span class="line">    NoCopy(<span class="keyword">const</span> NoCopy &amp;) = <span class="keyword">delete</span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">NoCopy a;  </span><br><span class="line">NoCopy b(a); <span class="comment">//编译错误，拷贝构造函数是 deleted 函数</span></span><br></pre></td></tr></table></figure><h5 id="5-nullptr"><a href="#5-nullptr" class="headerlink" title="5.nullptr"></a>5.nullptr</h5><p>nullptr 是一个新的 C++ 关键字，它是空指针常量，它是用来替代高风险的 NULL 宏和 0 字面量的。nullptr 是强类型的,所有跟指针有关的地方都可以用 nullptr，包括函数指针和成员指针：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> f(int); <span class="comment">//#1  </span></span><br><span class="line"><span class="keyword">void</span> f(char *);<span class="comment">//#2  </span></span><br><span class="line"><span class="comment">//C++03  </span></span><br><span class="line">f(<span class="number">0</span>); <span class="comment">//调用的是哪个 f?  </span></span><br><span class="line"><span class="comment">//C++11  </span></span><br><span class="line">f(nullptr) <span class="comment">//毫无疑问，调用的是 #2  </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> char *pc=str.c_str(); <span class="comment">//data pointers  </span></span><br><span class="line"><span class="keyword">if</span> (pc != nullptr)  </span><br><span class="line">  cout &lt;&lt; pc &lt;&lt; endl;  </span><br><span class="line">int (A::*pmf)()=nullptr; <span class="comment">//指向成员函数的指针  </span></span><br><span class="line"><span class="keyword">void</span> (*pmf)()=nullptr; <span class="comment">//指向函数的指针</span></span><br></pre></td></tr></table></figure><h5 id="6-右值引用"><a href="#6-右值引用" class="headerlink" title="6.右值引用"></a>6.右值引用</h5><p>在 C++03 中的引用类型是只绑定左值的，C++11 引用一个新的引用类型叫右值引用类型，它是绑定到右值的，如临时对象或字面量。<br>增加右值引用的主要原因是为了<strong>实现 move 语义</strong>。与传统的拷贝不同，move 的意思是目标对象“窃取”原对象的资源，并将源置于“空”状态。当拷贝一个对象时，其实代价昂贵且无必要，move 操作就可以替代它。如在 string 交换的时候，使用 move 意义就有巨大的性能提升，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原方案很慢，因为需要申请内存，然后拷贝字符；</span></span><br><span class="line">[cpp] view plain copy</span><br><span class="line"><span class="keyword">void</span> naiveswap(string &amp;a, string &amp; b)  </span><br><span class="line">&#123;  </span><br><span class="line">    string temp = a;  </span><br><span class="line">    a=b;  </span><br><span class="line">    b=temp;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用move就只需要交换两个数据成员，无须申请、释放内存和拷贝字符数组；</span></span><br><span class="line"><span class="keyword">void</span> moveswapstr(string&amp; empty, string &amp; filled)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//pseudo code, but you get the idea  </span></span><br><span class="line">    size_t sz=empty.size();  </span><br><span class="line">    <span class="keyword">const</span> char *p= empty.data();  </span><br><span class="line">    <span class="comment">//move filled's resources to empty  </span></span><br><span class="line">    empty.setsize(filled.size());  </span><br><span class="line">    empty.setdata(filled.data());  </span><br><span class="line">    <span class="comment">//filled becomes empty  </span></span><br><span class="line">    filled.setsize(sz);  </span><br><span class="line">    filled.setdata(p);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现支持 move 的类，需要声明 move 构造函数和 move 赋值操作符，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    Movable (Movable&amp;&amp;); <span class="comment">//move constructor  </span></span><br><span class="line">    Movable&amp;&amp; operator=(Movable&amp;&amp;); <span class="comment">//move assignment operator  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="C-11-的标准库"><a href="#C-11-的标准库" class="headerlink" title="C++11 的标准库"></a>C++11 的标准库</h5><p>线程库、新的智能指针类、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-Lambda-表达式&quot;&gt;&lt;a href=&quot;#1-Lambda-表达式&quot; class=&quot;headerlink&quot; title=&quot;1.Lambda 表达式&quot;&gt;&lt;/a&gt;1.Lambda 表达式&lt;/h5&gt;&lt;p&gt;Lambda 表达式就是用于创建&lt;strong&gt;匿名函数&lt;/
      
    
    </summary>
    
    
      <category term="技术 编程语言 C++11" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C-11/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="http://yoursite.com/2018/12/27/docker/"/>
    <id>http://yoursite.com/2018/12/27/docker/</id>
    <published>2018-12-27T02:50:02.862Z</published>
    <updated>2018-12-27T02:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="docker是什么？"><a href="#docker是什么？" class="headerlink" title="docker是什么？"></a>docker是什么？</h5><p>docker是一个开源的容器引擎，它基于LCX容器技术，使用Go语言开发。<br>源代码托管在Github上，并遵从Apache2.0协议。<br>Docker采用C/S架构，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。</p><p>简单来说：Docker就是一种快速解决生产问题的一种技术手段。<br>简单点：Docker就是对容器进行操作管理的工具</p><h5 id="docker优缺点"><a href="#docker优缺点" class="headerlink" title="docker优缺点"></a>docker优缺点</h5><p><strong>优点：</strong><br>多：    适用场景多<br>快：    环境部署快、更新快<br>好：    好多人在用<br>省：    省钱省力省人工</p><p><strong>缺点：</strong><br>太腻歪人：  依赖操作系统<br>不善沟通：  依赖网络<br>不善理财：  银行U盾等场景不能用</p><h5 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h5><p>搜索 ： docker search 【image_name】<br>获取 ： docker pull 【image_name】<br>查看 ： docker image 【image_name】<br>docker image -a 列出本地的image（包括已删除的镜像记录）<br>镜像重命名： docker tag [old_name]:[old_version]  [new_name]:[new_verdion]<br>删除镜像：docker rmi [image_id]<br>导出镜像：（将已下载好的镜像，导出到本地）<br>                docker save  -o [导出镜像名称]   [本地镜像]<br>                例：docker save -o nginx.tar nginx</p><p>导入镜像： docker load  &lt; [image.tar_name]</p><h5 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h5><p>查看容器： docker ps<br>启动容器三种方式：</p><ol><li><p>基于镜像新建一个容器并启动<br>docker  run  &lt;参数，可选&gt;   [docker_image]  [执行命令]<br><strong>docker run 其实是两个命令的结合体docker create + docker start</strong></p></li><li><p>将关闭的容器重新启动<br>docker  start   [container_id]</p></li><li><p>守护进程方式启动(常用方式)<br>docker  run  -d  [image_name]   command…<br>例：docker run  -d nginx</p></li></ol><p>关闭容器： docker stop  [container_id]</p><p>删除容器的三种方式：<br>1.正常删除- - -删除已关闭的<br>docker  rm [container_id]</p><p>2.强制删除- - - 删除正在运行的<br>docker rm  -f  [container_id]</p><p>3.强制批量删除- - - 删除全部容器<br>docker rm  -f $(docker ps -a -q)</p><p>进入容器三种方法：<br>1.创建容器的同事并且进入容器<br>docker  run  –name  [container_name] -it [docker_image]  /bin/bash</p><p>2.手工方式进入容器<br>docker exec -it  容器id   /bin/bash</p><p>3.生产方式进入容器<br> 我们生产中常用的进入容器方法是使用脚本，脚本内容如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"># 定义进入仓库函数</span><br><span class="line">docker_in()&#123;</span><br><span class="line">  NAME_ID=$<span class="number">1</span></span><br><span class="line">  PID=$(docker inspect --format &#123;&#123;.State.Pid&#125;&#125; $NAME_ID)</span><br><span class="line">  nsenter --target $PID --mount --uts --ipc --net --pid</span><br><span class="line">&#125;</span><br><span class="line">docker_in $<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;docker是什么？&quot;&gt;&lt;a href=&quot;#docker是什么？&quot; class=&quot;headerlink&quot; title=&quot;docker是什么？&quot;&gt;&lt;/a&gt;docker是什么？&lt;/h5&gt;&lt;p&gt;docker是一个开源的容器引擎，它基于LCX容器技术，使用Go语言开发。&lt;
      
    
    </summary>
    
    
      <category term="技术 容器" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>IO阻塞与非阻塞一篇就够了</title>
    <link href="http://yoursite.com/2018/12/27/io_sync/"/>
    <id>http://yoursite.com/2018/12/27/io_sync/</id>
    <published>2018-12-27T02:49:55.298Z</published>
    <updated>2018-12-27T01:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么叫IO"><a href="#什么叫IO" class="headerlink" title="什么叫IO"></a>什么叫IO</h5><p>io通常是指计算机系统输入和输出的称呼，包括设备（键盘鼠标显示器）、总线、磁盘读写、内存等都称之为IO。</p><h5 id="IO阻塞与非阻塞"><a href="#IO阻塞与非阻塞" class="headerlink" title="IO阻塞与非阻塞"></a>IO阻塞与非阻塞</h5><p>阻塞（block）：用户态进程切换至内核态进程（read，write，accept等API函数系统调用），用户态进程一直处于挂起状态，直至内核态返回，继续工作。</p><p>非阻塞（nonblock）:用户态进程切换至内核态进程（read，write，accept等API函数系统调用），内核态进程会立马返回数据或状态码给用户态进程，用户态进程无需处于挂起状态，一直处于忙碌状态。</p><h5 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h5><p>同步（synchronous）:一个服务进行数据请求时，服务方立马告知请求结果，若数据不满足，请求方会再次主动发送请求到服务方，直至请求方得到满意的回复。（期望的结果）</p><p>异步（asynchronous）：客户向服务方请求，服务方也会立马回复请求方，不同的是，客户请求方只留下一个回调函数，用来让服务方等待条件满足后，主动通知客户方最终结果。（此方式客户方只请求了一次服务方）</p><ul><li>阻塞、非阻塞和同步异步是两个不同的概念。 </li><li>同步与异步最大的差异是对待结果的返回方式不一样。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;什么叫IO&quot;&gt;&lt;a href=&quot;#什么叫IO&quot; class=&quot;headerlink&quot; title=&quot;什么叫IO&quot;&gt;&lt;/a&gt;什么叫IO&lt;/h5&gt;&lt;p&gt;io通常是指计算机系统输入和输出的称呼，包括设备（键盘鼠标显示器）、总线、磁盘读写、内存等都称之为IO。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="技术 linux" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-linux/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2018/12/26/threadpool/"/>
    <id>http://yoursite.com/2018/12/26/threadpool/</id>
    <published>2018-12-26T14:13:35.349Z</published>
    <updated>2018-12-26T14:13:35.345Z</updated>
    
    <content type="html"><![CDATA[<h5 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h5><p>在那些情况下我们会使用到多线程：</p><p>1.阻塞调用（阻塞IO调用、等待资源）<br>2.耗时的计算（读写文件、复杂的计算）<br>3.高密度任务（高并发低延时的网络IO请求）<br>面临以上情况时都去临时创建线程会带来什么问题：</p><p>1.创建了太多的线程，系统资源就会被浪费，而且会浪费时间去创建和销毁线程。<br>2.创建线程太慢，导致执行任务结果返回过慢。<br>3.销毁线程太慢，可能会影响别的进程使用资源。<br>所以：创建多个线程，放在池子里不销毁，要用的时候就把任务丢给池子里的线程去执行，这就是线程池。<br>OK，问题来了任务由谁产生（生产者），如何丢给线程池的某个线程（消费者）？这个问题的回答需从以下几方面：</p><p>1） 生产者采用什么方式与消费者同步？<br>2） 任务如何保存？<br>3） 生产者之间的同步方式，消费者之间的同步方式？</p><p>一下所有的代码设计适用于单生产者多消费者模式</p><h5 id="条件变量结合互斥锁-任务队列"><a href="#条件变量结合互斥锁-任务队列" class="headerlink" title="条件变量结合互斥锁 + 任务队列"></a>条件变量结合互斥锁 + 任务队列</h5><p>设计如何：</p><p><img src="https://github.com/zhiyong0804/f-threadpool/blob/master/cond_mutex.png?raw=true" alt="enter description here"></p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">typedef struct queue_task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* (*run)(<span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">void</span>* argv;</span><br><span class="line">&#125;task_t;</span><br><span class="line"></span><br><span class="line">typedef struct queue</span><br><span class="line">&#123;</span><br><span class="line">    int      head;</span><br><span class="line">    int      tail;</span><br><span class="line">    int      size;</span><br><span class="line">    int      capcity;</span><br><span class="line">    task_t*  tasks;</span><br><span class="line">&#125; queue_t;</span><br><span class="line"></span><br><span class="line">typedef struct async_queue</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_t  mutex;</span><br><span class="line">    pthread_cond_t   cond;</span><br><span class="line">    int              waiting_threads;</span><br><span class="line"></span><br><span class="line">    queue_t*         queue;</span><br><span class="line">    int              quit;   <span class="comment">// 0 表示不退出  1 表示退出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调试变量 */</span></span><br><span class="line">    long long        tasked;  <span class="comment">// 已经处理完的任务数量</span></span><br><span class="line">&#125; async_queue_t;</span><br></pre></td></tr></table></figure><p>取任务的代码设计如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">task_t* async_cond_queue_pop_head(async_queue_t* q, int timeout)</span><br><span class="line">&#123;</span><br><span class="line">    task_t *task = NULL;</span><br><span class="line">    struct timeval now;</span><br><span class="line">    struct timespec outtime;</span><br><span class="line">    pthread_mutex_lock(&amp;(q-&gt;mutex));</span><br><span class="line">    <span class="keyword">if</span> (queue_is_empty(q-&gt;queue))</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;waiting_threads++;</span><br><span class="line">        <span class="keyword">while</span> (queue_is_empty(q-&gt;queue) &amp;&amp; (q-&gt;quit == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            gettimeofday(&amp;now, NULL);</span><br><span class="line">            <span class="keyword">if</span> (now.tv_usec + timeout &gt; <span class="number">1000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                outtime.tv_sec = now.tv_sec + <span class="number">1</span>;</span><br><span class="line">                outtime.tv_nsec = ((now.tv_usec + timeout) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                outtime.tv_sec = now.tv_sec;</span><br><span class="line">                outtime.tv_nsec = (now.tv_usec + timeout) * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_cond_timedwait(&amp;(q-&gt;cond), &amp;(q-&gt;mutex), &amp;outtime);</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;waiting_threads--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task = queue_pop_head(q-&gt;queue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调试代码 */</span></span><br><span class="line">    <span class="keyword">if</span> (task)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;tasked ++;</span><br><span class="line">        <span class="keyword">static</span> long long precision = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> ((q-&gt;tasked % precision ) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            time_t current_stm = get_current_timestamp();</span><br><span class="line">            precision *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;(q-&gt;mutex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情见：<a href="https://github.com/zhiyong0804/f-threadpool/blob/master/async_cond_queue.c" target="_blank" rel="noopener">https://github.com/zhiyong0804/f-threadpool/blob/master/async_cond_queue.c</a></p><p>不足：</p><p>因为Mutex引起线程挂起和唤醒的操作，在IO密集型的服务器上不是特别高效（实测过）；<br>条件变量必须和互斥锁相结合使用，使用起来较麻烦；<br>条件变量不能像eventfd一样为I/O事件驱动。<br>管道可以和I/O复用很好的融合，但是管道比eventfd多用了一个文件描述符，而且管道内核还得给其管理的缓冲区，eventfd则不需要，因此eventfd比起管道要高效。</p><h5 id="eventfd-epoll"><a href="#eventfd-epoll" class="headerlink" title="eventfd + epoll"></a>eventfd + epoll</h5><p>队列的设计：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct async_queue</span><br><span class="line">&#123;</span><br><span class="line">    queue_t*         queue;</span><br><span class="line">    int              quit;   <span class="comment">// 0 表示不退出  1 表示退出</span></span><br><span class="line"></span><br><span class="line">    int              efd;     <span class="comment">//event fd,</span></span><br><span class="line">    int              epollfd; <span class="comment">// epoll fd</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调试变量 */</span></span><br><span class="line">    long long        tasked;  <span class="comment">// 已经处理完的任务数量</span></span><br><span class="line">&#125; async_queue_t;</span><br></pre></td></tr></table></figure><p>插入任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BOOL async_eventfd_queue_push_tail(async_queue_t* q, task_t *task)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long long i = <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">if</span> (!queue_is_full(q-&gt;queue))</span><br><span class="line">    &#123;</span><br><span class="line">        queue_push_tail(q-&gt;queue, task);</span><br><span class="line"></span><br><span class="line">        struct epoll_event ev;</span><br><span class="line">        int efd = eventfd(<span class="number">0</span>, EFD_CLOEXEC | EFD_NONBLOCK);</span><br><span class="line">        <span class="keyword">if</span> (efd == <span class="number">-1</span>) printf(<span class="string">"eventfd create: %s"</span>, strerror(errno));</span><br><span class="line">        ev.events = EPOLLIN ;<span class="comment">// | EPOLLLT;</span></span><br><span class="line">        ev.data.fd = efd;</span><br><span class="line">        <span class="keyword">if</span> (epoll_ctl(q-&gt;epollfd, EPOLL_CTL_ADD, efd, &amp;ev) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> NULL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(efd, &amp;i, sizeof (i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">task_t* async_eventfd_queue_pop_head(async_queue_t* q, int timeout)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long long i = <span class="number">0</span>;</span><br><span class="line">    struct epoll_event events[MAX_EVENTS];</span><br><span class="line">    int nfds = epoll_wait(q-&gt;epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        read(events[<span class="number">0</span>].data.fd, &amp;i, sizeof (i));</span><br><span class="line">        close(events[<span class="number">0</span>].data.fd); <span class="comment">// <span class="doctag">NOTE:</span> need to close here</span></span><br><span class="line">        task_t* task = queue_pop_head(q-&gt;queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 调试代码 */</span></span><br><span class="line">        <span class="keyword">if</span> (task)</span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;tasked ++;</span><br><span class="line">            <span class="keyword">static</span> long long precision = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> ((q-&gt;tasked % precision ) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                time_t current_stm = get_current_timestamp();</span><br><span class="line">                printf(<span class="string">"%d tasks cost : %d\n"</span>, precision, current_stm - start_stm);</span><br><span class="line">                precision *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为eventfd每次写数据后，只会唤醒一个epoll_wait所在的线程，so，确保了同一时刻仅有一个线程取任务。<br>代码详情：<a href="https://github.com/zhiyong0804/f-threadpool/blob/master/async_eventfd_queue.c" target="_blank" rel="noopener">https://github.com/zhiyong0804/f-threadpool/blob/master/async_eventfd_queue.c</a></p><p>不足：<br>上面两种方案，所有的线程共用同一个队列，所以消费者线程之间取任务时需要做同步，生产者和消费者也需要做同步。用一个形象的图可以表示如下：<br><img src="https://github.com/zhiyong0804/f-threadpool/blob/master/fuck.png?raw=true" alt="enter description here"></p><h5 id="eventfd-epoll-多队列的设计"><a href="#eventfd-epoll-多队列的设计" class="headerlink" title="eventfd + epoll + 多队列的设计"></a>eventfd + epoll + 多队列的设计</h5><p>设计思想如下图：<br><img src="https://github.com/zhiyong0804/f-threadpool/blob/master/multiple.png?raw=true" alt="enter description here"></p><p>代码详情见：<a href="https://github.com/zhiyong0804/StreamingServer" target="_blank" rel="noopener">https://github.com/zhiyong0804/StreamingServer</a><br>Oh my god, huge project, where can i find thre thread pool source. 说来话长，这个代码是EasyDarwin的源码，但是因为某种原因，EasyDarwin的源码不再共享，取而代之的打赏的二维码，so， 我把他们的源码做了局部的修改，然后重新提交，且命名为StreamingServer，里面的设计是采用条件变量做同步的，但是多队列的思想是可以沿袭的，打算加班用eventfd实现。</p><p>这样一种设计是不是让我们能够想到下面这幅图呢？<br><img src="https://github.com/zhiyong0804/f-threadpool/blob/master/lijiao.jpg?raw=true" alt="enter description here"></p><p>之前所有的道路遇到十字路口时（共享了资源），只能使用信号灯去同步汽车的行驶，现如今，把共享资源fuck掉了，用立交桥，爽吧！！！？</p><p>并行编程是很难的，可以参考以下这篇论文:</p><p>并发编程的11个问题英文版：<a href="http://www.it610.com/article/4462577.htm" target="_blank" rel="noopener">http://www.it610.com/article/4462577.htm</a><br>并发编程的11个问题中文版：<a href="https://blog.csdn.net/mergerly/article/details/39028861" target="_blank" rel="noopener">https://blog.csdn.net/mergerly/article/details/39028861</a><br>我也并不聪明，可是当我2年前接触到ZeroMQ这个项目时，我特别惊叹于Pieter Hintjens的一些观点，“真正的并发就是不共享资源”</p><p>so，方案四的设计</p><h5 id="Lock-free"><a href="#Lock-free" class="headerlink" title="Lock-free"></a>Lock-free</h5><p>当我们在第三种方案上，增加了多队列，即每线程每队列时，实际上我们的队列设计变成了一个单生产者单消费者共享的队列，但是这个队列的写指针（tail）仅会被生产者使用，读指针（head）仅会被消费者使用，实际上没有共享任何资源，当然queue_t的size变量，我正在重构把它拿掉。</p><p><strong>OK，那么在这种设计下，消费者线程如何“等待”如何“取”任务？</strong></p><p>实际上，上面的三种方案对于消费者线程都是被动等待通知，收到通知则去取任务，实际上，我们完全可以设计成“轮询”的方案，就是不停地看自己的任务队列里是否有任务，没有就循环一次，中间当然可以加上sched_yield操作，让其它的线程能够得到调度。</p><h5 id="线程池的尺寸设计多大合适？"><a href="#线程池的尺寸设计多大合适？" class="headerlink" title="线程池的尺寸设计多大合适？"></a>线程池的尺寸设计多大合适？</h5><p>CPU密集型的：<br>thread size = N + 1;<br>IO密集型的：<br>thread size = 2*N + 1;</p><p>当然这不是绝对的，所以在mariadb的线程池是可以动态调整这个尺寸的。</p><p>——————————————全文完—————————————————–</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;为什么需要线程池&quot;&gt;&lt;a href=&quot;#为什么需要线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么需要线程池&quot;&gt;&lt;/a&gt;为什么需要线程池&lt;/h5&gt;&lt;p&gt;在那些情况下我们会使用到多线程：&lt;/p&gt;
&lt;p&gt;1.阻塞调用（阻塞IO调用、等待资源）&lt;br
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Mutex的实现原理</title>
    <link href="http://yoursite.com/2018/12/26/mutex/"/>
    <id>http://yoursite.com/2018/12/26/mutex/</id>
    <published>2018-12-26T13:34:02.511Z</published>
    <updated>2018-12-26T13:31:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>互斥锁主要用于实现内核中的互斥访问功能。内核互斥锁是在原子 API 之上实现的，但这对于内核用户是不可见的。对它的访问必须遵循一些规则：同一时间只能有一个任务持有互斥锁，而且只有这个任务可以对互斥锁进行解锁。互斥锁不能进行递归锁定或解锁。一个互斥锁对象必须通过其API初始化，而不能使用memset或复制初始化。一个任务在持有互斥锁的时候是不能结束的。互斥锁所使用的内存区域是不能被释放的。使用中的互斥锁是不能被重新初始化的。并且互斥锁不能用于中断上下文。但是互斥锁比当前的内核信号量选项更快，并且更加紧凑，因此如果它们满足您的需求，那么它们将是您明智的选择。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.15</span> kernel</span><br><span class="line">include/linux/mutex.h</span><br><span class="line">struct mutex &#123;</span><br><span class="line">atomic_long_towner;</span><br><span class="line">spinlock_twait_lock;</span><br><span class="line">#ifdef CONFIG_MUTEX_SPIN_ON_OWNER</span><br><span class="line">struct optimistic_spin_queue osq; <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line">#endif</span><br><span class="line">struct list_headwait_list;</span><br><span class="line">#ifdef CONFIG_DEBUG_MUTEXES</span><br><span class="line"><span class="keyword">void</span>*magic;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="line">struct lockdep_mapdep_map;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1.owner<br>锁的持有者, 如果没有task持有则为0，否则是获取到锁的pid。<br>2.wait_lock<br>自旋锁，内核用来保护代码执行区的。<br>3.wait_list<br>等待队列，是一个链表，如果task没有获取owner == 0，则把task加入到这个等待队列，并且将进程设置为TASK_UNINTERRUPTIBLE状态，直到被wakeup调用唤醒执行。</p><h3 id="mutex-lock"><a href="#mutex-lock" class="headerlink" title="mutex_lock"></a>mutex_lock</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux/kener/locking/mutex.c:252</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mutex_lock - acquire the mutex</span></span><br><span class="line"><span class="comment"> * @lock: the mutex to be acquired</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Lock the mutex exclusively for this task. If the mutex is not</span></span><br><span class="line"><span class="comment"> * available right now, it will sleep until it can get it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The mutex must later on be released by the same task that</span></span><br><span class="line"><span class="comment"> * acquired it. Recursive locking is not allowed. The task</span></span><br><span class="line"><span class="comment"> * may not exit without first unlocking the mutex. Also, kernel</span></span><br><span class="line"><span class="comment"> * memory where the mutex resides must not be freed with</span></span><br><span class="line"><span class="comment"> * the mutex still locked. The mutex must first be initialized</span></span><br><span class="line"><span class="comment"> * (or statically defined) before it can be locked. memset()-ing</span></span><br><span class="line"><span class="comment"> * the mutex to 0 is not allowed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (The CONFIG_DEBUG_MUTEXES .config option turns on debugging</span></span><br><span class="line"><span class="comment"> * checks that will enforce the restrictions and will also do</span></span><br><span class="line"><span class="comment"> * deadlock debugging)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is similar to (but not equivalent to) down().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __sched mutex_lock(struct mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!__mutex_trylock_fast(lock))</span><br><span class="line">__mutex_lock_slowpath(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline bool __mutex_trylock_fast(struct mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long curr = (unsigned long)current;</span><br><span class="line">unsigned long zero = <span class="number">0</span>UL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (atomic_long_try_cmpxchg_acquire(&amp;lock-&gt;owner, &amp;zero, curr))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lock a mutex (possibly interruptible), slowpath:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline int __sched</span><br><span class="line">__mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,</span><br><span class="line">    struct lockdep_map *nest_lock, unsigned long ip,</span><br><span class="line">    struct ww_acquire_ctx *ww_ctx, <span class="keyword">const</span> bool use_ww_ctx)</span><br><span class="line">&#123;</span><br><span class="line">struct mutex_waiter waiter;</span><br><span class="line">bool first = <span class="literal">false</span>;</span><br><span class="line">struct ww_mutex *ww;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line">ww = container_of(lock, struct ww_mutex, base);</span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx) &#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(ww_ctx == READ_ONCE(ww-&gt;ctx)))</span><br><span class="line"><span class="keyword">return</span> -EALREADY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reset the wounded flag after a kill. No other process can</span></span><br><span class="line"><span class="comment"> * race and wound us here since they can't have a valid owner</span></span><br><span class="line"><span class="comment"> * pointer if we don't have any locks held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ww_ctx-&gt;acquired == <span class="number">0</span>)</span><br><span class="line">ww_ctx-&gt;wounded = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preempt_disable();</span><br><span class="line">mutex_acquire_nest(&amp;lock-&gt;dep_map, subclass, <span class="number">0</span>, nest_lock, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock) ||</span><br><span class="line">    mutex_optimistic_spin(lock, ww_ctx, use_ww_ctx, NULL)) &#123;</span><br><span class="line"><span class="comment">/* got the lock, yay! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx)</span><br><span class="line">ww_mutex_set_context_fastpath(ww, ww_ctx);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * After waiting to acquire the wait_lock, try again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock)) &#123;</span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx)</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line"></span><br><span class="line">goto skip_wait;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug_mutex_lock_common(lock, &amp;waiter);</span><br><span class="line"></span><br><span class="line">lock_contended(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!use_ww_ctx) &#123;</span><br><span class="line"><span class="comment">/* add waiting tasks to the end of the waitqueue (FIFO): */</span></span><br><span class="line">__mutex_add_waiter(lock, &amp;waiter, &amp;lock-&gt;wait_list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEBUG_MUTEXES</span><br><span class="line">waiter.ww_ctx = MUTEX_POISON_WW_CTX;</span><br><span class="line">#endif</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add in stamp order, waking up waiters that must kill</span></span><br><span class="line"><span class="comment"> * themselves.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = __ww_mutex_add_waiter(&amp;waiter, lock, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">goto err_early_kill;</span><br><span class="line"></span><br><span class="line">waiter.ww_ctx = ww_ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">waiter.task = current;</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Once we hold wait_lock, we're serialized against</span></span><br><span class="line"><span class="comment"> * mutex_unlock() handing the lock off to us, do a trylock</span></span><br><span class="line"><span class="comment"> * before testing the error conditions to make sure we pick up</span></span><br><span class="line"><span class="comment"> * the handoff.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock))</span><br><span class="line">goto acquired;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check for signals and kill conditions while holding</span></span><br><span class="line"><span class="comment"> * wait_lock. This ensures the lock cancellation is ordered</span></span><br><span class="line"><span class="comment"> * against mutex_unlock() and wake-ups do not go missing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal_pending_state(state, current))) &#123;</span><br><span class="line">ret = -EINTR;</span><br><span class="line">goto err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx) &#123;</span><br><span class="line">ret = __ww_mutex_check_kill(lock, &amp;waiter, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">goto err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ww_mutex needs to always recheck its position since its waiter</span></span><br><span class="line"><span class="comment"> * list is not FIFO ordered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((use_ww_ctx &amp;&amp; ww_ctx) || !first) &#123;</span><br><span class="line">first = __mutex_waiter_is_first(lock, &amp;waiter);</span><br><span class="line"><span class="keyword">if</span> (first)</span><br><span class="line">__mutex_set_flag(lock, MUTEX_FLAG_HANDOFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Here we order against unlock; we must either see it change</span></span><br><span class="line"><span class="comment"> * state back to RUNNING and fall through the next schedule(),</span></span><br><span class="line"><span class="comment"> * or we must see its unlock and acquire.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock) ||</span><br><span class="line">    (first &amp;&amp; mutex_optimistic_spin(lock, ww_ctx, use_ww_ctx, &amp;waiter)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">&#125;</span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">acquired:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wound-Wait; we stole the lock (!first_waiter), check the</span></span><br><span class="line"><span class="comment"> * waiters as anyone might want to wound us.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!ww_ctx-&gt;is_wait_die &amp;&amp;</span><br><span class="line">    !__mutex_waiter_is_first(lock, &amp;waiter))</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_remove_waiter(lock, &amp;waiter, current);</span><br><span class="line"><span class="keyword">if</span> (likely(list_empty(&amp;lock-&gt;wait_list)))</span><br><span class="line">__mutex_clear_flag(lock, MUTEX_FLAGS);</span><br><span class="line"></span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line"></span><br><span class="line">skip_wait:</span><br><span class="line"><span class="comment">/* got the lock - cleanup and rejoice! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx)</span><br><span class="line">ww_mutex_lock_acquired(ww, ww_ctx);</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">mutex_remove_waiter(lock, &amp;waiter, current);</span><br><span class="line">err_early_kill:</span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line">mutex_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, ip);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码可以看出，如果task获取不到锁，则先把自己加入到等待队列，并且设置进程状态为TASK_UNINTERRUPTIBLE，让出CPU的执行。</p><h3 id="mutex-unlock"><a href="#mutex-unlock" class="headerlink" title="mutex_unlock"></a>mutex_unlock</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mutex_unlock - release the mutex</span></span><br><span class="line"><span class="comment"> * @lock: the mutex to be released</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unlock a mutex that has been locked by this task previously.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function must not be used in interrupt context. Unlocking</span></span><br><span class="line"><span class="comment"> * of a not locked mutex is not allowed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is similar to (but not equivalent to) up().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __sched mutex_unlock(struct mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">#ifndef CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="line"><span class="keyword">if</span> (__mutex_unlock_fast(lock))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">#endif</span><br><span class="line">__mutex_unlock_slowpath(lock, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Release the lock, slowpath:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __sched __mutex_unlock_slowpath(struct mutex *lock, unsigned long ip)</span><br><span class="line">&#123;</span><br><span class="line">struct task_struct *next = NULL;</span><br><span class="line">DEFINE_WAKE_Q(wake_q);</span><br><span class="line">unsigned long owner;</span><br><span class="line"></span><br><span class="line">mutex_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, ip);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Release the lock before (potentially) taking the spinlock such that</span></span><br><span class="line"><span class="comment"> * other contenders can get on with things ASAP.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Except when HANDOFF, in that case we must not clear the owner field,</span></span><br><span class="line"><span class="comment"> * but instead set it to the top waiter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">owner = atomic_long_read(&amp;lock-&gt;owner);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">unsigned long old;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEBUG_MUTEXES</span><br><span class="line">DEBUG_LOCKS_WARN_ON(__owner_task(owner) != current);</span><br><span class="line">DEBUG_LOCKS_WARN_ON(owner &amp; MUTEX_FLAG_PICKUP);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (owner &amp; MUTEX_FLAG_HANDOFF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">old = atomic_long_cmpxchg_release(&amp;lock-&gt;owner, owner,</span><br><span class="line">  __owner_flags(owner));</span><br><span class="line"><span class="keyword">if</span> (old == owner) &#123;</span><br><span class="line"><span class="keyword">if</span> (owner &amp; MUTEX_FLAG_WAITERS)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">owner = old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">debug_mutex_unlock(lock);</span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;lock-&gt;wait_list)) &#123;</span><br><span class="line"><span class="comment">/* get the first entry from the wait-list: */</span></span><br><span class="line">struct mutex_waiter *waiter =</span><br><span class="line">list_first_entry(&amp;lock-&gt;wait_list,</span><br><span class="line"> struct mutex_waiter, list);</span><br><span class="line"></span><br><span class="line">next = waiter-&gt;task;</span><br><span class="line"></span><br><span class="line">debug_mutex_wake_waiter(lock, waiter);</span><br><span class="line">wake_q_add(&amp;wake_q, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (owner &amp; MUTEX_FLAG_HANDOFF)</span><br><span class="line">__mutex_handoff(lock, next);</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line"></span><br><span class="line">wake_up_q(&amp;wake_q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放锁时，先检查ower是否是自己，如果是的，则从等待队列（wait_list）拿取第一个task，并且调用wake_up_q去唤醒task，task恢复执行。</p><p>——————————————全文完—————————————————–</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;互斥锁主要用于实现内核中的互斥访问功能。内核互斥锁是在原子 API 之上实现的，但这对于内核用户是不可见的。对它的访问必须遵循一些规则：同一时间只能有一个任务持有互斥锁，而且只有这个任务可以对互斥锁进行解锁。互斥锁不能进行递归锁定或解锁。一个互斥锁对象必须通过其API初始化
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>协程</title>
    <link href="http://yoursite.com/2018/12/26/xiecheng/"/>
    <id>http://yoursite.com/2018/12/26/xiecheng/</id>
    <published>2018-12-26T12:39:35.468Z</published>
    <updated>2018-12-26T12:39:35.464Z</updated>
    
    <content type="html"><![CDATA[<p>协程，英文（coroutines）,是一种比线程更加轻量级的存在。</p><ol><li>一个进程可以拥有多个线程，一个线程也可以拥有多个协程。</li><li>最重要的是，协程不是被操作系统内核所管理（内核调用），而完全是由用户态程序所控制（用户态执行）。</li><li>这样带来的好处就是性能得到了很大的提升，不像进程线程切换带来的消耗资源，cpu的调度。</li><li>协程的开销远远小于线程的开销。</li><li>协程并不想线程需要锁机制，协程中控制共享资源不加锁，只需要判断状态就好，所以执行效率比多线程高的多。</li></ol><p>因为协程是一个线程执行，那怎么利用多核CPU呢？<br>        最简单的方法就是多进程+协程，既充分利用多核，又充分发挥协程的高效率。</p><p>==协程允许我们写同步代码的逻辑，却做着异步的事，避免回调嵌套，使得代码逻辑清晰（协程是追求极限性能和优美的代码结构产物）==</p><p><em>参考手册</em> : <a href="http://ntycobook.ntytcp.com/" target="_blank" rel="noopener">协程详细介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;协程，英文（coroutines）,是一种比线程更加轻量级的存在。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个进程可以拥有多个线程，一个线程也可以拥有多个协程。&lt;/li&gt;
&lt;li&gt;最重要的是，协程不是被操作系统内核所管理（内核调用），而完全是由用户态程序所控制（用户态执行）。&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://yoursite.com/2018/12/26/git/"/>
    <id>http://yoursite.com/2018/12/26/git/</id>
    <published>2018-12-26T12:36:16.198Z</published>
    <updated>2018-12-26T12:36:16.198Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-git与SVN的区别"><a href="#1-git与SVN的区别" class="headerlink" title="1.git与SVN的区别"></a>1.git与SVN的区别</h5><p>git是分布式版本控制系统。必须客户端连接上服务端才能正常工作。<br>svn是集中式版本控制系统。每台机器就是一个单独运行的库，方便高效便捷的开发。</p><h5 id="2-git常用命令"><a href="#2-git常用命令" class="headerlink" title="2.git常用命令"></a>2.git常用命令</h5><p>git config -global ; 配置环境信息<br>git init ；将目录变成git管理的仓库，初始化仓库<br>git add ;提交到暂存区<br>git commit; 提交到本地仓<br>git status ;查看仓库是否有文件未提交<br>git diff 文件名；比较文件<br>git reset -hard HEAD~100;回到前100个版本<br>git reset -hard(版本号)；回到指定的版本号<br>git  reflog；取得版本号</p><p>git checkout -b ;创建并且换到分支<br>git branch dev ；创建分支<br>git checkout dev；切换分支<br>git merge dev; 将dev分支上的内容合并到主支master上<br>git branch -d name;删除分支</p><p><em>参考手册</em> :  <a href="http://47.106.79.26:4000/" target="_blank" rel="noopener">git详细介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-git与SVN的区别&quot;&gt;&lt;a href=&quot;#1-git与SVN的区别&quot; class=&quot;headerlink&quot; title=&quot;1.git与SVN的区别&quot;&gt;&lt;/a&gt;1.git与SVN的区别&lt;/h5&gt;&lt;p&gt;git是分布式版本控制系统。必须客户端连接上服务端才能正常工
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Lua脚本式编程</title>
    <link href="http://yoursite.com/2018/12/26/lua/"/>
    <id>http://yoursite.com/2018/12/26/lua/</id>
    <published>2018-12-26T08:58:27.539Z</published>
    <updated>2018-12-26T08:57:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h3><p>单行注释：–<br>多行注释：–[[ 内容–]]</p><p>lua最好<strong>不要使用</strong>下划线加大字母的标识符，因为lua的保留字是这样的。<br>lua不允许使用特殊字符如@$%来定义标志符。</p><p>默认情况下，变量总是认为全局。<br>删除全局变量，只需要将变量赋值nil .</p><p>lua的数据类型：nil 、boolean、number、string、userdata、function、thread和table。</p><p>nil作为比较时应该加上双引号，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type(x) == &quot;nil&quot;</span><br></pre></td></tr></table></figure><p>boolean类型只有两个可选值：true 和 false<br>lua把false和nil看作是“假”，其他都为真。</p><p>number（数字）：lua只有一种number类型，double双精度类型，默认类型可以修改luaconf.h里面的定义。</p><p>string（字符串）：由一对双引号或单引号来表示，也可以用2个方括号“[[ ]]”来表示“一块”字符串。</p><p>对一个数字字符串上进行算术操作时，lua会尝试将这个数字字符串转换成一个数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(“<span class="number">2</span>”+<span class="number">6</span>)   <span class="number">8.0</span></span><br><span class="line">print(<span class="string">"2"</span>+<span class="string">"6"</span>) <span class="number">8.0</span></span><br></pre></td></tr></table></figure><p>字符串连接使用的是 . .如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"a"</span> .. <span class="string">"b"</span>)  ab</span><br><span class="line">print(<span class="number">157</span> .. <span class="number">428</span>) <span class="number">157428</span></span><br></pre></td></tr></table></figure><p>#计算字符串的长度。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len =<span class="string">"www.runoob.com"</span></span><br><span class="line">print(#len)                 14</span><br><span class="line">print(#"www.runoob.com") 14</span><br></pre></td></tr></table></figure><h3 id="2-宿主语言C-C"><a href="#2-宿主语言C-C" class="headerlink" title="2.宿主语言C/C++"></a>2.宿主语言C/C++</h3><p>==虚拟栈==<br>        无论何时lua调用C，被调用的函数都得到一个新的栈，这个栈独立于C函数本身的栈，也独立于之前的栈。<br>        方便起见，所有正对栈的API查询操作都不严格遵守栈的操作规则。而是可以用一个索引来指向栈上的任何元素：<br>        ==正的索引指的是栈上的绝对位置（从1开始），负的索引指从栈顶开始的偏移量。==</p><p>Lua_checkstack:扩大可用堆栈的尺寸<br>LUA_MINSTACK一般被定义为20。</p><p>压入栈的数据类型包括数值、字符串、指针、table、闭包。</p><p><img src="./attachments/1545806848964.drawio.html" alt="Diagram"></p><p>Lua_pushcclosure(L,func,0)；创建并压入一个闭包<br>Lua_createtable(L,0,0)；新建并压入一个表<br>Lua_pushnumber(L,343)；压入一个数字<br>Lua_pushstring(L,”Nystr”)；压入一个字符串</p><p>Lua中，number、boolean、nil、lightuserdata四种类型的值是直接存在栈上元素里和垃圾回收无关。<br>Lua中，string、table、closure、userdata、thread存在栈上元素里的只是指针，他们都会在生命周期结束后被垃圾回收。</p><p>Lua_push<em>族函数都有“创建一个类型的值并压入”的语义。<br>Lua value -&gt; C value时，是通过Lua_to</em>族api实现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">取表中元素 </span><br><span class="line"><span class="keyword">void</span> lua_getfield(lua_state *L,int index,<span class="keyword">const</span> char *K)</span><br><span class="line">操作： arr = stack[index]</span><br><span class="line">stack.push(arr[K])</span><br><span class="line">取表中键为K的元素，这里的表是由index指向的栈上的一个表。</span><br><span class="line">栈高度+<span class="number">1</span>，栈顶元素是（stack[index]）[K]。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本语法&quot;&gt;&lt;a href=&quot;#1-基本语法&quot; class=&quot;headerlink&quot; title=&quot;1.基本语法&quot;&gt;&lt;/a&gt;1.基本语法&lt;/h3&gt;&lt;p&gt;单行注释：–&lt;br&gt;多行注释：–[[ 内容–]]&lt;/p&gt;
&lt;p&gt;lua最好&lt;strong&gt;不要使用&lt;/str
      
    
    </summary>
    
    
      <category term="技术,编程语言" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP通讯知识</title>
    <link href="http://yoursite.com/2018/11/25/TCP-IP%E9%80%9A%E8%AE%AF%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/11/25/TCP-IP通讯知识/</id>
    <published>2018-11-25T07:28:09.000Z</published>
    <updated>2018-11-25T07:28:51.974Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="TCP" scheme="http://yoursite.com/categories/TCP/"/>
    
    
      <category term="TCP网络通信" scheme="http://yoursite.com/tags/TCP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>test_md</title>
    <link href="http://yoursite.com/2018/11/23/test-md/"/>
    <id>http://yoursite.com/2018/11/23/test-md/</id>
    <published>2018-11-23T12:06:11.000Z</published>
    <updated>2018-11-25T07:09:53.890Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="test" scheme="http://yoursite.com/categories/test/"/>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/11/23/hello-world/"/>
    <id>http://yoursite.com/2017/11/23/hello-world/</id>
    <published>2017-11-23T12:06:11.000Z</published>
    <updated>2018-11-25T07:23:27.648Z</updated>
    
    <content type="html"><![CDATA[<p>notshow: true<br>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;notshow: true&lt;br&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a hr
      
    
    </summary>
    
      <category term="hexo查询" scheme="http://yoursite.com/categories/hexo%E6%9F%A5%E8%AF%A2/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
